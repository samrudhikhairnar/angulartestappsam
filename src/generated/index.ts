// Code generated by Prisma (prisma@1.34.5). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  connector: (where?: ConnectorWhereInput) => Promise<boolean>;
  databaseUser: (where?: DatabaseUserWhereInput) => Promise<boolean>;
  entity: (where?: EntityWhereInput) => Promise<boolean>;
  entityMap: (where?: EntityMapWhereInput) => Promise<boolean>;
  field: (where?: FieldWhereInput) => Promise<boolean>;
  fieldMap: (where?: FieldMapWhereInput) => Promise<boolean>;
  log: (where?: LogWhereInput) => Promise<boolean>;
  plugin: (where?: PluginWhereInput) => Promise<boolean>;
  pluginCategory: (where?: PluginCategoryWhereInput) => Promise<boolean>;
  pluginParam: (where?: PluginParamWhereInput) => Promise<boolean>;
  process: (where?: ProcessWhereInput) => Promise<boolean>;
  processHistory: (where?: ProcessHistoryWhereInput) => Promise<boolean>;
  schedule: (where?: ScheduleWhereInput) => Promise<boolean>;
  sourceTargetFieldmapping: (
    where?: SourceTargetFieldmappingWhereInput
  ) => Promise<boolean>;
  subcriptionHistory: (
    where?: SubcriptionHistoryWhereInput
  ) => Promise<boolean>;
  subscriberEntity: (where?: SubscriberEntityWhereInput) => Promise<boolean>;
  subscriberEntityMap: (
    where?: SubscriberEntityMapWhereInput
  ) => Promise<boolean>;
  subscriberField: (where?: SubscriberFieldWhereInput) => Promise<boolean>;
  subscriberFieldMap: (
    where?: SubscriberFieldMapWhereInput
  ) => Promise<boolean>;
  subscriberProcess: (where?: SubscriberProcessWhereInput) => Promise<boolean>;
  subscriptionIntegration: (
    where?: SubscriptionIntegrationWhereInput
  ) => Promise<boolean>;
  testimonial: (where?: TestimonialWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  connector: (where: ConnectorWhereUniqueInput) => ConnectorNullablePromise;
  connectors: (args?: {
    where?: ConnectorWhereInput;
    orderBy?: ConnectorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Connector>;
  connectorsConnection: (args?: {
    where?: ConnectorWhereInput;
    orderBy?: ConnectorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ConnectorConnectionPromise;
  databaseUser: (
    where: DatabaseUserWhereUniqueInput
  ) => DatabaseUserNullablePromise;
  databaseUsers: (args?: {
    where?: DatabaseUserWhereInput;
    orderBy?: DatabaseUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DatabaseUser>;
  databaseUsersConnection: (args?: {
    where?: DatabaseUserWhereInput;
    orderBy?: DatabaseUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DatabaseUserConnectionPromise;
  entity: (where: EntityWhereUniqueInput) => EntityNullablePromise;
  entities: (args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Entity>;
  entitiesConnection: (args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EntityConnectionPromise;
  entityMap: (where: EntityMapWhereUniqueInput) => EntityMapNullablePromise;
  entityMaps: (args?: {
    where?: EntityMapWhereInput;
    orderBy?: EntityMapOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EntityMap>;
  entityMapsConnection: (args?: {
    where?: EntityMapWhereInput;
    orderBy?: EntityMapOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EntityMapConnectionPromise;
  field: (where: FieldWhereUniqueInput) => FieldNullablePromise;
  fields: (args?: {
    where?: FieldWhereInput;
    orderBy?: FieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Field>;
  fieldsConnection: (args?: {
    where?: FieldWhereInput;
    orderBy?: FieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FieldConnectionPromise;
  fieldMap: (where: FieldMapWhereUniqueInput) => FieldMapNullablePromise;
  fieldMaps: (args?: {
    where?: FieldMapWhereInput;
    orderBy?: FieldMapOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FieldMap>;
  fieldMapsConnection: (args?: {
    where?: FieldMapWhereInput;
    orderBy?: FieldMapOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FieldMapConnectionPromise;
  log: (where: LogWhereUniqueInput) => LogNullablePromise;
  logs: (args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Log>;
  logsConnection: (args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LogConnectionPromise;
  plugin: (where: PluginWhereUniqueInput) => PluginNullablePromise;
  plugins: (args?: {
    where?: PluginWhereInput;
    orderBy?: PluginOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Plugin>;
  pluginsConnection: (args?: {
    where?: PluginWhereInput;
    orderBy?: PluginOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PluginConnectionPromise;
  pluginCategory: (
    where: PluginCategoryWhereUniqueInput
  ) => PluginCategoryNullablePromise;
  pluginCategories: (args?: {
    where?: PluginCategoryWhereInput;
    orderBy?: PluginCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PluginCategory>;
  pluginCategoriesConnection: (args?: {
    where?: PluginCategoryWhereInput;
    orderBy?: PluginCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PluginCategoryConnectionPromise;
  pluginParam: (
    where: PluginParamWhereUniqueInput
  ) => PluginParamNullablePromise;
  pluginParams: (args?: {
    where?: PluginParamWhereInput;
    orderBy?: PluginParamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PluginParam>;
  pluginParamsConnection: (args?: {
    where?: PluginParamWhereInput;
    orderBy?: PluginParamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PluginParamConnectionPromise;
  process: (where: ProcessWhereUniqueInput) => ProcessNullablePromise;
  processes: (args?: {
    where?: ProcessWhereInput;
    orderBy?: ProcessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Process>;
  processesConnection: (args?: {
    where?: ProcessWhereInput;
    orderBy?: ProcessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProcessConnectionPromise;
  processHistory: (
    where: ProcessHistoryWhereUniqueInput
  ) => ProcessHistoryNullablePromise;
  processHistories: (args?: {
    where?: ProcessHistoryWhereInput;
    orderBy?: ProcessHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProcessHistory>;
  processHistoriesConnection: (args?: {
    where?: ProcessHistoryWhereInput;
    orderBy?: ProcessHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProcessHistoryConnectionPromise;
  schedule: (where: ScheduleWhereUniqueInput) => ScheduleNullablePromise;
  schedules: (args?: {
    where?: ScheduleWhereInput;
    orderBy?: ScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Schedule>;
  schedulesConnection: (args?: {
    where?: ScheduleWhereInput;
    orderBy?: ScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ScheduleConnectionPromise;
  sourceTargetFieldmapping: (
    where: SourceTargetFieldmappingWhereUniqueInput
  ) => SourceTargetFieldmappingNullablePromise;
  sourceTargetFieldmappings: (args?: {
    where?: SourceTargetFieldmappingWhereInput;
    orderBy?: SourceTargetFieldmappingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SourceTargetFieldmapping>;
  sourceTargetFieldmappingsConnection: (args?: {
    where?: SourceTargetFieldmappingWhereInput;
    orderBy?: SourceTargetFieldmappingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SourceTargetFieldmappingConnectionPromise;
  subcriptionHistory: (
    where: SubcriptionHistoryWhereUniqueInput
  ) => SubcriptionHistoryNullablePromise;
  subcriptionHistories: (args?: {
    where?: SubcriptionHistoryWhereInput;
    orderBy?: SubcriptionHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SubcriptionHistory>;
  subcriptionHistoriesConnection: (args?: {
    where?: SubcriptionHistoryWhereInput;
    orderBy?: SubcriptionHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubcriptionHistoryConnectionPromise;
  subscriberEntity: (
    where: SubscriberEntityWhereUniqueInput
  ) => SubscriberEntityNullablePromise;
  subscriberEntities: (args?: {
    where?: SubscriberEntityWhereInput;
    orderBy?: SubscriberEntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SubscriberEntity>;
  subscriberEntitiesConnection: (args?: {
    where?: SubscriberEntityWhereInput;
    orderBy?: SubscriberEntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubscriberEntityConnectionPromise;
  subscriberEntityMap: (
    where: SubscriberEntityMapWhereUniqueInput
  ) => SubscriberEntityMapNullablePromise;
  subscriberEntityMaps: (args?: {
    where?: SubscriberEntityMapWhereInput;
    orderBy?: SubscriberEntityMapOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SubscriberEntityMap>;
  subscriberEntityMapsConnection: (args?: {
    where?: SubscriberEntityMapWhereInput;
    orderBy?: SubscriberEntityMapOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubscriberEntityMapConnectionPromise;
  subscriberField: (
    where: SubscriberFieldWhereUniqueInput
  ) => SubscriberFieldNullablePromise;
  subscriberFields: (args?: {
    where?: SubscriberFieldWhereInput;
    orderBy?: SubscriberFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SubscriberField>;
  subscriberFieldsConnection: (args?: {
    where?: SubscriberFieldWhereInput;
    orderBy?: SubscriberFieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubscriberFieldConnectionPromise;
  subscriberFieldMap: (
    where: SubscriberFieldMapWhereUniqueInput
  ) => SubscriberFieldMapNullablePromise;
  subscriberFieldMaps: (args?: {
    where?: SubscriberFieldMapWhereInput;
    orderBy?: SubscriberFieldMapOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SubscriberFieldMap>;
  subscriberFieldMapsConnection: (args?: {
    where?: SubscriberFieldMapWhereInput;
    orderBy?: SubscriberFieldMapOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubscriberFieldMapConnectionPromise;
  subscriberProcess: (
    where: SubscriberProcessWhereUniqueInput
  ) => SubscriberProcessNullablePromise;
  subscriberProcesses: (args?: {
    where?: SubscriberProcessWhereInput;
    orderBy?: SubscriberProcessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SubscriberProcess>;
  subscriberProcessesConnection: (args?: {
    where?: SubscriberProcessWhereInput;
    orderBy?: SubscriberProcessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubscriberProcessConnectionPromise;
  subscriptionIntegration: (
    where: SubscriptionIntegrationWhereUniqueInput
  ) => SubscriptionIntegrationNullablePromise;
  subscriptionIntegrations: (args?: {
    where?: SubscriptionIntegrationWhereInput;
    orderBy?: SubscriptionIntegrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SubscriptionIntegration>;
  subscriptionIntegrationsConnection: (args?: {
    where?: SubscriptionIntegrationWhereInput;
    orderBy?: SubscriptionIntegrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubscriptionIntegrationConnectionPromise;
  testimonial: (
    where: TestimonialWhereUniqueInput
  ) => TestimonialNullablePromise;
  testimonials: (args?: {
    where?: TestimonialWhereInput;
    orderBy?: TestimonialOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Testimonial>;
  testimonialsConnection: (args?: {
    where?: TestimonialWhereInput;
    orderBy?: TestimonialOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TestimonialConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createConnector: (data: ConnectorCreateInput) => ConnectorPromise;
  updateConnector: (args: {
    data: ConnectorUpdateInput;
    where: ConnectorWhereUniqueInput;
  }) => ConnectorPromise;
  updateManyConnectors: (args: {
    data: ConnectorUpdateManyMutationInput;
    where?: ConnectorWhereInput;
  }) => BatchPayloadPromise;
  upsertConnector: (args: {
    where: ConnectorWhereUniqueInput;
    create: ConnectorCreateInput;
    update: ConnectorUpdateInput;
  }) => ConnectorPromise;
  deleteConnector: (where: ConnectorWhereUniqueInput) => ConnectorPromise;
  deleteManyConnectors: (where?: ConnectorWhereInput) => BatchPayloadPromise;
  createDatabaseUser: (data: DatabaseUserCreateInput) => DatabaseUserPromise;
  updateDatabaseUser: (args: {
    data: DatabaseUserUpdateInput;
    where: DatabaseUserWhereUniqueInput;
  }) => DatabaseUserPromise;
  updateManyDatabaseUsers: (args: {
    data: DatabaseUserUpdateManyMutationInput;
    where?: DatabaseUserWhereInput;
  }) => BatchPayloadPromise;
  upsertDatabaseUser: (args: {
    where: DatabaseUserWhereUniqueInput;
    create: DatabaseUserCreateInput;
    update: DatabaseUserUpdateInput;
  }) => DatabaseUserPromise;
  deleteDatabaseUser: (
    where: DatabaseUserWhereUniqueInput
  ) => DatabaseUserPromise;
  deleteManyDatabaseUsers: (
    where?: DatabaseUserWhereInput
  ) => BatchPayloadPromise;
  createEntity: (data: EntityCreateInput) => EntityPromise;
  updateEntity: (args: {
    data: EntityUpdateInput;
    where: EntityWhereUniqueInput;
  }) => EntityPromise;
  updateManyEntities: (args: {
    data: EntityUpdateManyMutationInput;
    where?: EntityWhereInput;
  }) => BatchPayloadPromise;
  upsertEntity: (args: {
    where: EntityWhereUniqueInput;
    create: EntityCreateInput;
    update: EntityUpdateInput;
  }) => EntityPromise;
  deleteEntity: (where: EntityWhereUniqueInput) => EntityPromise;
  deleteManyEntities: (where?: EntityWhereInput) => BatchPayloadPromise;
  createEntityMap: (data: EntityMapCreateInput) => EntityMapPromise;
  updateEntityMap: (args: {
    data: EntityMapUpdateInput;
    where: EntityMapWhereUniqueInput;
  }) => EntityMapPromise;
  updateManyEntityMaps: (args: {
    data: EntityMapUpdateManyMutationInput;
    where?: EntityMapWhereInput;
  }) => BatchPayloadPromise;
  upsertEntityMap: (args: {
    where: EntityMapWhereUniqueInput;
    create: EntityMapCreateInput;
    update: EntityMapUpdateInput;
  }) => EntityMapPromise;
  deleteEntityMap: (where: EntityMapWhereUniqueInput) => EntityMapPromise;
  deleteManyEntityMaps: (where?: EntityMapWhereInput) => BatchPayloadPromise;
  createField: (data: FieldCreateInput) => FieldPromise;
  updateField: (args: {
    data: FieldUpdateInput;
    where: FieldWhereUniqueInput;
  }) => FieldPromise;
  updateManyFields: (args: {
    data: FieldUpdateManyMutationInput;
    where?: FieldWhereInput;
  }) => BatchPayloadPromise;
  upsertField: (args: {
    where: FieldWhereUniqueInput;
    create: FieldCreateInput;
    update: FieldUpdateInput;
  }) => FieldPromise;
  deleteField: (where: FieldWhereUniqueInput) => FieldPromise;
  deleteManyFields: (where?: FieldWhereInput) => BatchPayloadPromise;
  createFieldMap: (data: FieldMapCreateInput) => FieldMapPromise;
  updateFieldMap: (args: {
    data: FieldMapUpdateInput;
    where: FieldMapWhereUniqueInput;
  }) => FieldMapPromise;
  updateManyFieldMaps: (args: {
    data: FieldMapUpdateManyMutationInput;
    where?: FieldMapWhereInput;
  }) => BatchPayloadPromise;
  upsertFieldMap: (args: {
    where: FieldMapWhereUniqueInput;
    create: FieldMapCreateInput;
    update: FieldMapUpdateInput;
  }) => FieldMapPromise;
  deleteFieldMap: (where: FieldMapWhereUniqueInput) => FieldMapPromise;
  deleteManyFieldMaps: (where?: FieldMapWhereInput) => BatchPayloadPromise;
  createLog: (data: LogCreateInput) => LogPromise;
  updateLog: (args: {
    data: LogUpdateInput;
    where: LogWhereUniqueInput;
  }) => LogPromise;
  updateManyLogs: (args: {
    data: LogUpdateManyMutationInput;
    where?: LogWhereInput;
  }) => BatchPayloadPromise;
  upsertLog: (args: {
    where: LogWhereUniqueInput;
    create: LogCreateInput;
    update: LogUpdateInput;
  }) => LogPromise;
  deleteLog: (where: LogWhereUniqueInput) => LogPromise;
  deleteManyLogs: (where?: LogWhereInput) => BatchPayloadPromise;
  createPlugin: (data: PluginCreateInput) => PluginPromise;
  updatePlugin: (args: {
    data: PluginUpdateInput;
    where: PluginWhereUniqueInput;
  }) => PluginPromise;
  updateManyPlugins: (args: {
    data: PluginUpdateManyMutationInput;
    where?: PluginWhereInput;
  }) => BatchPayloadPromise;
  upsertPlugin: (args: {
    where: PluginWhereUniqueInput;
    create: PluginCreateInput;
    update: PluginUpdateInput;
  }) => PluginPromise;
  deletePlugin: (where: PluginWhereUniqueInput) => PluginPromise;
  deleteManyPlugins: (where?: PluginWhereInput) => BatchPayloadPromise;
  createPluginCategory: (
    data: PluginCategoryCreateInput
  ) => PluginCategoryPromise;
  updatePluginCategory: (args: {
    data: PluginCategoryUpdateInput;
    where: PluginCategoryWhereUniqueInput;
  }) => PluginCategoryPromise;
  updateManyPluginCategories: (args: {
    data: PluginCategoryUpdateManyMutationInput;
    where?: PluginCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertPluginCategory: (args: {
    where: PluginCategoryWhereUniqueInput;
    create: PluginCategoryCreateInput;
    update: PluginCategoryUpdateInput;
  }) => PluginCategoryPromise;
  deletePluginCategory: (
    where: PluginCategoryWhereUniqueInput
  ) => PluginCategoryPromise;
  deleteManyPluginCategories: (
    where?: PluginCategoryWhereInput
  ) => BatchPayloadPromise;
  createPluginParam: (data: PluginParamCreateInput) => PluginParamPromise;
  updatePluginParam: (args: {
    data: PluginParamUpdateInput;
    where: PluginParamWhereUniqueInput;
  }) => PluginParamPromise;
  updateManyPluginParams: (args: {
    data: PluginParamUpdateManyMutationInput;
    where?: PluginParamWhereInput;
  }) => BatchPayloadPromise;
  upsertPluginParam: (args: {
    where: PluginParamWhereUniqueInput;
    create: PluginParamCreateInput;
    update: PluginParamUpdateInput;
  }) => PluginParamPromise;
  deletePluginParam: (where: PluginParamWhereUniqueInput) => PluginParamPromise;
  deleteManyPluginParams: (
    where?: PluginParamWhereInput
  ) => BatchPayloadPromise;
  createProcess: (data: ProcessCreateInput) => ProcessPromise;
  updateProcess: (args: {
    data: ProcessUpdateInput;
    where: ProcessWhereUniqueInput;
  }) => ProcessPromise;
  updateManyProcesses: (args: {
    data: ProcessUpdateManyMutationInput;
    where?: ProcessWhereInput;
  }) => BatchPayloadPromise;
  upsertProcess: (args: {
    where: ProcessWhereUniqueInput;
    create: ProcessCreateInput;
    update: ProcessUpdateInput;
  }) => ProcessPromise;
  deleteProcess: (where: ProcessWhereUniqueInput) => ProcessPromise;
  deleteManyProcesses: (where?: ProcessWhereInput) => BatchPayloadPromise;
  createProcessHistory: (
    data: ProcessHistoryCreateInput
  ) => ProcessHistoryPromise;
  updateProcessHistory: (args: {
    data: ProcessHistoryUpdateInput;
    where: ProcessHistoryWhereUniqueInput;
  }) => ProcessHistoryPromise;
  updateManyProcessHistories: (args: {
    data: ProcessHistoryUpdateManyMutationInput;
    where?: ProcessHistoryWhereInput;
  }) => BatchPayloadPromise;
  upsertProcessHistory: (args: {
    where: ProcessHistoryWhereUniqueInput;
    create: ProcessHistoryCreateInput;
    update: ProcessHistoryUpdateInput;
  }) => ProcessHistoryPromise;
  deleteProcessHistory: (
    where: ProcessHistoryWhereUniqueInput
  ) => ProcessHistoryPromise;
  deleteManyProcessHistories: (
    where?: ProcessHistoryWhereInput
  ) => BatchPayloadPromise;
  createSchedule: (data: ScheduleCreateInput) => SchedulePromise;
  updateSchedule: (args: {
    data: ScheduleUpdateInput;
    where: ScheduleWhereUniqueInput;
  }) => SchedulePromise;
  updateManySchedules: (args: {
    data: ScheduleUpdateManyMutationInput;
    where?: ScheduleWhereInput;
  }) => BatchPayloadPromise;
  upsertSchedule: (args: {
    where: ScheduleWhereUniqueInput;
    create: ScheduleCreateInput;
    update: ScheduleUpdateInput;
  }) => SchedulePromise;
  deleteSchedule: (where: ScheduleWhereUniqueInput) => SchedulePromise;
  deleteManySchedules: (where?: ScheduleWhereInput) => BatchPayloadPromise;
  createSourceTargetFieldmapping: (
    data: SourceTargetFieldmappingCreateInput
  ) => SourceTargetFieldmappingPromise;
  updateSourceTargetFieldmapping: (args: {
    data: SourceTargetFieldmappingUpdateInput;
    where: SourceTargetFieldmappingWhereUniqueInput;
  }) => SourceTargetFieldmappingPromise;
  updateManySourceTargetFieldmappings: (args: {
    data: SourceTargetFieldmappingUpdateManyMutationInput;
    where?: SourceTargetFieldmappingWhereInput;
  }) => BatchPayloadPromise;
  upsertSourceTargetFieldmapping: (args: {
    where: SourceTargetFieldmappingWhereUniqueInput;
    create: SourceTargetFieldmappingCreateInput;
    update: SourceTargetFieldmappingUpdateInput;
  }) => SourceTargetFieldmappingPromise;
  deleteSourceTargetFieldmapping: (
    where: SourceTargetFieldmappingWhereUniqueInput
  ) => SourceTargetFieldmappingPromise;
  deleteManySourceTargetFieldmappings: (
    where?: SourceTargetFieldmappingWhereInput
  ) => BatchPayloadPromise;
  createSubcriptionHistory: (
    data: SubcriptionHistoryCreateInput
  ) => SubcriptionHistoryPromise;
  updateSubcriptionHistory: (args: {
    data: SubcriptionHistoryUpdateInput;
    where: SubcriptionHistoryWhereUniqueInput;
  }) => SubcriptionHistoryPromise;
  updateManySubcriptionHistories: (args: {
    data: SubcriptionHistoryUpdateManyMutationInput;
    where?: SubcriptionHistoryWhereInput;
  }) => BatchPayloadPromise;
  upsertSubcriptionHistory: (args: {
    where: SubcriptionHistoryWhereUniqueInput;
    create: SubcriptionHistoryCreateInput;
    update: SubcriptionHistoryUpdateInput;
  }) => SubcriptionHistoryPromise;
  deleteSubcriptionHistory: (
    where: SubcriptionHistoryWhereUniqueInput
  ) => SubcriptionHistoryPromise;
  deleteManySubcriptionHistories: (
    where?: SubcriptionHistoryWhereInput
  ) => BatchPayloadPromise;
  createSubscriberEntity: (
    data: SubscriberEntityCreateInput
  ) => SubscriberEntityPromise;
  updateSubscriberEntity: (args: {
    data: SubscriberEntityUpdateInput;
    where: SubscriberEntityWhereUniqueInput;
  }) => SubscriberEntityPromise;
  updateManySubscriberEntities: (args: {
    data: SubscriberEntityUpdateManyMutationInput;
    where?: SubscriberEntityWhereInput;
  }) => BatchPayloadPromise;
  upsertSubscriberEntity: (args: {
    where: SubscriberEntityWhereUniqueInput;
    create: SubscriberEntityCreateInput;
    update: SubscriberEntityUpdateInput;
  }) => SubscriberEntityPromise;
  deleteSubscriberEntity: (
    where: SubscriberEntityWhereUniqueInput
  ) => SubscriberEntityPromise;
  deleteManySubscriberEntities: (
    where?: SubscriberEntityWhereInput
  ) => BatchPayloadPromise;
  createSubscriberEntityMap: (
    data: SubscriberEntityMapCreateInput
  ) => SubscriberEntityMapPromise;
  updateSubscriberEntityMap: (args: {
    data: SubscriberEntityMapUpdateInput;
    where: SubscriberEntityMapWhereUniqueInput;
  }) => SubscriberEntityMapPromise;
  updateManySubscriberEntityMaps: (args: {
    data: SubscriberEntityMapUpdateManyMutationInput;
    where?: SubscriberEntityMapWhereInput;
  }) => BatchPayloadPromise;
  upsertSubscriberEntityMap: (args: {
    where: SubscriberEntityMapWhereUniqueInput;
    create: SubscriberEntityMapCreateInput;
    update: SubscriberEntityMapUpdateInput;
  }) => SubscriberEntityMapPromise;
  deleteSubscriberEntityMap: (
    where: SubscriberEntityMapWhereUniqueInput
  ) => SubscriberEntityMapPromise;
  deleteManySubscriberEntityMaps: (
    where?: SubscriberEntityMapWhereInput
  ) => BatchPayloadPromise;
  createSubscriberField: (
    data: SubscriberFieldCreateInput
  ) => SubscriberFieldPromise;
  updateSubscriberField: (args: {
    data: SubscriberFieldUpdateInput;
    where: SubscriberFieldWhereUniqueInput;
  }) => SubscriberFieldPromise;
  updateManySubscriberFields: (args: {
    data: SubscriberFieldUpdateManyMutationInput;
    where?: SubscriberFieldWhereInput;
  }) => BatchPayloadPromise;
  upsertSubscriberField: (args: {
    where: SubscriberFieldWhereUniqueInput;
    create: SubscriberFieldCreateInput;
    update: SubscriberFieldUpdateInput;
  }) => SubscriberFieldPromise;
  deleteSubscriberField: (
    where: SubscriberFieldWhereUniqueInput
  ) => SubscriberFieldPromise;
  deleteManySubscriberFields: (
    where?: SubscriberFieldWhereInput
  ) => BatchPayloadPromise;
  createSubscriberFieldMap: (
    data: SubscriberFieldMapCreateInput
  ) => SubscriberFieldMapPromise;
  updateSubscriberFieldMap: (args: {
    data: SubscriberFieldMapUpdateInput;
    where: SubscriberFieldMapWhereUniqueInput;
  }) => SubscriberFieldMapPromise;
  updateManySubscriberFieldMaps: (args: {
    data: SubscriberFieldMapUpdateManyMutationInput;
    where?: SubscriberFieldMapWhereInput;
  }) => BatchPayloadPromise;
  upsertSubscriberFieldMap: (args: {
    where: SubscriberFieldMapWhereUniqueInput;
    create: SubscriberFieldMapCreateInput;
    update: SubscriberFieldMapUpdateInput;
  }) => SubscriberFieldMapPromise;
  deleteSubscriberFieldMap: (
    where: SubscriberFieldMapWhereUniqueInput
  ) => SubscriberFieldMapPromise;
  deleteManySubscriberFieldMaps: (
    where?: SubscriberFieldMapWhereInput
  ) => BatchPayloadPromise;
  createSubscriberProcess: (
    data: SubscriberProcessCreateInput
  ) => SubscriberProcessPromise;
  updateSubscriberProcess: (args: {
    data: SubscriberProcessUpdateInput;
    where: SubscriberProcessWhereUniqueInput;
  }) => SubscriberProcessPromise;
  updateManySubscriberProcesses: (args: {
    data: SubscriberProcessUpdateManyMutationInput;
    where?: SubscriberProcessWhereInput;
  }) => BatchPayloadPromise;
  upsertSubscriberProcess: (args: {
    where: SubscriberProcessWhereUniqueInput;
    create: SubscriberProcessCreateInput;
    update: SubscriberProcessUpdateInput;
  }) => SubscriberProcessPromise;
  deleteSubscriberProcess: (
    where: SubscriberProcessWhereUniqueInput
  ) => SubscriberProcessPromise;
  deleteManySubscriberProcesses: (
    where?: SubscriberProcessWhereInput
  ) => BatchPayloadPromise;
  createSubscriptionIntegration: (
    data: SubscriptionIntegrationCreateInput
  ) => SubscriptionIntegrationPromise;
  updateSubscriptionIntegration: (args: {
    data: SubscriptionIntegrationUpdateInput;
    where: SubscriptionIntegrationWhereUniqueInput;
  }) => SubscriptionIntegrationPromise;
  updateManySubscriptionIntegrations: (args: {
    data: SubscriptionIntegrationUpdateManyMutationInput;
    where?: SubscriptionIntegrationWhereInput;
  }) => BatchPayloadPromise;
  upsertSubscriptionIntegration: (args: {
    where: SubscriptionIntegrationWhereUniqueInput;
    create: SubscriptionIntegrationCreateInput;
    update: SubscriptionIntegrationUpdateInput;
  }) => SubscriptionIntegrationPromise;
  deleteSubscriptionIntegration: (
    where: SubscriptionIntegrationWhereUniqueInput
  ) => SubscriptionIntegrationPromise;
  deleteManySubscriptionIntegrations: (
    where?: SubscriptionIntegrationWhereInput
  ) => BatchPayloadPromise;
  createTestimonial: (data: TestimonialCreateInput) => TestimonialPromise;
  updateTestimonial: (args: {
    data: TestimonialUpdateInput;
    where: TestimonialWhereUniqueInput;
  }) => TestimonialPromise;
  updateManyTestimonials: (args: {
    data: TestimonialUpdateManyMutationInput;
    where?: TestimonialWhereInput;
  }) => BatchPayloadPromise;
  upsertTestimonial: (args: {
    where: TestimonialWhereUniqueInput;
    create: TestimonialCreateInput;
    update: TestimonialUpdateInput;
  }) => TestimonialPromise;
  deleteTestimonial: (where: TestimonialWhereUniqueInput) => TestimonialPromise;
  deleteManyTestimonials: (
    where?: TestimonialWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  connector: (
    where?: ConnectorSubscriptionWhereInput
  ) => ConnectorSubscriptionPayloadSubscription;
  databaseUser: (
    where?: DatabaseUserSubscriptionWhereInput
  ) => DatabaseUserSubscriptionPayloadSubscription;
  entity: (
    where?: EntitySubscriptionWhereInput
  ) => EntitySubscriptionPayloadSubscription;
  entityMap: (
    where?: EntityMapSubscriptionWhereInput
  ) => EntityMapSubscriptionPayloadSubscription;
  field: (
    where?: FieldSubscriptionWhereInput
  ) => FieldSubscriptionPayloadSubscription;
  fieldMap: (
    where?: FieldMapSubscriptionWhereInput
  ) => FieldMapSubscriptionPayloadSubscription;
  log: (
    where?: LogSubscriptionWhereInput
  ) => LogSubscriptionPayloadSubscription;
  plugin: (
    where?: PluginSubscriptionWhereInput
  ) => PluginSubscriptionPayloadSubscription;
  pluginCategory: (
    where?: PluginCategorySubscriptionWhereInput
  ) => PluginCategorySubscriptionPayloadSubscription;
  pluginParam: (
    where?: PluginParamSubscriptionWhereInput
  ) => PluginParamSubscriptionPayloadSubscription;
  process: (
    where?: ProcessSubscriptionWhereInput
  ) => ProcessSubscriptionPayloadSubscription;
  processHistory: (
    where?: ProcessHistorySubscriptionWhereInput
  ) => ProcessHistorySubscriptionPayloadSubscription;
  schedule: (
    where?: ScheduleSubscriptionWhereInput
  ) => ScheduleSubscriptionPayloadSubscription;
  sourceTargetFieldmapping: (
    where?: SourceTargetFieldmappingSubscriptionWhereInput
  ) => SourceTargetFieldmappingSubscriptionPayloadSubscription;
  subcriptionHistory: (
    where?: SubcriptionHistorySubscriptionWhereInput
  ) => SubcriptionHistorySubscriptionPayloadSubscription;
  subscriberEntity: (
    where?: SubscriberEntitySubscriptionWhereInput
  ) => SubscriberEntitySubscriptionPayloadSubscription;
  subscriberEntityMap: (
    where?: SubscriberEntityMapSubscriptionWhereInput
  ) => SubscriberEntityMapSubscriptionPayloadSubscription;
  subscriberField: (
    where?: SubscriberFieldSubscriptionWhereInput
  ) => SubscriberFieldSubscriptionPayloadSubscription;
  subscriberFieldMap: (
    where?: SubscriberFieldMapSubscriptionWhereInput
  ) => SubscriberFieldMapSubscriptionPayloadSubscription;
  subscriberProcess: (
    where?: SubscriberProcessSubscriptionWhereInput
  ) => SubscriberProcessSubscriptionPayloadSubscription;
  subscriptionIntegration: (
    where?: SubscriptionIntegrationSubscriptionWhereInput
  ) => SubscriptionIntegrationSubscriptionPayloadSubscription;
  testimonial: (
    where?: TestimonialSubscriptionWhereInput
  ) => TestimonialSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ConnectorOrderByInput =
  | "ConnectorId_ASC"
  | "ConnectorId_DESC"
  | "Status_ASC"
  | "Status_DESC"
  | "ConnectorTitle_ASC"
  | "ConnectorTitle_DESC"
  | "ConnectorShortName_ASC"
  | "ConnectorShortName_DESC"
  | "ConnectorSEOName_ASC"
  | "ConnectorSEOName_DESC"
  | "ConnectorShortDesc_ASC"
  | "ConnectorShortDesc_DESC"
  | "ConnectorLongDesc_ASC"
  | "ConnectorLongDesc_DESC"
  | "CreatedBy_ASC"
  | "CreatedBy_DESC"
  | "CreatedDate_ASC"
  | "CreatedDate_DESC"
  | "ModifiedDate_ASC"
  | "ModifiedDate_DESC"
  | "ModifiedBy_ASC"
  | "ModifiedBy_DESC"
  | "Popular_ASC"
  | "Popular_DESC"
  | "Recent_ASC"
  | "Recent_DESC"
  | "testuser_ASC"
  | "testuser_DESC";

export type EntityOrderByInput =
  | "EntityID_ASC"
  | "EntityID_DESC"
  | "EntityName_ASC"
  | "EntityName_DESC"
  | "EntityType_ASC"
  | "EntityType_DESC"
  | "EntityShortDesc_ASC"
  | "EntityShortDesc_DESC"
  | "EntityLongDesc_ASC"
  | "EntityLongDesc_DESC"
  | "CreatedBy_ASC"
  | "CreatedBy_DESC"
  | "ConnectUrl_ASC"
  | "ConnectUrl_DESC"
  | "CreatedDate_ASC"
  | "CreatedDate_DESC"
  | "ModifiedBy_ASC"
  | "ModifiedBy_DESC"
  | "ModifiedDate_ASC"
  | "ModifiedDate_DESC"
  | "Status_ASC"
  | "Status_DESC";

export type PluginParamOrderByInput =
  | "PluginParamID_ASC"
  | "PluginParamID_DESC"
  | "FieldType_ASC"
  | "FieldType_DESC"
  | "FieldName_ASC"
  | "FieldName_DESC"
  | "Caption_ASC"
  | "Caption_DESC"
  | "Status_ASC"
  | "Status_DESC"
  | "Required_ASC"
  | "Required_DESC"
  | "CreatedBy_ASC"
  | "CreatedBy_DESC"
  | "CreatedDate_ASC"
  | "CreatedDate_DESC"
  | "ModifiedBy_ASC"
  | "ModifiedBy_DESC"
  | "ModifiedDate_ASC"
  | "ModifiedDate_DESC";

export type Status = "ENABLE" | "DISABLE" | "DEPRECATED";

export type PluginCategoryOrderByInput =
  | "CategoryID_ASC"
  | "CategoryID_DESC"
  | "CategoryName_ASC"
  | "CategoryName_DESC"
  | "CategoryDesc_ASC"
  | "CategoryDesc_DESC";

export type SubscriptionIntegrationOrderByInput =
  | "SubscriptionIntegrationId_ASC"
  | "SubscriptionIntegrationId_DESC"
  | "NoOfLicenses_ASC"
  | "NoOfLicenses_DESC"
  | "NoOfUsers_ASC"
  | "NoOfUsers_DESC"
  | "Status_ASC"
  | "Status_DESC"
  | "SubscriptionStartDate_ASC"
  | "SubscriptionStartDate_DESC"
  | "SubscriptionEndDate_ASC"
  | "SubscriptionEndDate_DESC";

export type PluginOrderByInput =
  | "PluginID_ASC"
  | "PluginID_DESC"
  | "PluginName_ASC"
  | "PluginName_DESC"
  | "PluginTitle_ASC"
  | "PluginTitle_DESC"
  | "PluginShortName_ASC"
  | "PluginShortName_DESC"
  | "PluginSEOName_ASC"
  | "PluginSEOName_DESC"
  | "PluginShortDesc_ASC"
  | "PluginShortDesc_DESC"
  | "PluginLongDesc_ASC"
  | "PluginLongDesc_DESC"
  | "AssemblyName_ASC"
  | "AssemblyName_DESC"
  | "Status_ASC"
  | "Status_DESC"
  | "pluginType_ASC"
  | "pluginType_DESC"
  | "CreatedDate_ASC"
  | "CreatedDate_DESC"
  | "CreatedBy_ASC"
  | "CreatedBy_DESC"
  | "ModifiedDate_ASC"
  | "ModifiedDate_DESC"
  | "ModifiedBy_ASC"
  | "ModifiedBy_DESC"
  | "ImageName_ASC"
  | "ImageName_DESC"
  | "DefaultStructure_ASC"
  | "DefaultStructure_DESC"
  | "ConnectUrl_ASC"
  | "ConnectUrl_DESC"
  | "Popular_ASC"
  | "Popular_DESC"
  | "Recent_ASC"
  | "Recent_DESC";

export type SubscriberFieldMapOrderByInput =
  | "SubscriberFieldMapID_ASC"
  | "SubscriberFieldMapID_DESC"
  | "Status_ASC"
  | "Status_DESC"
  | "FieldShortDesc_ASC"
  | "FieldShortDesc_DESC"
  | "FieldLongDesc_ASC"
  | "FieldLongDesc_DESC"
  | "CreatedBy_ASC"
  | "CreatedBy_DESC"
  | "CreatedDate_ASC"
  | "CreatedDate_DESC"
  | "ModifiedBy_ASC"
  | "ModifiedBy_DESC"
  | "ModifiedDate_ASC"
  | "ModifiedDate_DESC";

export type LogOrderByInput =
  | "LogId_ASC"
  | "LogId_DESC"
  | "LogDate_ASC"
  | "LogDate_DESC"
  | "Thread_ASC"
  | "Thread_DESC"
  | "Level_ASC"
  | "Level_DESC"
  | "Operation_ASC"
  | "Operation_DESC"
  | "Event_ASC"
  | "Event_DESC"
  | "Sourcekeyfields_ASC"
  | "Sourcekeyfields_DESC"
  | "Sourcekeyvalue_ASC"
  | "Sourcekeyvalue_DESC"
  | "Targetkeyfields_ASC"
  | "Targetkeyfields_DESC"
  | "Targetkeyvalue_ASC"
  | "Targetkeyvalue_DESC"
  | "Message_ASC"
  | "Message_DESC"
  | "Exceptions_ASC"
  | "Exceptions_DESC";

export type SubscriberEntityMapOrderByInput =
  | "SubscriberEntityMapID_ASC"
  | "SubscriberEntityMapID_DESC"
  | "Status_ASC"
  | "Status_DESC"
  | "EntityShortDesc_ASC"
  | "EntityShortDesc_DESC"
  | "EntityLongDesc_ASC"
  | "EntityLongDesc_DESC"
  | "CreatedBy_ASC"
  | "CreatedBy_DESC"
  | "CreatedDate_ASC"
  | "CreatedDate_DESC"
  | "ModifiedBy_ASC"
  | "ModifiedBy_DESC"
  | "ModifiedDate_ASC"
  | "ModifiedDate_DESC";

export type ScheduleOrderByInput =
  | "ScheduleID_ASC"
  | "ScheduleID_DESC"
  | "Field_ASC"
  | "Field_DESC"
  | "Status_ASC"
  | "Status_DESC"
  | "DailyOccurence_ASC"
  | "DailyOccurence_DESC"
  | "ScheduleType_ASC"
  | "ScheduleType_DESC"
  | "DailyRecurrenceType_ASC"
  | "DailyRecurrenceType_DESC"
  | "OccursAt_ASC"
  | "OccursAt_DESC"
  | "DailyInterval_ASC"
  | "DailyInterval_DESC"
  | "DailyIntervalSpan_ASC"
  | "DailyIntervalSpan_DESC"
  | "DayofMonth_ASC"
  | "DayofMonth_DESC"
  | "LastExecuted_ASC"
  | "LastExecuted_DESC"
  | "NextOccurence_ASC"
  | "NextOccurence_DESC"
  | "CreatedDate_ASC"
  | "CreatedDate_DESC"
  | "CreatedBy_ASC"
  | "CreatedBy_DESC"
  | "ModifiedDate_ASC"
  | "ModifiedDate_DESC"
  | "ModifiedBy_ASC"
  | "ModifiedBy_DESC"
  | "StartTime_ASC"
  | "StartTime_DESC"
  | "EndTime_ASC"
  | "EndTime_DESC"
  | "Type_ASC"
  | "Type_DESC";

export type SubcriptionHistoryOrderByInput =
  | "SubcriptionHistoryId_ASC"
  | "SubcriptionHistoryId_DESC"
  | "SubcriptionHistoryName_ASC"
  | "SubcriptionHistoryName_DESC"
  | "Status_ASC"
  | "Status_DESC"
  | "CreatedBy_ASC"
  | "CreatedBy_DESC"
  | "CreatedDate_ASC"
  | "CreatedDate_DESC"
  | "ModifiedBy_ASC"
  | "ModifiedBy_DESC"
  | "ModifiedDate_ASC"
  | "ModifiedDate_DESC";

export type Stage = "IDLE" | "RUNNING" | "QUEUED";

export type ProcessHistoryOrderByInput =
  | "ProcessHistoryId_ASC"
  | "ProcessHistoryId_DESC"
  | "LastSyncDate_ASC"
  | "LastSyncDate_DESC"
  | "CreatedDate_ASC"
  | "CreatedDate_DESC"
  | "ModifiedDate_ASC"
  | "ModifiedDate_DESC"
  | "Stage_ASC"
  | "Stage_DESC";

export type DBClaims = "READWRITE" | "READONLY";

export type UserOrderByInput =
  | "UserId_ASC"
  | "UserId_DESC"
  | "FirstName_ASC"
  | "FirstName_DESC"
  | "LastName_ASC"
  | "LastName_DESC"
  | "UserName_ASC"
  | "UserName_DESC"
  | "Address_ASC"
  | "Address_DESC"
  | "PhoneNumber_ASC"
  | "PhoneNumber_DESC"
  | "PhoneCode_ASC"
  | "PhoneCode_DESC"
  | "Email_ASC"
  | "Email_DESC"
  | "TenantId_ASC"
  | "TenantId_DESC"
  | "CompanyName_ASC"
  | "CompanyName_DESC"
  | "ZipCode_ASC"
  | "ZipCode_DESC"
  | "Country_ASC"
  | "Country_DESC"
  | "State_ASC"
  | "State_DESC"
  | "City_ASC"
  | "City_DESC"
  | "IsAdmin_ASC"
  | "IsAdmin_DESC"
  | "Password_ASC"
  | "Password_DESC"
  | "ConfirmPassword_ASC"
  | "ConfirmPassword_DESC";

export type FieldMapOrderByInput =
  | "FieldMapID_ASC"
  | "FieldMapID_DESC"
  | "Status_ASC"
  | "Status_DESC"
  | "FieldShortDesc_ASC"
  | "FieldShortDesc_DESC"
  | "FieldLongDesc_ASC"
  | "FieldLongDesc_DESC"
  | "CreatedBy_ASC"
  | "CreatedBy_DESC"
  | "CreatedDate_ASC"
  | "CreatedDate_DESC"
  | "ModifiedBy_ASC"
  | "ModifiedBy_DESC"
  | "ModifiedDate_ASC"
  | "ModifiedDate_DESC";

export type SubscriberProcessOrderByInput =
  | "SubscriberProcessID_ASC"
  | "SubscriberProcessID_DESC"
  | "Status_ASC"
  | "Status_DESC"
  | "Stage_ASC"
  | "Stage_DESC"
  | "CreatedBy_ASC"
  | "CreatedBy_DESC"
  | "CreatedDate_ASC"
  | "CreatedDate_DESC"
  | "ModifiedDate_ASC"
  | "ModifiedDate_DESC"
  | "ModifiedBy_ASC"
  | "ModifiedBy_DESC"
  | "LastSyncDate_ASC"
  | "LastSyncDate_DESC";

export type EntityMapOrderByInput =
  | "EntityMapID_ASC"
  | "EntityMapID_DESC"
  | "Status_ASC"
  | "Status_DESC"
  | "EntityShortDesc_ASC"
  | "EntityShortDesc_DESC"
  | "EntityLongDesc_ASC"
  | "EntityLongDesc_DESC"
  | "CreatedBy_ASC"
  | "CreatedBy_DESC"
  | "CreatedDate_ASC"
  | "CreatedDate_DESC"
  | "ModifiedBy_ASC"
  | "ModifiedBy_DESC"
  | "ModifiedDate_ASC"
  | "ModifiedDate_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type FieldOrderByInput =
  | "FieldID_ASC"
  | "FieldID_DESC"
  | "FieldName_ASC"
  | "FieldName_DESC"
  | "FieldShortDesc_ASC"
  | "FieldShortDesc_DESC"
  | "FieldLongDesc_ASC"
  | "FieldLongDesc_DESC"
  | "DataType_ASC"
  | "DataType_DESC"
  | "FieldType_ASC"
  | "FieldType_DESC"
  | "Status_ASC"
  | "Status_DESC"
  | "CreatedBy_ASC"
  | "CreatedBy_DESC"
  | "CreatedDate_ASC"
  | "CreatedDate_DESC"
  | "ModifiedBy_ASC"
  | "ModifiedBy_DESC"
  | "ModifiedDate_ASC"
  | "ModifiedDate_DESC";

export type DatabaseUserOrderByInput =
  | "UserId_ASC"
  | "UserId_DESC"
  | "Name_ASC"
  | "Name_DESC"
  | "Password_ASC"
  | "Password_DESC"
  | "Claims_ASC"
  | "Claims_DESC"
  | "Token_ASC"
  | "Token_DESC";

export type SubscriberFieldOrderByInput =
  | "SubscriberFieldID_ASC"
  | "SubscriberFieldID_DESC"
  | "FieldName_ASC"
  | "FieldName_DESC"
  | "DataType_ASC"
  | "DataType_DESC"
  | "FieldType_ASC"
  | "FieldType_DESC"
  | "Status_ASC"
  | "Status_DESC"
  | "CreatedBy_ASC"
  | "CreatedBy_DESC"
  | "CreatedDate_ASC"
  | "CreatedDate_DESC"
  | "ModifiedBy_ASC"
  | "ModifiedBy_DESC"
  | "ModifiedDate_ASC"
  | "ModifiedDate_DESC";

export type TestimonialOrderByInput =
  | "TestimonialID_ASC"
  | "TestimonialID_DESC"
  | "Message_ASC"
  | "Message_DESC"
  | "Author_ASC"
  | "Author_DESC"
  | "Designation_ASC"
  | "Designation_DESC"
  | "CompanyName_ASC"
  | "CompanyName_DESC"
  | "ImageName_ASC"
  | "ImageName_DESC"
  | "CreatedBy_ASC"
  | "CreatedBy_DESC"
  | "CreatedDate_ASC"
  | "CreatedDate_DESC"
  | "ModifiedBy_ASC"
  | "ModifiedBy_DESC"
  | "ModifiedDate_ASC"
  | "ModifiedDate_DESC";

export type ProcessOrderByInput =
  | "ProcessId_ASC"
  | "ProcessId_DESC"
  | "ProcessShortDesc_ASC"
  | "ProcessShortDesc_DESC"
  | "ProcessLongDesc_ASC"
  | "ProcessLongDesc_DESC"
  | "Status_ASC"
  | "Status_DESC"
  | "CreatedBy_ASC"
  | "CreatedBy_DESC"
  | "CreatedDate_ASC"
  | "CreatedDate_DESC"
  | "ModifiedDate_ASC"
  | "ModifiedDate_DESC"
  | "ModifiedBy_ASC"
  | "ModifiedBy_DESC";

export type SourceTargetFieldmappingOrderByInput =
  | "SourceTargetFieldmappingID_ASC"
  | "SourceTargetFieldmappingID_DESC"
  | "FieldShortDesc_ASC"
  | "FieldShortDesc_DESC"
  | "FieldLongDesc_ASC"
  | "FieldLongDesc_DESC"
  | "SourceKey_ASC"
  | "SourceKey_DESC"
  | "SourceKeyValue_ASC"
  | "SourceKeyValue_DESC"
  | "TargetKey_ASC"
  | "TargetKey_DESC"
  | "TargetKeyValue_ASC"
  | "TargetKeyValue_DESC"
  | "OtherParam_ASC"
  | "OtherParam_DESC";

export type SubscriberEntityOrderByInput =
  | "SubscriberEntityID_ASC"
  | "SubscriberEntityID_DESC"
  | "EntityName_ASC"
  | "EntityName_DESC"
  | "EntityType_ASC"
  | "EntityType_DESC"
  | "EntityShortDesc_ASC"
  | "EntityShortDesc_DESC"
  | "EntityLongDesc_ASC"
  | "EntityLongDesc_DESC"
  | "CreatedBy_ASC"
  | "CreatedBy_DESC"
  | "CreatedDate_ASC"
  | "CreatedDate_DESC"
  | "ModifiedBy_ASC"
  | "ModifiedBy_DESC"
  | "ModifiedDate_ASC"
  | "ModifiedDate_DESC"
  | "Status_ASC"
  | "Status_DESC";

export interface SubscriberEntityWhereInput {
  SubscriberEntityID?: Maybe<ID_Input>;
  SubscriberEntityID_not?: Maybe<ID_Input>;
  SubscriberEntityID_in?: Maybe<ID_Input[] | ID_Input>;
  SubscriberEntityID_not_in?: Maybe<ID_Input[] | ID_Input>;
  SubscriberEntityID_lt?: Maybe<ID_Input>;
  SubscriberEntityID_lte?: Maybe<ID_Input>;
  SubscriberEntityID_gt?: Maybe<ID_Input>;
  SubscriberEntityID_gte?: Maybe<ID_Input>;
  SubscriberEntityID_contains?: Maybe<ID_Input>;
  SubscriberEntityID_not_contains?: Maybe<ID_Input>;
  SubscriberEntityID_starts_with?: Maybe<ID_Input>;
  SubscriberEntityID_not_starts_with?: Maybe<ID_Input>;
  SubscriberEntityID_ends_with?: Maybe<ID_Input>;
  SubscriberEntityID_not_ends_with?: Maybe<ID_Input>;
  PluginID?: Maybe<PluginWhereInput>;
  EntityName?: Maybe<String>;
  EntityName_not?: Maybe<String>;
  EntityName_in?: Maybe<String[] | String>;
  EntityName_not_in?: Maybe<String[] | String>;
  EntityName_lt?: Maybe<String>;
  EntityName_lte?: Maybe<String>;
  EntityName_gt?: Maybe<String>;
  EntityName_gte?: Maybe<String>;
  EntityName_contains?: Maybe<String>;
  EntityName_not_contains?: Maybe<String>;
  EntityName_starts_with?: Maybe<String>;
  EntityName_not_starts_with?: Maybe<String>;
  EntityName_ends_with?: Maybe<String>;
  EntityName_not_ends_with?: Maybe<String>;
  EntityType?: Maybe<String>;
  EntityType_not?: Maybe<String>;
  EntityType_in?: Maybe<String[] | String>;
  EntityType_not_in?: Maybe<String[] | String>;
  EntityType_lt?: Maybe<String>;
  EntityType_lte?: Maybe<String>;
  EntityType_gt?: Maybe<String>;
  EntityType_gte?: Maybe<String>;
  EntityType_contains?: Maybe<String>;
  EntityType_not_contains?: Maybe<String>;
  EntityType_starts_with?: Maybe<String>;
  EntityType_not_starts_with?: Maybe<String>;
  EntityType_ends_with?: Maybe<String>;
  EntityType_not_ends_with?: Maybe<String>;
  EntityShortDesc?: Maybe<String>;
  EntityShortDesc_not?: Maybe<String>;
  EntityShortDesc_in?: Maybe<String[] | String>;
  EntityShortDesc_not_in?: Maybe<String[] | String>;
  EntityShortDesc_lt?: Maybe<String>;
  EntityShortDesc_lte?: Maybe<String>;
  EntityShortDesc_gt?: Maybe<String>;
  EntityShortDesc_gte?: Maybe<String>;
  EntityShortDesc_contains?: Maybe<String>;
  EntityShortDesc_not_contains?: Maybe<String>;
  EntityShortDesc_starts_with?: Maybe<String>;
  EntityShortDesc_not_starts_with?: Maybe<String>;
  EntityShortDesc_ends_with?: Maybe<String>;
  EntityShortDesc_not_ends_with?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  EntityLongDesc_not?: Maybe<String>;
  EntityLongDesc_in?: Maybe<String[] | String>;
  EntityLongDesc_not_in?: Maybe<String[] | String>;
  EntityLongDesc_lt?: Maybe<String>;
  EntityLongDesc_lte?: Maybe<String>;
  EntityLongDesc_gt?: Maybe<String>;
  EntityLongDesc_gte?: Maybe<String>;
  EntityLongDesc_contains?: Maybe<String>;
  EntityLongDesc_not_contains?: Maybe<String>;
  EntityLongDesc_starts_with?: Maybe<String>;
  EntityLongDesc_not_starts_with?: Maybe<String>;
  EntityLongDesc_ends_with?: Maybe<String>;
  EntityLongDesc_not_ends_with?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  CreatedDate?: Maybe<DateTimeInput>;
  CreatedDate_not?: Maybe<DateTimeInput>;
  CreatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_lt?: Maybe<DateTimeInput>;
  CreatedDate_lte?: Maybe<DateTimeInput>;
  CreatedDate_gt?: Maybe<DateTimeInput>;
  CreatedDate_gte?: Maybe<DateTimeInput>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  ModifiedDate?: Maybe<DateTimeInput>;
  ModifiedDate_not?: Maybe<DateTimeInput>;
  ModifiedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_lt?: Maybe<DateTimeInput>;
  ModifiedDate_lte?: Maybe<DateTimeInput>;
  ModifiedDate_gt?: Maybe<DateTimeInput>;
  ModifiedDate_gte?: Maybe<DateTimeInput>;
  Status?: Maybe<Status>;
  Status_not?: Maybe<Status>;
  Status_in?: Maybe<Status[] | Status>;
  Status_not_in?: Maybe<Status[] | Status>;
  AND?: Maybe<SubscriberEntityWhereInput[] | SubscriberEntityWhereInput>;
}

export interface ProcessCreateInput {
  ProcessId?: Maybe<ID_Input>;
  ConnectorId?: Maybe<ConnectorCreateOneInput>;
  ProcessShortDesc?: Maybe<String>;
  ProcessLongDesc?: Maybe<String>;
  Status?: Maybe<Status>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  PrimaryEntity?: Maybe<EntityCreateOneInput>;
  SecondaryEntity?: Maybe<EntityCreateOneInput>;
}

export interface SubscriberEntityMapSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SubscriberEntityMapWhereInput>;
  AND?: Maybe<
    | SubscriberEntityMapSubscriptionWhereInput[]
    | SubscriberEntityMapSubscriptionWhereInput
  >;
}

export type ConnectorWhereUniqueInput = AtLeastOne<{
  ConnectorId: Maybe<ID_Input>;
  ConnectorShortName?: Maybe<String>;
  ConnectorSEOName?: Maybe<String>;
}>;

export interface ScheduleUpdateManyWithoutSubscriberProcessInput {
  create?: Maybe<
    | ScheduleCreateWithoutSubscriberProcessInput[]
    | ScheduleCreateWithoutSubscriberProcessInput
  >;
  delete?: Maybe<ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput>;
  connect?: Maybe<ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput>;
  set?: Maybe<ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput>;
  disconnect?: Maybe<ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput>;
  update?: Maybe<
    | ScheduleUpdateWithWhereUniqueWithoutSubscriberProcessInput[]
    | ScheduleUpdateWithWhereUniqueWithoutSubscriberProcessInput
  >;
  upsert?: Maybe<
    | ScheduleUpsertWithWhereUniqueWithoutSubscriberProcessInput[]
    | ScheduleUpsertWithWhereUniqueWithoutSubscriberProcessInput
  >;
  deleteMany?: Maybe<ScheduleScalarWhereInput[] | ScheduleScalarWhereInput>;
  updateMany?: Maybe<
    | ScheduleUpdateManyWithWhereNestedInput[]
    | ScheduleUpdateManyWithWhereNestedInput
  >;
}

export interface LogSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LogWhereInput>;
  AND?: Maybe<LogSubscriptionWhereInput[] | LogSubscriptionWhereInput>;
}

export interface ProcessUpsertNestedInput {
  update: ProcessUpdateDataInput;
  create: ProcessCreateInput;
}

export interface EntityWhereInput {
  EntityID?: Maybe<ID_Input>;
  EntityID_not?: Maybe<ID_Input>;
  EntityID_in?: Maybe<ID_Input[] | ID_Input>;
  EntityID_not_in?: Maybe<ID_Input[] | ID_Input>;
  EntityID_lt?: Maybe<ID_Input>;
  EntityID_lte?: Maybe<ID_Input>;
  EntityID_gt?: Maybe<ID_Input>;
  EntityID_gte?: Maybe<ID_Input>;
  EntityID_contains?: Maybe<ID_Input>;
  EntityID_not_contains?: Maybe<ID_Input>;
  EntityID_starts_with?: Maybe<ID_Input>;
  EntityID_not_starts_with?: Maybe<ID_Input>;
  EntityID_ends_with?: Maybe<ID_Input>;
  EntityID_not_ends_with?: Maybe<ID_Input>;
  PluginID?: Maybe<PluginWhereInput>;
  EntityName?: Maybe<String>;
  EntityName_not?: Maybe<String>;
  EntityName_in?: Maybe<String[] | String>;
  EntityName_not_in?: Maybe<String[] | String>;
  EntityName_lt?: Maybe<String>;
  EntityName_lte?: Maybe<String>;
  EntityName_gt?: Maybe<String>;
  EntityName_gte?: Maybe<String>;
  EntityName_contains?: Maybe<String>;
  EntityName_not_contains?: Maybe<String>;
  EntityName_starts_with?: Maybe<String>;
  EntityName_not_starts_with?: Maybe<String>;
  EntityName_ends_with?: Maybe<String>;
  EntityName_not_ends_with?: Maybe<String>;
  EntityType?: Maybe<String>;
  EntityType_not?: Maybe<String>;
  EntityType_in?: Maybe<String[] | String>;
  EntityType_not_in?: Maybe<String[] | String>;
  EntityType_lt?: Maybe<String>;
  EntityType_lte?: Maybe<String>;
  EntityType_gt?: Maybe<String>;
  EntityType_gte?: Maybe<String>;
  EntityType_contains?: Maybe<String>;
  EntityType_not_contains?: Maybe<String>;
  EntityType_starts_with?: Maybe<String>;
  EntityType_not_starts_with?: Maybe<String>;
  EntityType_ends_with?: Maybe<String>;
  EntityType_not_ends_with?: Maybe<String>;
  EntityShortDesc?: Maybe<String>;
  EntityShortDesc_not?: Maybe<String>;
  EntityShortDesc_in?: Maybe<String[] | String>;
  EntityShortDesc_not_in?: Maybe<String[] | String>;
  EntityShortDesc_lt?: Maybe<String>;
  EntityShortDesc_lte?: Maybe<String>;
  EntityShortDesc_gt?: Maybe<String>;
  EntityShortDesc_gte?: Maybe<String>;
  EntityShortDesc_contains?: Maybe<String>;
  EntityShortDesc_not_contains?: Maybe<String>;
  EntityShortDesc_starts_with?: Maybe<String>;
  EntityShortDesc_not_starts_with?: Maybe<String>;
  EntityShortDesc_ends_with?: Maybe<String>;
  EntityShortDesc_not_ends_with?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  EntityLongDesc_not?: Maybe<String>;
  EntityLongDesc_in?: Maybe<String[] | String>;
  EntityLongDesc_not_in?: Maybe<String[] | String>;
  EntityLongDesc_lt?: Maybe<String>;
  EntityLongDesc_lte?: Maybe<String>;
  EntityLongDesc_gt?: Maybe<String>;
  EntityLongDesc_gte?: Maybe<String>;
  EntityLongDesc_contains?: Maybe<String>;
  EntityLongDesc_not_contains?: Maybe<String>;
  EntityLongDesc_starts_with?: Maybe<String>;
  EntityLongDesc_not_starts_with?: Maybe<String>;
  EntityLongDesc_ends_with?: Maybe<String>;
  EntityLongDesc_not_ends_with?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  ConnectUrl?: Maybe<String>;
  ConnectUrl_not?: Maybe<String>;
  ConnectUrl_in?: Maybe<String[] | String>;
  ConnectUrl_not_in?: Maybe<String[] | String>;
  ConnectUrl_lt?: Maybe<String>;
  ConnectUrl_lte?: Maybe<String>;
  ConnectUrl_gt?: Maybe<String>;
  ConnectUrl_gte?: Maybe<String>;
  ConnectUrl_contains?: Maybe<String>;
  ConnectUrl_not_contains?: Maybe<String>;
  ConnectUrl_starts_with?: Maybe<String>;
  ConnectUrl_not_starts_with?: Maybe<String>;
  ConnectUrl_ends_with?: Maybe<String>;
  ConnectUrl_not_ends_with?: Maybe<String>;
  CreatedDate?: Maybe<DateTimeInput>;
  CreatedDate_not?: Maybe<DateTimeInput>;
  CreatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_lt?: Maybe<DateTimeInput>;
  CreatedDate_lte?: Maybe<DateTimeInput>;
  CreatedDate_gt?: Maybe<DateTimeInput>;
  CreatedDate_gte?: Maybe<DateTimeInput>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  ModifiedDate?: Maybe<DateTimeInput>;
  ModifiedDate_not?: Maybe<DateTimeInput>;
  ModifiedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_lt?: Maybe<DateTimeInput>;
  ModifiedDate_lte?: Maybe<DateTimeInput>;
  ModifiedDate_gt?: Maybe<DateTimeInput>;
  ModifiedDate_gte?: Maybe<DateTimeInput>;
  Status?: Maybe<Status>;
  Status_not?: Maybe<Status>;
  Status_in?: Maybe<Status[] | Status>;
  Status_not_in?: Maybe<Status[] | Status>;
  ConfigStructure_some?: Maybe<EntityConnStrctjsonWhereInput>;
  ConfigStructure_every?: Maybe<EntityConnStrctjsonRestrictedWhereInput>;
  ConfigStructure_none?: Maybe<EntityConnStrctjsonRestrictedWhereInput>;
  AND?: Maybe<EntityWhereInput[] | EntityWhereInput>;
}

export interface ProcessUpdateDataInput {
  ConnectorId?: Maybe<ConnectorUpdateOneInput>;
  ProcessShortDesc?: Maybe<String>;
  ProcessLongDesc?: Maybe<String>;
  Status?: Maybe<Status>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  PrimaryEntity?: Maybe<EntityUpdateOneInput>;
  SecondaryEntity?: Maybe<EntityUpdateOneInput>;
}

export interface EntityConnStrctjsonRestrictedWhereInput {
  Name?: Maybe<String>;
  Name_not?: Maybe<String>;
  Name_in?: Maybe<String[] | String>;
  Name_not_in?: Maybe<String[] | String>;
  Name_lt?: Maybe<String>;
  Name_lte?: Maybe<String>;
  Name_gt?: Maybe<String>;
  Name_gte?: Maybe<String>;
  Name_contains?: Maybe<String>;
  Name_not_contains?: Maybe<String>;
  Name_starts_with?: Maybe<String>;
  Name_not_starts_with?: Maybe<String>;
  Name_ends_with?: Maybe<String>;
  Name_not_ends_with?: Maybe<String>;
  Value?: Maybe<String>;
  Value_not?: Maybe<String>;
  Value_in?: Maybe<String[] | String>;
  Value_not_in?: Maybe<String[] | String>;
  Value_lt?: Maybe<String>;
  Value_lte?: Maybe<String>;
  Value_gt?: Maybe<String>;
  Value_gte?: Maybe<String>;
  Value_contains?: Maybe<String>;
  Value_not_contains?: Maybe<String>;
  Value_starts_with?: Maybe<String>;
  Value_not_starts_with?: Maybe<String>;
  Value_ends_with?: Maybe<String>;
  Value_not_ends_with?: Maybe<String>;
  PluginId?: Maybe<String>;
  PluginId_not?: Maybe<String>;
  PluginId_in?: Maybe<String[] | String>;
  PluginId_not_in?: Maybe<String[] | String>;
  PluginId_lt?: Maybe<String>;
  PluginId_lte?: Maybe<String>;
  PluginId_gt?: Maybe<String>;
  PluginId_gte?: Maybe<String>;
  PluginId_contains?: Maybe<String>;
  PluginId_not_contains?: Maybe<String>;
  PluginId_starts_with?: Maybe<String>;
  PluginId_not_starts_with?: Maybe<String>;
  PluginId_ends_with?: Maybe<String>;
  PluginId_not_ends_with?: Maybe<String>;
  EntityID?: Maybe<String>;
  EntityID_not?: Maybe<String>;
  EntityID_in?: Maybe<String[] | String>;
  EntityID_not_in?: Maybe<String[] | String>;
  EntityID_lt?: Maybe<String>;
  EntityID_lte?: Maybe<String>;
  EntityID_gt?: Maybe<String>;
  EntityID_gte?: Maybe<String>;
  EntityID_contains?: Maybe<String>;
  EntityID_not_contains?: Maybe<String>;
  EntityID_starts_with?: Maybe<String>;
  EntityID_not_starts_with?: Maybe<String>;
  EntityID_ends_with?: Maybe<String>;
  EntityID_not_ends_with?: Maybe<String>;
  Question?: Maybe<String>;
  Question_not?: Maybe<String>;
  Question_in?: Maybe<String[] | String>;
  Question_not_in?: Maybe<String[] | String>;
  Question_lt?: Maybe<String>;
  Question_lte?: Maybe<String>;
  Question_gt?: Maybe<String>;
  Question_gte?: Maybe<String>;
  Question_contains?: Maybe<String>;
  Question_not_contains?: Maybe<String>;
  Question_starts_with?: Maybe<String>;
  Question_not_starts_with?: Maybe<String>;
  Question_ends_with?: Maybe<String>;
  Question_not_ends_with?: Maybe<String>;
  FieldType?: Maybe<String>;
  FieldType_not?: Maybe<String>;
  FieldType_in?: Maybe<String[] | String>;
  FieldType_not_in?: Maybe<String[] | String>;
  FieldType_lt?: Maybe<String>;
  FieldType_lte?: Maybe<String>;
  FieldType_gt?: Maybe<String>;
  FieldType_gte?: Maybe<String>;
  FieldType_contains?: Maybe<String>;
  FieldType_not_contains?: Maybe<String>;
  FieldType_starts_with?: Maybe<String>;
  FieldType_not_starts_with?: Maybe<String>;
  FieldType_ends_with?: Maybe<String>;
  FieldType_not_ends_with?: Maybe<String>;
  FieldLength?: Maybe<Int>;
  FieldLength_not?: Maybe<Int>;
  FieldLength_in?: Maybe<Int[] | Int>;
  FieldLength_not_in?: Maybe<Int[] | Int>;
  FieldLength_lt?: Maybe<Int>;
  FieldLength_lte?: Maybe<Int>;
  FieldLength_gt?: Maybe<Int>;
  FieldLength_gte?: Maybe<Int>;
  IsRequired?: Maybe<Boolean>;
  IsRequired_not?: Maybe<Boolean>;
  FieldName?: Maybe<String>;
  FieldName_not?: Maybe<String>;
  FieldName_in?: Maybe<String[] | String>;
  FieldName_not_in?: Maybe<String[] | String>;
  FieldName_lt?: Maybe<String>;
  FieldName_lte?: Maybe<String>;
  FieldName_gt?: Maybe<String>;
  FieldName_gte?: Maybe<String>;
  FieldName_contains?: Maybe<String>;
  FieldName_not_contains?: Maybe<String>;
  FieldName_starts_with?: Maybe<String>;
  FieldName_not_starts_with?: Maybe<String>;
  FieldName_ends_with?: Maybe<String>;
  FieldName_not_ends_with?: Maybe<String>;
  Answers?: Maybe<String>;
  Answers_not?: Maybe<String>;
  Answers_in?: Maybe<String[] | String>;
  Answers_not_in?: Maybe<String[] | String>;
  Answers_lt?: Maybe<String>;
  Answers_lte?: Maybe<String>;
  Answers_gt?: Maybe<String>;
  Answers_gte?: Maybe<String>;
  Answers_contains?: Maybe<String>;
  Answers_not_contains?: Maybe<String>;
  Answers_starts_with?: Maybe<String>;
  Answers_not_starts_with?: Maybe<String>;
  Answers_ends_with?: Maybe<String>;
  Answers_not_ends_with?: Maybe<String>;
  IsEditable?: Maybe<Boolean>;
  IsEditable_not?: Maybe<Boolean>;
  IsViewable?: Maybe<Boolean>;
  IsViewable_not?: Maybe<Boolean>;
  AND?: Maybe<
    | EntityConnStrctjsonRestrictedWhereInput[]
    | EntityConnStrctjsonRestrictedWhereInput
  >;
}

export type SubscriberFieldMapWhereUniqueInput = AtLeastOne<{
  SubscriberFieldMapID: Maybe<ID_Input>;
}>;

export interface FieldSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FieldWhereInput>;
  AND?: Maybe<FieldSubscriptionWhereInput[] | FieldSubscriptionWhereInput>;
}

export interface ProcessUpdateOneInput {
  create?: Maybe<ProcessCreateInput>;
  update?: Maybe<ProcessUpdateDataInput>;
  upsert?: Maybe<ProcessUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProcessWhereUniqueInput>;
}

export interface EntitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EntityWhereInput>;
  AND?: Maybe<EntitySubscriptionWhereInput[] | EntitySubscriptionWhereInput>;
}

export interface SubscriberFieldMapWhereInput {
  SubscriberFieldMapID?: Maybe<ID_Input>;
  SubscriberFieldMapID_not?: Maybe<ID_Input>;
  SubscriberFieldMapID_in?: Maybe<ID_Input[] | ID_Input>;
  SubscriberFieldMapID_not_in?: Maybe<ID_Input[] | ID_Input>;
  SubscriberFieldMapID_lt?: Maybe<ID_Input>;
  SubscriberFieldMapID_lte?: Maybe<ID_Input>;
  SubscriberFieldMapID_gt?: Maybe<ID_Input>;
  SubscriberFieldMapID_gte?: Maybe<ID_Input>;
  SubscriberFieldMapID_contains?: Maybe<ID_Input>;
  SubscriberFieldMapID_not_contains?: Maybe<ID_Input>;
  SubscriberFieldMapID_starts_with?: Maybe<ID_Input>;
  SubscriberFieldMapID_not_starts_with?: Maybe<ID_Input>;
  SubscriberFieldMapID_ends_with?: Maybe<ID_Input>;
  SubscriberFieldMapID_not_ends_with?: Maybe<ID_Input>;
  SourceEntityID?: Maybe<EntityWhereInput>;
  TargetEntityID?: Maybe<EntityWhereInput>;
  SourceField_some?: Maybe<FieldWhereInput>;
  TargetField_some?: Maybe<FieldWhereInput>;
  Status?: Maybe<Status>;
  Status_not?: Maybe<Status>;
  Status_in?: Maybe<Status[] | Status>;
  Status_not_in?: Maybe<Status[] | Status>;
  FieldShortDesc?: Maybe<String>;
  FieldShortDesc_not?: Maybe<String>;
  FieldShortDesc_in?: Maybe<String[] | String>;
  FieldShortDesc_not_in?: Maybe<String[] | String>;
  FieldShortDesc_lt?: Maybe<String>;
  FieldShortDesc_lte?: Maybe<String>;
  FieldShortDesc_gt?: Maybe<String>;
  FieldShortDesc_gte?: Maybe<String>;
  FieldShortDesc_contains?: Maybe<String>;
  FieldShortDesc_not_contains?: Maybe<String>;
  FieldShortDesc_starts_with?: Maybe<String>;
  FieldShortDesc_not_starts_with?: Maybe<String>;
  FieldShortDesc_ends_with?: Maybe<String>;
  FieldShortDesc_not_ends_with?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  FieldLongDesc_not?: Maybe<String>;
  FieldLongDesc_in?: Maybe<String[] | String>;
  FieldLongDesc_not_in?: Maybe<String[] | String>;
  FieldLongDesc_lt?: Maybe<String>;
  FieldLongDesc_lte?: Maybe<String>;
  FieldLongDesc_gt?: Maybe<String>;
  FieldLongDesc_gte?: Maybe<String>;
  FieldLongDesc_contains?: Maybe<String>;
  FieldLongDesc_not_contains?: Maybe<String>;
  FieldLongDesc_starts_with?: Maybe<String>;
  FieldLongDesc_not_starts_with?: Maybe<String>;
  FieldLongDesc_ends_with?: Maybe<String>;
  FieldLongDesc_not_ends_with?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  CreatedDate?: Maybe<DateTimeInput>;
  CreatedDate_not?: Maybe<DateTimeInput>;
  CreatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_lt?: Maybe<DateTimeInput>;
  CreatedDate_lte?: Maybe<DateTimeInput>;
  CreatedDate_gt?: Maybe<DateTimeInput>;
  CreatedDate_gte?: Maybe<DateTimeInput>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  ModifiedDate?: Maybe<DateTimeInput>;
  ModifiedDate_not?: Maybe<DateTimeInput>;
  ModifiedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_lt?: Maybe<DateTimeInput>;
  ModifiedDate_lte?: Maybe<DateTimeInput>;
  ModifiedDate_gt?: Maybe<DateTimeInput>;
  ModifiedDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SubscriberFieldMapWhereInput[] | SubscriberFieldMapWhereInput>;
}

export interface DatabaseUserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DatabaseUserWhereInput>;
  AND?: Maybe<
    DatabaseUserSubscriptionWhereInput[] | DatabaseUserSubscriptionWhereInput
  >;
}

export interface SubscriberFieldSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SubscriberFieldWhereInput>;
  AND?: Maybe<
    | SubscriberFieldSubscriptionWhereInput[]
    | SubscriberFieldSubscriptionWhereInput
  >;
}

export interface PluginSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PluginWhereInput>;
  AND?: Maybe<PluginSubscriptionWhereInput[] | PluginSubscriptionWhereInput>;
}

export interface SubscriberProcessUpdateDataInput {
  ProcessId?: Maybe<ProcessUpdateOneInput>;
  TenantId?: Maybe<UserUpdateOneInput>;
  ConnectorId?: Maybe<ConnectorUpdateOneInput>;
  Status?: Maybe<Status>;
  Stage?: Maybe<Stage>;
  CreatedBy?: Maybe<String>;
  Schedule?: Maybe<ScheduleUpdateManyWithoutSubscriberProcessInput>;
  ModifiedBy?: Maybe<String>;
  LastSyncDate?: Maybe<String>;
  PrimaryEntity?: Maybe<EntityUpdateOneInput>;
  SecondaryEntity?: Maybe<EntityUpdateOneInput>;
}

export interface ConnectorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ConnectorWhereInput>;
  AND?: Maybe<
    ConnectorSubscriptionWhereInput[] | ConnectorSubscriptionWhereInput
  >;
}

export interface SubscriberProcessUpdateOneInput {
  create?: Maybe<SubscriberProcessCreateInput>;
  update?: Maybe<SubscriberProcessUpdateDataInput>;
  upsert?: Maybe<SubscriberProcessUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SubscriberProcessWhereUniqueInput>;
}

export type FieldWhereUniqueInput = AtLeastOne<{
  FieldID: Maybe<ID_Input>;
}>;

export interface SubcriptionHistoryUpsertNestedInput {
  update: SubcriptionHistoryUpdateDataInput;
  create: SubcriptionHistoryCreateInput;
}

export interface FieldWhereInput {
  FieldID?: Maybe<ID_Input>;
  FieldID_not?: Maybe<ID_Input>;
  FieldID_in?: Maybe<ID_Input[] | ID_Input>;
  FieldID_not_in?: Maybe<ID_Input[] | ID_Input>;
  FieldID_lt?: Maybe<ID_Input>;
  FieldID_lte?: Maybe<ID_Input>;
  FieldID_gt?: Maybe<ID_Input>;
  FieldID_gte?: Maybe<ID_Input>;
  FieldID_contains?: Maybe<ID_Input>;
  FieldID_not_contains?: Maybe<ID_Input>;
  FieldID_starts_with?: Maybe<ID_Input>;
  FieldID_not_starts_with?: Maybe<ID_Input>;
  FieldID_ends_with?: Maybe<ID_Input>;
  FieldID_not_ends_with?: Maybe<ID_Input>;
  PluginsID?: Maybe<PluginWhereInput>;
  EntityID?: Maybe<EntityWhereInput>;
  FieldName?: Maybe<String>;
  FieldName_not?: Maybe<String>;
  FieldName_in?: Maybe<String[] | String>;
  FieldName_not_in?: Maybe<String[] | String>;
  FieldName_lt?: Maybe<String>;
  FieldName_lte?: Maybe<String>;
  FieldName_gt?: Maybe<String>;
  FieldName_gte?: Maybe<String>;
  FieldName_contains?: Maybe<String>;
  FieldName_not_contains?: Maybe<String>;
  FieldName_starts_with?: Maybe<String>;
  FieldName_not_starts_with?: Maybe<String>;
  FieldName_ends_with?: Maybe<String>;
  FieldName_not_ends_with?: Maybe<String>;
  FieldShortDesc?: Maybe<String>;
  FieldShortDesc_not?: Maybe<String>;
  FieldShortDesc_in?: Maybe<String[] | String>;
  FieldShortDesc_not_in?: Maybe<String[] | String>;
  FieldShortDesc_lt?: Maybe<String>;
  FieldShortDesc_lte?: Maybe<String>;
  FieldShortDesc_gt?: Maybe<String>;
  FieldShortDesc_gte?: Maybe<String>;
  FieldShortDesc_contains?: Maybe<String>;
  FieldShortDesc_not_contains?: Maybe<String>;
  FieldShortDesc_starts_with?: Maybe<String>;
  FieldShortDesc_not_starts_with?: Maybe<String>;
  FieldShortDesc_ends_with?: Maybe<String>;
  FieldShortDesc_not_ends_with?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  FieldLongDesc_not?: Maybe<String>;
  FieldLongDesc_in?: Maybe<String[] | String>;
  FieldLongDesc_not_in?: Maybe<String[] | String>;
  FieldLongDesc_lt?: Maybe<String>;
  FieldLongDesc_lte?: Maybe<String>;
  FieldLongDesc_gt?: Maybe<String>;
  FieldLongDesc_gte?: Maybe<String>;
  FieldLongDesc_contains?: Maybe<String>;
  FieldLongDesc_not_contains?: Maybe<String>;
  FieldLongDesc_starts_with?: Maybe<String>;
  FieldLongDesc_not_starts_with?: Maybe<String>;
  FieldLongDesc_ends_with?: Maybe<String>;
  FieldLongDesc_not_ends_with?: Maybe<String>;
  DataType?: Maybe<String>;
  DataType_not?: Maybe<String>;
  DataType_in?: Maybe<String[] | String>;
  DataType_not_in?: Maybe<String[] | String>;
  DataType_lt?: Maybe<String>;
  DataType_lte?: Maybe<String>;
  DataType_gt?: Maybe<String>;
  DataType_gte?: Maybe<String>;
  DataType_contains?: Maybe<String>;
  DataType_not_contains?: Maybe<String>;
  DataType_starts_with?: Maybe<String>;
  DataType_not_starts_with?: Maybe<String>;
  DataType_ends_with?: Maybe<String>;
  DataType_not_ends_with?: Maybe<String>;
  FieldType?: Maybe<String>;
  FieldType_not?: Maybe<String>;
  FieldType_in?: Maybe<String[] | String>;
  FieldType_not_in?: Maybe<String[] | String>;
  FieldType_lt?: Maybe<String>;
  FieldType_lte?: Maybe<String>;
  FieldType_gt?: Maybe<String>;
  FieldType_gte?: Maybe<String>;
  FieldType_contains?: Maybe<String>;
  FieldType_not_contains?: Maybe<String>;
  FieldType_starts_with?: Maybe<String>;
  FieldType_not_starts_with?: Maybe<String>;
  FieldType_ends_with?: Maybe<String>;
  FieldType_not_ends_with?: Maybe<String>;
  Status?: Maybe<Status>;
  Status_not?: Maybe<Status>;
  Status_in?: Maybe<Status[] | Status>;
  Status_not_in?: Maybe<Status[] | Status>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  CreatedDate?: Maybe<DateTimeInput>;
  CreatedDate_not?: Maybe<DateTimeInput>;
  CreatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_lt?: Maybe<DateTimeInput>;
  CreatedDate_lte?: Maybe<DateTimeInput>;
  CreatedDate_gt?: Maybe<DateTimeInput>;
  CreatedDate_gte?: Maybe<DateTimeInput>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  ModifiedDate?: Maybe<DateTimeInput>;
  ModifiedDate_not?: Maybe<DateTimeInput>;
  ModifiedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_lt?: Maybe<DateTimeInput>;
  ModifiedDate_lte?: Maybe<DateTimeInput>;
  ModifiedDate_gt?: Maybe<DateTimeInput>;
  ModifiedDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FieldWhereInput[] | FieldWhereInput>;
}

export type SubscriberProcessWhereUniqueInput = AtLeastOne<{
  SubscriberProcessID: Maybe<ID_Input>;
}>;

export interface TestimonialUpdateManyMutationInput {
  Message?: Maybe<String>;
  Author?: Maybe<String>;
  Designation?: Maybe<String>;
  CompanyName?: Maybe<String>;
  ImageName?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface SubscriberFieldMapSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SubscriberFieldMapWhereInput>;
  AND?: Maybe<
    | SubscriberFieldMapSubscriptionWhereInput[]
    | SubscriberFieldMapSubscriptionWhereInput
  >;
}

export interface TestimonialCreateInput {
  TestimonialID?: Maybe<ID_Input>;
  Message?: Maybe<String>;
  Author?: Maybe<String>;
  Designation?: Maybe<String>;
  CompanyName?: Maybe<String>;
  ImageName?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface SubscriptionIntegrationUpsertNestedInput {
  update: SubscriptionIntegrationUpdateDataInput;
  create: SubscriptionIntegrationCreateInput;
}

export interface SubscriptionIntegrationUpdateManyMutationInput {
  NoOfLicenses?: Maybe<String>;
  NoOfUsers?: Maybe<String>;
  Status?: Maybe<Status>;
  SubscriptionEndDate?: Maybe<DateTimeInput>;
}

export interface SubscriptionIntegrationUpdateDataInput {
  NoOfLicenses?: Maybe<String>;
  NoOfUsers?: Maybe<String>;
  Status?: Maybe<Status>;
  TenantId?: Maybe<UserUpdateOneInput>;
  ConnectorId?: Maybe<ConnectorUpdateOneInput>;
  SubscriptionEndDate?: Maybe<DateTimeInput>;
  PrimaryPluginConnectionData?: Maybe<ConnStrctjsonUpdateManyInput>;
  SecondaryPluginConnectionData?: Maybe<ConnStrctjsonUpdateManyInput>;
  ConfigStructure?: Maybe<EntityConnStrctjsonUpdateManyInput>;
}

export interface DatabaseUserWhereInput {
  UserId?: Maybe<ID_Input>;
  UserId_not?: Maybe<ID_Input>;
  UserId_in?: Maybe<ID_Input[] | ID_Input>;
  UserId_not_in?: Maybe<ID_Input[] | ID_Input>;
  UserId_lt?: Maybe<ID_Input>;
  UserId_lte?: Maybe<ID_Input>;
  UserId_gt?: Maybe<ID_Input>;
  UserId_gte?: Maybe<ID_Input>;
  UserId_contains?: Maybe<ID_Input>;
  UserId_not_contains?: Maybe<ID_Input>;
  UserId_starts_with?: Maybe<ID_Input>;
  UserId_not_starts_with?: Maybe<ID_Input>;
  UserId_ends_with?: Maybe<ID_Input>;
  UserId_not_ends_with?: Maybe<ID_Input>;
  Name?: Maybe<String>;
  Name_not?: Maybe<String>;
  Name_in?: Maybe<String[] | String>;
  Name_not_in?: Maybe<String[] | String>;
  Name_lt?: Maybe<String>;
  Name_lte?: Maybe<String>;
  Name_gt?: Maybe<String>;
  Name_gte?: Maybe<String>;
  Name_contains?: Maybe<String>;
  Name_not_contains?: Maybe<String>;
  Name_starts_with?: Maybe<String>;
  Name_not_starts_with?: Maybe<String>;
  Name_ends_with?: Maybe<String>;
  Name_not_ends_with?: Maybe<String>;
  Password?: Maybe<String>;
  Password_not?: Maybe<String>;
  Password_in?: Maybe<String[] | String>;
  Password_not_in?: Maybe<String[] | String>;
  Password_lt?: Maybe<String>;
  Password_lte?: Maybe<String>;
  Password_gt?: Maybe<String>;
  Password_gte?: Maybe<String>;
  Password_contains?: Maybe<String>;
  Password_not_contains?: Maybe<String>;
  Password_starts_with?: Maybe<String>;
  Password_not_starts_with?: Maybe<String>;
  Password_ends_with?: Maybe<String>;
  Password_not_ends_with?: Maybe<String>;
  Claims?: Maybe<DBClaims>;
  Claims_not?: Maybe<DBClaims>;
  Claims_in?: Maybe<DBClaims[] | DBClaims>;
  Claims_not_in?: Maybe<DBClaims[] | DBClaims>;
  Token?: Maybe<String>;
  Token_not?: Maybe<String>;
  Token_in?: Maybe<String[] | String>;
  Token_not_in?: Maybe<String[] | String>;
  Token_lt?: Maybe<String>;
  Token_lte?: Maybe<String>;
  Token_gt?: Maybe<String>;
  Token_gte?: Maybe<String>;
  Token_contains?: Maybe<String>;
  Token_not_contains?: Maybe<String>;
  Token_starts_with?: Maybe<String>;
  Token_not_starts_with?: Maybe<String>;
  Token_ends_with?: Maybe<String>;
  Token_not_ends_with?: Maybe<String>;
  AND?: Maybe<DatabaseUserWhereInput[] | DatabaseUserWhereInput>;
}

export interface SubscriptionIntegrationUpdateOneInput {
  create?: Maybe<SubscriptionIntegrationCreateInput>;
  update?: Maybe<SubscriptionIntegrationUpdateDataInput>;
  upsert?: Maybe<SubscriptionIntegrationUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SubscriptionIntegrationWhereUniqueInput>;
}

export interface SubscriberProcessUpdateManyMutationInput {
  Status?: Maybe<Status>;
  Stage?: Maybe<Stage>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  LastSyncDate?: Maybe<String>;
}

export type SubscriptionIntegrationWhereUniqueInput = AtLeastOne<{
  SubscriptionIntegrationId: Maybe<ID_Input>;
}>;

export type LogWhereUniqueInput = AtLeastOne<{
  LogId: Maybe<ID_Input>;
}>;

export interface SubscriberProcessSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SubscriberProcessWhereInput>;
  AND?: Maybe<
    | SubscriberProcessSubscriptionWhereInput[]
    | SubscriberProcessSubscriptionWhereInput
  >;
}

export interface SubscriberFieldMapUpdateInput {
  SourceEntityID?: Maybe<EntityUpdateOneInput>;
  TargetEntityID?: Maybe<EntityUpdateOneInput>;
  SourceField?: Maybe<FieldUpdateManyInput>;
  TargetField?: Maybe<FieldUpdateManyInput>;
  Status?: Maybe<Status>;
  FieldShortDesc?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface ConnectorUpsertNestedInput {
  update: ConnectorUpdateDataInput;
  create: ConnectorCreateInput;
}

export interface SubscriberFieldUpdateManyMutationInput {
  FieldName?: Maybe<String>;
  DataType?: Maybe<String>;
  FieldType?: Maybe<String>;
  Status?: Maybe<Status>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface ConnectorUpdateDataInput {
  Status?: Maybe<Status>;
  ConnectorTitle?: Maybe<String>;
  ConnectorShortName?: Maybe<String>;
  ConnectorSEOName?: Maybe<String>;
  ConnectorShortDesc?: Maybe<String>;
  ConnectorLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  Popular?: Maybe<Boolean>;
  Recent?: Maybe<Boolean>;
  testuser?: Maybe<String>;
  PrimaryPluginId?: Maybe<PluginUpdateOneInput>;
  SecondaryPluginId?: Maybe<PluginUpdateOneInput>;
}

export interface SubscriberFieldCreateInput {
  SubscriberFieldID?: Maybe<ID_Input>;
  PluginsID?: Maybe<PluginCreateOneInput>;
  EntityID?: Maybe<EntityCreateOneInput>;
  FieldName?: Maybe<String>;
  DataType?: Maybe<String>;
  FieldType?: Maybe<String>;
  Status?: Maybe<Status>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface ConnectorUpdateOneInput {
  create?: Maybe<ConnectorCreateInput>;
  update?: Maybe<ConnectorUpdateDataInput>;
  upsert?: Maybe<ConnectorUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ConnectorWhereUniqueInput>;
}

export interface ScheduleWhereInput {
  ScheduleID?: Maybe<ID_Input>;
  ScheduleID_not?: Maybe<ID_Input>;
  ScheduleID_in?: Maybe<ID_Input[] | ID_Input>;
  ScheduleID_not_in?: Maybe<ID_Input[] | ID_Input>;
  ScheduleID_lt?: Maybe<ID_Input>;
  ScheduleID_lte?: Maybe<ID_Input>;
  ScheduleID_gt?: Maybe<ID_Input>;
  ScheduleID_gte?: Maybe<ID_Input>;
  ScheduleID_contains?: Maybe<ID_Input>;
  ScheduleID_not_contains?: Maybe<ID_Input>;
  ScheduleID_starts_with?: Maybe<ID_Input>;
  ScheduleID_not_starts_with?: Maybe<ID_Input>;
  ScheduleID_ends_with?: Maybe<ID_Input>;
  ScheduleID_not_ends_with?: Maybe<ID_Input>;
  TenantId?: Maybe<UserWhereInput>;
  ProcessId?: Maybe<ProcessWhereInput>;
  SubscriberProcess?: Maybe<SubscriberProcessWhereInput>;
  SubcriptionHistoryId?: Maybe<SubcriptionHistoryWhereInput>;
  Field?: Maybe<String>;
  Field_not?: Maybe<String>;
  Field_in?: Maybe<String[] | String>;
  Field_not_in?: Maybe<String[] | String>;
  Field_lt?: Maybe<String>;
  Field_lte?: Maybe<String>;
  Field_gt?: Maybe<String>;
  Field_gte?: Maybe<String>;
  Field_contains?: Maybe<String>;
  Field_not_contains?: Maybe<String>;
  Field_starts_with?: Maybe<String>;
  Field_not_starts_with?: Maybe<String>;
  Field_ends_with?: Maybe<String>;
  Field_not_ends_with?: Maybe<String>;
  Status?: Maybe<Stage>;
  Status_not?: Maybe<Stage>;
  Status_in?: Maybe<Stage[] | Stage>;
  Status_not_in?: Maybe<Stage[] | Stage>;
  DailyOccurence?: Maybe<String>;
  DailyOccurence_not?: Maybe<String>;
  DailyOccurence_in?: Maybe<String[] | String>;
  DailyOccurence_not_in?: Maybe<String[] | String>;
  DailyOccurence_lt?: Maybe<String>;
  DailyOccurence_lte?: Maybe<String>;
  DailyOccurence_gt?: Maybe<String>;
  DailyOccurence_gte?: Maybe<String>;
  DailyOccurence_contains?: Maybe<String>;
  DailyOccurence_not_contains?: Maybe<String>;
  DailyOccurence_starts_with?: Maybe<String>;
  DailyOccurence_not_starts_with?: Maybe<String>;
  DailyOccurence_ends_with?: Maybe<String>;
  DailyOccurence_not_ends_with?: Maybe<String>;
  ScheduleType?: Maybe<String>;
  ScheduleType_not?: Maybe<String>;
  ScheduleType_in?: Maybe<String[] | String>;
  ScheduleType_not_in?: Maybe<String[] | String>;
  ScheduleType_lt?: Maybe<String>;
  ScheduleType_lte?: Maybe<String>;
  ScheduleType_gt?: Maybe<String>;
  ScheduleType_gte?: Maybe<String>;
  ScheduleType_contains?: Maybe<String>;
  ScheduleType_not_contains?: Maybe<String>;
  ScheduleType_starts_with?: Maybe<String>;
  ScheduleType_not_starts_with?: Maybe<String>;
  ScheduleType_ends_with?: Maybe<String>;
  ScheduleType_not_ends_with?: Maybe<String>;
  DailyRecurrenceType?: Maybe<String>;
  DailyRecurrenceType_not?: Maybe<String>;
  DailyRecurrenceType_in?: Maybe<String[] | String>;
  DailyRecurrenceType_not_in?: Maybe<String[] | String>;
  DailyRecurrenceType_lt?: Maybe<String>;
  DailyRecurrenceType_lte?: Maybe<String>;
  DailyRecurrenceType_gt?: Maybe<String>;
  DailyRecurrenceType_gte?: Maybe<String>;
  DailyRecurrenceType_contains?: Maybe<String>;
  DailyRecurrenceType_not_contains?: Maybe<String>;
  DailyRecurrenceType_starts_with?: Maybe<String>;
  DailyRecurrenceType_not_starts_with?: Maybe<String>;
  DailyRecurrenceType_ends_with?: Maybe<String>;
  DailyRecurrenceType_not_ends_with?: Maybe<String>;
  OccursAt?: Maybe<String>;
  OccursAt_not?: Maybe<String>;
  OccursAt_in?: Maybe<String[] | String>;
  OccursAt_not_in?: Maybe<String[] | String>;
  OccursAt_lt?: Maybe<String>;
  OccursAt_lte?: Maybe<String>;
  OccursAt_gt?: Maybe<String>;
  OccursAt_gte?: Maybe<String>;
  OccursAt_contains?: Maybe<String>;
  OccursAt_not_contains?: Maybe<String>;
  OccursAt_starts_with?: Maybe<String>;
  OccursAt_not_starts_with?: Maybe<String>;
  OccursAt_ends_with?: Maybe<String>;
  OccursAt_not_ends_with?: Maybe<String>;
  DailyInterval?: Maybe<String>;
  DailyInterval_not?: Maybe<String>;
  DailyInterval_in?: Maybe<String[] | String>;
  DailyInterval_not_in?: Maybe<String[] | String>;
  DailyInterval_lt?: Maybe<String>;
  DailyInterval_lte?: Maybe<String>;
  DailyInterval_gt?: Maybe<String>;
  DailyInterval_gte?: Maybe<String>;
  DailyInterval_contains?: Maybe<String>;
  DailyInterval_not_contains?: Maybe<String>;
  DailyInterval_starts_with?: Maybe<String>;
  DailyInterval_not_starts_with?: Maybe<String>;
  DailyInterval_ends_with?: Maybe<String>;
  DailyInterval_not_ends_with?: Maybe<String>;
  DailyIntervalSpan?: Maybe<String>;
  DailyIntervalSpan_not?: Maybe<String>;
  DailyIntervalSpan_in?: Maybe<String[] | String>;
  DailyIntervalSpan_not_in?: Maybe<String[] | String>;
  DailyIntervalSpan_lt?: Maybe<String>;
  DailyIntervalSpan_lte?: Maybe<String>;
  DailyIntervalSpan_gt?: Maybe<String>;
  DailyIntervalSpan_gte?: Maybe<String>;
  DailyIntervalSpan_contains?: Maybe<String>;
  DailyIntervalSpan_not_contains?: Maybe<String>;
  DailyIntervalSpan_starts_with?: Maybe<String>;
  DailyIntervalSpan_not_starts_with?: Maybe<String>;
  DailyIntervalSpan_ends_with?: Maybe<String>;
  DailyIntervalSpan_not_ends_with?: Maybe<String>;
  DayofMonth?: Maybe<String>;
  DayofMonth_not?: Maybe<String>;
  DayofMonth_in?: Maybe<String[] | String>;
  DayofMonth_not_in?: Maybe<String[] | String>;
  DayofMonth_lt?: Maybe<String>;
  DayofMonth_lte?: Maybe<String>;
  DayofMonth_gt?: Maybe<String>;
  DayofMonth_gte?: Maybe<String>;
  DayofMonth_contains?: Maybe<String>;
  DayofMonth_not_contains?: Maybe<String>;
  DayofMonth_starts_with?: Maybe<String>;
  DayofMonth_not_starts_with?: Maybe<String>;
  DayofMonth_ends_with?: Maybe<String>;
  DayofMonth_not_ends_with?: Maybe<String>;
  LastExecuted?: Maybe<String>;
  LastExecuted_not?: Maybe<String>;
  LastExecuted_in?: Maybe<String[] | String>;
  LastExecuted_not_in?: Maybe<String[] | String>;
  LastExecuted_lt?: Maybe<String>;
  LastExecuted_lte?: Maybe<String>;
  LastExecuted_gt?: Maybe<String>;
  LastExecuted_gte?: Maybe<String>;
  LastExecuted_contains?: Maybe<String>;
  LastExecuted_not_contains?: Maybe<String>;
  LastExecuted_starts_with?: Maybe<String>;
  LastExecuted_not_starts_with?: Maybe<String>;
  LastExecuted_ends_with?: Maybe<String>;
  LastExecuted_not_ends_with?: Maybe<String>;
  NextOccurence?: Maybe<String>;
  NextOccurence_not?: Maybe<String>;
  NextOccurence_in?: Maybe<String[] | String>;
  NextOccurence_not_in?: Maybe<String[] | String>;
  NextOccurence_lt?: Maybe<String>;
  NextOccurence_lte?: Maybe<String>;
  NextOccurence_gt?: Maybe<String>;
  NextOccurence_gte?: Maybe<String>;
  NextOccurence_contains?: Maybe<String>;
  NextOccurence_not_contains?: Maybe<String>;
  NextOccurence_starts_with?: Maybe<String>;
  NextOccurence_not_starts_with?: Maybe<String>;
  NextOccurence_ends_with?: Maybe<String>;
  NextOccurence_not_ends_with?: Maybe<String>;
  SubscriptionIntegrationId?: Maybe<SubscriptionIntegrationWhereInput>;
  CreatedDate?: Maybe<String>;
  CreatedDate_not?: Maybe<String>;
  CreatedDate_in?: Maybe<String[] | String>;
  CreatedDate_not_in?: Maybe<String[] | String>;
  CreatedDate_lt?: Maybe<String>;
  CreatedDate_lte?: Maybe<String>;
  CreatedDate_gt?: Maybe<String>;
  CreatedDate_gte?: Maybe<String>;
  CreatedDate_contains?: Maybe<String>;
  CreatedDate_not_contains?: Maybe<String>;
  CreatedDate_starts_with?: Maybe<String>;
  CreatedDate_not_starts_with?: Maybe<String>;
  CreatedDate_ends_with?: Maybe<String>;
  CreatedDate_not_ends_with?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  ModifiedDate?: Maybe<String>;
  ModifiedDate_not?: Maybe<String>;
  ModifiedDate_in?: Maybe<String[] | String>;
  ModifiedDate_not_in?: Maybe<String[] | String>;
  ModifiedDate_lt?: Maybe<String>;
  ModifiedDate_lte?: Maybe<String>;
  ModifiedDate_gt?: Maybe<String>;
  ModifiedDate_gte?: Maybe<String>;
  ModifiedDate_contains?: Maybe<String>;
  ModifiedDate_not_contains?: Maybe<String>;
  ModifiedDate_starts_with?: Maybe<String>;
  ModifiedDate_not_starts_with?: Maybe<String>;
  ModifiedDate_ends_with?: Maybe<String>;
  ModifiedDate_not_ends_with?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  StartTime?: Maybe<String>;
  StartTime_not?: Maybe<String>;
  StartTime_in?: Maybe<String[] | String>;
  StartTime_not_in?: Maybe<String[] | String>;
  StartTime_lt?: Maybe<String>;
  StartTime_lte?: Maybe<String>;
  StartTime_gt?: Maybe<String>;
  StartTime_gte?: Maybe<String>;
  StartTime_contains?: Maybe<String>;
  StartTime_not_contains?: Maybe<String>;
  StartTime_starts_with?: Maybe<String>;
  StartTime_not_starts_with?: Maybe<String>;
  StartTime_ends_with?: Maybe<String>;
  StartTime_not_ends_with?: Maybe<String>;
  EndTime?: Maybe<String>;
  EndTime_not?: Maybe<String>;
  EndTime_in?: Maybe<String[] | String>;
  EndTime_not_in?: Maybe<String[] | String>;
  EndTime_lt?: Maybe<String>;
  EndTime_lte?: Maybe<String>;
  EndTime_gt?: Maybe<String>;
  EndTime_gte?: Maybe<String>;
  EndTime_contains?: Maybe<String>;
  EndTime_not_contains?: Maybe<String>;
  EndTime_starts_with?: Maybe<String>;
  EndTime_not_starts_with?: Maybe<String>;
  EndTime_ends_with?: Maybe<String>;
  EndTime_not_ends_with?: Maybe<String>;
  Type?: Maybe<String>;
  Type_not?: Maybe<String>;
  Type_in?: Maybe<String[] | String>;
  Type_not_in?: Maybe<String[] | String>;
  Type_lt?: Maybe<String>;
  Type_lte?: Maybe<String>;
  Type_gt?: Maybe<String>;
  Type_gte?: Maybe<String>;
  Type_contains?: Maybe<String>;
  Type_not_contains?: Maybe<String>;
  Type_starts_with?: Maybe<String>;
  Type_not_starts_with?: Maybe<String>;
  Type_ends_with?: Maybe<String>;
  Type_not_ends_with?: Maybe<String>;
  AND?: Maybe<ScheduleWhereInput[] | ScheduleWhereInput>;
}

export type TestimonialWhereUniqueInput = AtLeastOne<{
  TestimonialID: Maybe<ID_Input>;
}>;

export interface ProcessWhereInput {
  ProcessId?: Maybe<ID_Input>;
  ProcessId_not?: Maybe<ID_Input>;
  ProcessId_in?: Maybe<ID_Input[] | ID_Input>;
  ProcessId_not_in?: Maybe<ID_Input[] | ID_Input>;
  ProcessId_lt?: Maybe<ID_Input>;
  ProcessId_lte?: Maybe<ID_Input>;
  ProcessId_gt?: Maybe<ID_Input>;
  ProcessId_gte?: Maybe<ID_Input>;
  ProcessId_contains?: Maybe<ID_Input>;
  ProcessId_not_contains?: Maybe<ID_Input>;
  ProcessId_starts_with?: Maybe<ID_Input>;
  ProcessId_not_starts_with?: Maybe<ID_Input>;
  ProcessId_ends_with?: Maybe<ID_Input>;
  ProcessId_not_ends_with?: Maybe<ID_Input>;
  ConnectorId?: Maybe<ConnectorWhereInput>;
  ProcessShortDesc?: Maybe<String>;
  ProcessShortDesc_not?: Maybe<String>;
  ProcessShortDesc_in?: Maybe<String[] | String>;
  ProcessShortDesc_not_in?: Maybe<String[] | String>;
  ProcessShortDesc_lt?: Maybe<String>;
  ProcessShortDesc_lte?: Maybe<String>;
  ProcessShortDesc_gt?: Maybe<String>;
  ProcessShortDesc_gte?: Maybe<String>;
  ProcessShortDesc_contains?: Maybe<String>;
  ProcessShortDesc_not_contains?: Maybe<String>;
  ProcessShortDesc_starts_with?: Maybe<String>;
  ProcessShortDesc_not_starts_with?: Maybe<String>;
  ProcessShortDesc_ends_with?: Maybe<String>;
  ProcessShortDesc_not_ends_with?: Maybe<String>;
  ProcessLongDesc?: Maybe<String>;
  ProcessLongDesc_not?: Maybe<String>;
  ProcessLongDesc_in?: Maybe<String[] | String>;
  ProcessLongDesc_not_in?: Maybe<String[] | String>;
  ProcessLongDesc_lt?: Maybe<String>;
  ProcessLongDesc_lte?: Maybe<String>;
  ProcessLongDesc_gt?: Maybe<String>;
  ProcessLongDesc_gte?: Maybe<String>;
  ProcessLongDesc_contains?: Maybe<String>;
  ProcessLongDesc_not_contains?: Maybe<String>;
  ProcessLongDesc_starts_with?: Maybe<String>;
  ProcessLongDesc_not_starts_with?: Maybe<String>;
  ProcessLongDesc_ends_with?: Maybe<String>;
  ProcessLongDesc_not_ends_with?: Maybe<String>;
  Status?: Maybe<Status>;
  Status_not?: Maybe<Status>;
  Status_in?: Maybe<Status[] | Status>;
  Status_not_in?: Maybe<Status[] | Status>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  CreatedDate?: Maybe<DateTimeInput>;
  CreatedDate_not?: Maybe<DateTimeInput>;
  CreatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_lt?: Maybe<DateTimeInput>;
  CreatedDate_lte?: Maybe<DateTimeInput>;
  CreatedDate_gt?: Maybe<DateTimeInput>;
  CreatedDate_gte?: Maybe<DateTimeInput>;
  ModifiedDate?: Maybe<DateTimeInput>;
  ModifiedDate_not?: Maybe<DateTimeInput>;
  ModifiedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_lt?: Maybe<DateTimeInput>;
  ModifiedDate_lte?: Maybe<DateTimeInput>;
  ModifiedDate_gt?: Maybe<DateTimeInput>;
  ModifiedDate_gte?: Maybe<DateTimeInput>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  PrimaryEntity?: Maybe<EntityWhereInput>;
  SecondaryEntity?: Maybe<EntityWhereInput>;
  AND?: Maybe<ProcessWhereInput[] | ProcessWhereInput>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface SubcriptionHistoryWhereInput {
  SubcriptionHistoryId?: Maybe<ID_Input>;
  SubcriptionHistoryId_not?: Maybe<ID_Input>;
  SubcriptionHistoryId_in?: Maybe<ID_Input[] | ID_Input>;
  SubcriptionHistoryId_not_in?: Maybe<ID_Input[] | ID_Input>;
  SubcriptionHistoryId_lt?: Maybe<ID_Input>;
  SubcriptionHistoryId_lte?: Maybe<ID_Input>;
  SubcriptionHistoryId_gt?: Maybe<ID_Input>;
  SubcriptionHistoryId_gte?: Maybe<ID_Input>;
  SubcriptionHistoryId_contains?: Maybe<ID_Input>;
  SubcriptionHistoryId_not_contains?: Maybe<ID_Input>;
  SubcriptionHistoryId_starts_with?: Maybe<ID_Input>;
  SubcriptionHistoryId_not_starts_with?: Maybe<ID_Input>;
  SubcriptionHistoryId_ends_with?: Maybe<ID_Input>;
  SubcriptionHistoryId_not_ends_with?: Maybe<ID_Input>;
  TenantId?: Maybe<UserWhereInput>;
  ConnectorId?: Maybe<ConnectorWhereInput>;
  SubscriberID?: Maybe<SubscriptionIntegrationWhereInput>;
  SubcriptionHistoryName?: Maybe<String>;
  SubcriptionHistoryName_not?: Maybe<String>;
  SubcriptionHistoryName_in?: Maybe<String[] | String>;
  SubcriptionHistoryName_not_in?: Maybe<String[] | String>;
  SubcriptionHistoryName_lt?: Maybe<String>;
  SubcriptionHistoryName_lte?: Maybe<String>;
  SubcriptionHistoryName_gt?: Maybe<String>;
  SubcriptionHistoryName_gte?: Maybe<String>;
  SubcriptionHistoryName_contains?: Maybe<String>;
  SubcriptionHistoryName_not_contains?: Maybe<String>;
  SubcriptionHistoryName_starts_with?: Maybe<String>;
  SubcriptionHistoryName_not_starts_with?: Maybe<String>;
  SubcriptionHistoryName_ends_with?: Maybe<String>;
  SubcriptionHistoryName_not_ends_with?: Maybe<String>;
  PrimaryPluginID?: Maybe<PluginWhereInput>;
  SecondaryPluginID?: Maybe<PluginWhereInput>;
  Status?: Maybe<Status>;
  Status_not?: Maybe<Status>;
  Status_in?: Maybe<Status[] | Status>;
  Status_not_in?: Maybe<Status[] | Status>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  CreatedDate?: Maybe<DateTimeInput>;
  CreatedDate_not?: Maybe<DateTimeInput>;
  CreatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_lt?: Maybe<DateTimeInput>;
  CreatedDate_lte?: Maybe<DateTimeInput>;
  CreatedDate_gt?: Maybe<DateTimeInput>;
  CreatedDate_gte?: Maybe<DateTimeInput>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  ModifiedDate?: Maybe<DateTimeInput>;
  ModifiedDate_not?: Maybe<DateTimeInput>;
  ModifiedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_lt?: Maybe<DateTimeInput>;
  ModifiedDate_lte?: Maybe<DateTimeInput>;
  ModifiedDate_gt?: Maybe<DateTimeInput>;
  ModifiedDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SubcriptionHistoryWhereInput[] | SubcriptionHistoryWhereInput>;
}

export interface TestimonialWhereInput {
  TestimonialID?: Maybe<ID_Input>;
  TestimonialID_not?: Maybe<ID_Input>;
  TestimonialID_in?: Maybe<ID_Input[] | ID_Input>;
  TestimonialID_not_in?: Maybe<ID_Input[] | ID_Input>;
  TestimonialID_lt?: Maybe<ID_Input>;
  TestimonialID_lte?: Maybe<ID_Input>;
  TestimonialID_gt?: Maybe<ID_Input>;
  TestimonialID_gte?: Maybe<ID_Input>;
  TestimonialID_contains?: Maybe<ID_Input>;
  TestimonialID_not_contains?: Maybe<ID_Input>;
  TestimonialID_starts_with?: Maybe<ID_Input>;
  TestimonialID_not_starts_with?: Maybe<ID_Input>;
  TestimonialID_ends_with?: Maybe<ID_Input>;
  TestimonialID_not_ends_with?: Maybe<ID_Input>;
  Message?: Maybe<String>;
  Message_not?: Maybe<String>;
  Message_in?: Maybe<String[] | String>;
  Message_not_in?: Maybe<String[] | String>;
  Message_lt?: Maybe<String>;
  Message_lte?: Maybe<String>;
  Message_gt?: Maybe<String>;
  Message_gte?: Maybe<String>;
  Message_contains?: Maybe<String>;
  Message_not_contains?: Maybe<String>;
  Message_starts_with?: Maybe<String>;
  Message_not_starts_with?: Maybe<String>;
  Message_ends_with?: Maybe<String>;
  Message_not_ends_with?: Maybe<String>;
  Author?: Maybe<String>;
  Author_not?: Maybe<String>;
  Author_in?: Maybe<String[] | String>;
  Author_not_in?: Maybe<String[] | String>;
  Author_lt?: Maybe<String>;
  Author_lte?: Maybe<String>;
  Author_gt?: Maybe<String>;
  Author_gte?: Maybe<String>;
  Author_contains?: Maybe<String>;
  Author_not_contains?: Maybe<String>;
  Author_starts_with?: Maybe<String>;
  Author_not_starts_with?: Maybe<String>;
  Author_ends_with?: Maybe<String>;
  Author_not_ends_with?: Maybe<String>;
  Designation?: Maybe<String>;
  Designation_not?: Maybe<String>;
  Designation_in?: Maybe<String[] | String>;
  Designation_not_in?: Maybe<String[] | String>;
  Designation_lt?: Maybe<String>;
  Designation_lte?: Maybe<String>;
  Designation_gt?: Maybe<String>;
  Designation_gte?: Maybe<String>;
  Designation_contains?: Maybe<String>;
  Designation_not_contains?: Maybe<String>;
  Designation_starts_with?: Maybe<String>;
  Designation_not_starts_with?: Maybe<String>;
  Designation_ends_with?: Maybe<String>;
  Designation_not_ends_with?: Maybe<String>;
  CompanyName?: Maybe<String>;
  CompanyName_not?: Maybe<String>;
  CompanyName_in?: Maybe<String[] | String>;
  CompanyName_not_in?: Maybe<String[] | String>;
  CompanyName_lt?: Maybe<String>;
  CompanyName_lte?: Maybe<String>;
  CompanyName_gt?: Maybe<String>;
  CompanyName_gte?: Maybe<String>;
  CompanyName_contains?: Maybe<String>;
  CompanyName_not_contains?: Maybe<String>;
  CompanyName_starts_with?: Maybe<String>;
  CompanyName_not_starts_with?: Maybe<String>;
  CompanyName_ends_with?: Maybe<String>;
  CompanyName_not_ends_with?: Maybe<String>;
  ImageName?: Maybe<String>;
  ImageName_not?: Maybe<String>;
  ImageName_in?: Maybe<String[] | String>;
  ImageName_not_in?: Maybe<String[] | String>;
  ImageName_lt?: Maybe<String>;
  ImageName_lte?: Maybe<String>;
  ImageName_gt?: Maybe<String>;
  ImageName_gte?: Maybe<String>;
  ImageName_contains?: Maybe<String>;
  ImageName_not_contains?: Maybe<String>;
  ImageName_starts_with?: Maybe<String>;
  ImageName_not_starts_with?: Maybe<String>;
  ImageName_ends_with?: Maybe<String>;
  ImageName_not_ends_with?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  CreatedDate?: Maybe<DateTimeInput>;
  CreatedDate_not?: Maybe<DateTimeInput>;
  CreatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_lt?: Maybe<DateTimeInput>;
  CreatedDate_lte?: Maybe<DateTimeInput>;
  CreatedDate_gt?: Maybe<DateTimeInput>;
  CreatedDate_gte?: Maybe<DateTimeInput>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  ModifiedDate?: Maybe<DateTimeInput>;
  ModifiedDate_not?: Maybe<DateTimeInput>;
  ModifiedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_lt?: Maybe<DateTimeInput>;
  ModifiedDate_lte?: Maybe<DateTimeInput>;
  ModifiedDate_gt?: Maybe<DateTimeInput>;
  ModifiedDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TestimonialWhereInput[] | TestimonialWhereInput>;
}

export type DatabaseUserWhereUniqueInput = AtLeastOne<{
  UserId: Maybe<ID_Input>;
}>;

export interface SubscriptionIntegrationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SubscriptionIntegrationWhereInput>;
  AND?: Maybe<
    | SubscriptionIntegrationSubscriptionWhereInput[]
    | SubscriptionIntegrationSubscriptionWhereInput
  >;
}

export interface LogWhereInput {
  LogId?: Maybe<ID_Input>;
  LogId_not?: Maybe<ID_Input>;
  LogId_in?: Maybe<ID_Input[] | ID_Input>;
  LogId_not_in?: Maybe<ID_Input[] | ID_Input>;
  LogId_lt?: Maybe<ID_Input>;
  LogId_lte?: Maybe<ID_Input>;
  LogId_gt?: Maybe<ID_Input>;
  LogId_gte?: Maybe<ID_Input>;
  LogId_contains?: Maybe<ID_Input>;
  LogId_not_contains?: Maybe<ID_Input>;
  LogId_starts_with?: Maybe<ID_Input>;
  LogId_not_starts_with?: Maybe<ID_Input>;
  LogId_ends_with?: Maybe<ID_Input>;
  LogId_not_ends_with?: Maybe<ID_Input>;
  SubcriptionHistoryId?: Maybe<SubcriptionHistoryWhereInput>;
  SubscriberProcess?: Maybe<SubscriberProcessWhereInput>;
  SubscriptionIntegrationId?: Maybe<SubscriptionIntegrationWhereInput>;
  ConnectorId?: Maybe<ConnectorWhereInput>;
  LogDate?: Maybe<DateTimeInput>;
  LogDate_not?: Maybe<DateTimeInput>;
  LogDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  LogDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  LogDate_lt?: Maybe<DateTimeInput>;
  LogDate_lte?: Maybe<DateTimeInput>;
  LogDate_gt?: Maybe<DateTimeInput>;
  LogDate_gte?: Maybe<DateTimeInput>;
  Thread?: Maybe<String>;
  Thread_not?: Maybe<String>;
  Thread_in?: Maybe<String[] | String>;
  Thread_not_in?: Maybe<String[] | String>;
  Thread_lt?: Maybe<String>;
  Thread_lte?: Maybe<String>;
  Thread_gt?: Maybe<String>;
  Thread_gte?: Maybe<String>;
  Thread_contains?: Maybe<String>;
  Thread_not_contains?: Maybe<String>;
  Thread_starts_with?: Maybe<String>;
  Thread_not_starts_with?: Maybe<String>;
  Thread_ends_with?: Maybe<String>;
  Thread_not_ends_with?: Maybe<String>;
  Level?: Maybe<String>;
  Level_not?: Maybe<String>;
  Level_in?: Maybe<String[] | String>;
  Level_not_in?: Maybe<String[] | String>;
  Level_lt?: Maybe<String>;
  Level_lte?: Maybe<String>;
  Level_gt?: Maybe<String>;
  Level_gte?: Maybe<String>;
  Level_contains?: Maybe<String>;
  Level_not_contains?: Maybe<String>;
  Level_starts_with?: Maybe<String>;
  Level_not_starts_with?: Maybe<String>;
  Level_ends_with?: Maybe<String>;
  Level_not_ends_with?: Maybe<String>;
  ProcessId?: Maybe<ProcessWhereInput>;
  Operation?: Maybe<String>;
  Operation_not?: Maybe<String>;
  Operation_in?: Maybe<String[] | String>;
  Operation_not_in?: Maybe<String[] | String>;
  Operation_lt?: Maybe<String>;
  Operation_lte?: Maybe<String>;
  Operation_gt?: Maybe<String>;
  Operation_gte?: Maybe<String>;
  Operation_contains?: Maybe<String>;
  Operation_not_contains?: Maybe<String>;
  Operation_starts_with?: Maybe<String>;
  Operation_not_starts_with?: Maybe<String>;
  Operation_ends_with?: Maybe<String>;
  Operation_not_ends_with?: Maybe<String>;
  Event?: Maybe<String>;
  Event_not?: Maybe<String>;
  Event_in?: Maybe<String[] | String>;
  Event_not_in?: Maybe<String[] | String>;
  Event_lt?: Maybe<String>;
  Event_lte?: Maybe<String>;
  Event_gt?: Maybe<String>;
  Event_gte?: Maybe<String>;
  Event_contains?: Maybe<String>;
  Event_not_contains?: Maybe<String>;
  Event_starts_with?: Maybe<String>;
  Event_not_starts_with?: Maybe<String>;
  Event_ends_with?: Maybe<String>;
  Event_not_ends_with?: Maybe<String>;
  Sourcekeyfields?: Maybe<String>;
  Sourcekeyfields_not?: Maybe<String>;
  Sourcekeyfields_in?: Maybe<String[] | String>;
  Sourcekeyfields_not_in?: Maybe<String[] | String>;
  Sourcekeyfields_lt?: Maybe<String>;
  Sourcekeyfields_lte?: Maybe<String>;
  Sourcekeyfields_gt?: Maybe<String>;
  Sourcekeyfields_gte?: Maybe<String>;
  Sourcekeyfields_contains?: Maybe<String>;
  Sourcekeyfields_not_contains?: Maybe<String>;
  Sourcekeyfields_starts_with?: Maybe<String>;
  Sourcekeyfields_not_starts_with?: Maybe<String>;
  Sourcekeyfields_ends_with?: Maybe<String>;
  Sourcekeyfields_not_ends_with?: Maybe<String>;
  Sourcekeyvalue?: Maybe<String>;
  Sourcekeyvalue_not?: Maybe<String>;
  Sourcekeyvalue_in?: Maybe<String[] | String>;
  Sourcekeyvalue_not_in?: Maybe<String[] | String>;
  Sourcekeyvalue_lt?: Maybe<String>;
  Sourcekeyvalue_lte?: Maybe<String>;
  Sourcekeyvalue_gt?: Maybe<String>;
  Sourcekeyvalue_gte?: Maybe<String>;
  Sourcekeyvalue_contains?: Maybe<String>;
  Sourcekeyvalue_not_contains?: Maybe<String>;
  Sourcekeyvalue_starts_with?: Maybe<String>;
  Sourcekeyvalue_not_starts_with?: Maybe<String>;
  Sourcekeyvalue_ends_with?: Maybe<String>;
  Sourcekeyvalue_not_ends_with?: Maybe<String>;
  Targetkeyfields?: Maybe<String>;
  Targetkeyfields_not?: Maybe<String>;
  Targetkeyfields_in?: Maybe<String[] | String>;
  Targetkeyfields_not_in?: Maybe<String[] | String>;
  Targetkeyfields_lt?: Maybe<String>;
  Targetkeyfields_lte?: Maybe<String>;
  Targetkeyfields_gt?: Maybe<String>;
  Targetkeyfields_gte?: Maybe<String>;
  Targetkeyfields_contains?: Maybe<String>;
  Targetkeyfields_not_contains?: Maybe<String>;
  Targetkeyfields_starts_with?: Maybe<String>;
  Targetkeyfields_not_starts_with?: Maybe<String>;
  Targetkeyfields_ends_with?: Maybe<String>;
  Targetkeyfields_not_ends_with?: Maybe<String>;
  Targetkeyvalue?: Maybe<String>;
  Targetkeyvalue_not?: Maybe<String>;
  Targetkeyvalue_in?: Maybe<String[] | String>;
  Targetkeyvalue_not_in?: Maybe<String[] | String>;
  Targetkeyvalue_lt?: Maybe<String>;
  Targetkeyvalue_lte?: Maybe<String>;
  Targetkeyvalue_gt?: Maybe<String>;
  Targetkeyvalue_gte?: Maybe<String>;
  Targetkeyvalue_contains?: Maybe<String>;
  Targetkeyvalue_not_contains?: Maybe<String>;
  Targetkeyvalue_starts_with?: Maybe<String>;
  Targetkeyvalue_not_starts_with?: Maybe<String>;
  Targetkeyvalue_ends_with?: Maybe<String>;
  Targetkeyvalue_not_ends_with?: Maybe<String>;
  Message?: Maybe<String>;
  Message_not?: Maybe<String>;
  Message_in?: Maybe<String[] | String>;
  Message_not_in?: Maybe<String[] | String>;
  Message_lt?: Maybe<String>;
  Message_lte?: Maybe<String>;
  Message_gt?: Maybe<String>;
  Message_gte?: Maybe<String>;
  Message_contains?: Maybe<String>;
  Message_not_contains?: Maybe<String>;
  Message_starts_with?: Maybe<String>;
  Message_not_starts_with?: Maybe<String>;
  Message_ends_with?: Maybe<String>;
  Message_not_ends_with?: Maybe<String>;
  Exceptions?: Maybe<String>;
  Exceptions_not?: Maybe<String>;
  Exceptions_in?: Maybe<String[] | String>;
  Exceptions_not_in?: Maybe<String[] | String>;
  Exceptions_lt?: Maybe<String>;
  Exceptions_lte?: Maybe<String>;
  Exceptions_gt?: Maybe<String>;
  Exceptions_gte?: Maybe<String>;
  Exceptions_contains?: Maybe<String>;
  Exceptions_not_contains?: Maybe<String>;
  Exceptions_starts_with?: Maybe<String>;
  Exceptions_not_starts_with?: Maybe<String>;
  Exceptions_ends_with?: Maybe<String>;
  Exceptions_not_ends_with?: Maybe<String>;
  TenantId?: Maybe<UserWhereInput>;
  AND?: Maybe<LogWhereInput[] | LogWhereInput>;
}

export interface UserUpdateDataInput {
  FirstName?: Maybe<String>;
  LastName?: Maybe<String>;
  UserName?: Maybe<String>;
  Address?: Maybe<String>;
  PhoneNumber?: Maybe<String>;
  PhoneCode?: Maybe<String>;
  Email?: Maybe<String>;
  TenantId?: Maybe<String>;
  CompanyName?: Maybe<String>;
  ZipCode?: Maybe<String>;
  Country?: Maybe<String>;
  State?: Maybe<String>;
  City?: Maybe<String>;
  IsAdmin?: Maybe<String>;
  Password?: Maybe<String>;
  ConfirmPassword?: Maybe<String>;
}

export interface SubscriberEntityMapUpdateInput {
  SourceEntityID?: Maybe<EntityUpdateManyInput>;
  TargetEntityID?: Maybe<EntityUpdateManyInput>;
  Status?: Maybe<Status>;
  EntityShortDesc?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface SubscriberEntityUpdateManyMutationInput {
  EntityName?: Maybe<String>;
  EntityType?: Maybe<String>;
  EntityShortDesc?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  Status?: Maybe<Status>;
}

export interface SubcriptionHistoryUpdateDataInput {
  TenantId?: Maybe<UserUpdateOneInput>;
  ConnectorId?: Maybe<ConnectorUpdateOneInput>;
  SubscriberID?: Maybe<SubscriptionIntegrationUpdateOneInput>;
  SubcriptionHistoryName?: Maybe<String>;
  PrimaryPluginID?: Maybe<PluginUpdateOneInput>;
  SecondaryPluginID?: Maybe<PluginUpdateOneInput>;
  Status?: Maybe<Status>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface ScheduleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ScheduleWhereInput>;
  AND?: Maybe<
    ScheduleSubscriptionWhereInput[] | ScheduleSubscriptionWhereInput
  >;
}

export type UserWhereUniqueInput = AtLeastOne<{
  UserId: Maybe<ID_Input>;
  UserName?: Maybe<String>;
  TenantId?: Maybe<String>;
}>;

export interface SubscriberEntityCreateInput {
  SubscriberEntityID?: Maybe<ID_Input>;
  PluginID?: Maybe<PluginCreateOneInput>;
  EntityName?: Maybe<String>;
  EntityType?: Maybe<String>;
  EntityShortDesc?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  Status?: Maybe<Status>;
}

export interface TestimonialSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TestimonialWhereInput>;
  AND?: Maybe<
    TestimonialSubscriptionWhereInput[] | TestimonialSubscriptionWhereInput
  >;
}

export type PluginCategoryWhereUniqueInput = AtLeastOne<{
  CategoryID: Maybe<ID_Input>;
}>;

export interface SubcriptionHistoryUpdateOneInput {
  create?: Maybe<SubcriptionHistoryCreateInput>;
  update?: Maybe<SubcriptionHistoryUpdateDataInput>;
  upsert?: Maybe<SubcriptionHistoryUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SubcriptionHistoryWhereUniqueInput>;
}

export interface SubcriptionHistoryUpdateInput {
  TenantId?: Maybe<UserUpdateOneInput>;
  ConnectorId?: Maybe<ConnectorUpdateOneInput>;
  SubscriberID?: Maybe<SubscriptionIntegrationUpdateOneInput>;
  SubcriptionHistoryName?: Maybe<String>;
  PrimaryPluginID?: Maybe<PluginUpdateOneInput>;
  SecondaryPluginID?: Maybe<PluginUpdateOneInput>;
  Status?: Maybe<Status>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface LogUpdateInput {
  SubcriptionHistoryId?: Maybe<SubcriptionHistoryUpdateOneInput>;
  SubscriberProcess?: Maybe<SubscriberProcessUpdateOneInput>;
  SubscriptionIntegrationId?: Maybe<SubscriptionIntegrationUpdateOneInput>;
  ConnectorId?: Maybe<ConnectorUpdateOneInput>;
  LogDate?: Maybe<DateTimeInput>;
  Thread?: Maybe<String>;
  Level?: Maybe<String>;
  ProcessId?: Maybe<ProcessUpdateOneInput>;
  Operation?: Maybe<String>;
  Event?: Maybe<String>;
  Sourcekeyfields?: Maybe<String>;
  Sourcekeyvalue?: Maybe<String>;
  Targetkeyfields?: Maybe<String>;
  Targetkeyvalue?: Maybe<String>;
  Message?: Maybe<String>;
  Exceptions?: Maybe<String>;
  TenantId?: Maybe<UserUpdateOneInput>;
}

export interface SourceTargetFieldmappingUpdateInput {
  Entity?: Maybe<EntityUpdateOneInput>;
  Connector?: Maybe<ConnectorUpdateOneInput>;
  TenantId?: Maybe<UserUpdateOneInput>;
  FieldShortDesc?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  SourceKey?: Maybe<String>;
  SourceKeyValue?: Maybe<String>;
  TargetKey?: Maybe<String>;
  TargetKeyValue?: Maybe<String>;
  OtherParam?: Maybe<String>;
}

export interface ScheduleCreateWeekDaysInput {
  set?: Maybe<Int[] | Int>;
}

export interface SourceTargetFieldmappingCreateInput {
  SourceTargetFieldmappingID?: Maybe<ID_Input>;
  Entity?: Maybe<EntityCreateOneInput>;
  Connector?: Maybe<ConnectorCreateOneInput>;
  TenantId?: Maybe<UserCreateOneInput>;
  FieldShortDesc?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  SourceKey?: Maybe<String>;
  SourceKeyValue?: Maybe<String>;
  TargetKey?: Maybe<String>;
  TargetKeyValue?: Maybe<String>;
  OtherParam?: Maybe<String>;
}

export interface SubcriptionHistorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SubcriptionHistoryWhereInput>;
  AND?: Maybe<
    | SubcriptionHistorySubscriptionWhereInput[]
    | SubcriptionHistorySubscriptionWhereInput
  >;
}

export interface SubscriberProcessUpsertWithoutScheduleInput {
  update: SubscriberProcessUpdateWithoutScheduleDataInput;
  create: SubscriberProcessCreateWithoutScheduleInput;
}

export interface ConnectorCreateInput {
  ConnectorId?: Maybe<ID_Input>;
  Status?: Maybe<Status>;
  ConnectorTitle?: Maybe<String>;
  ConnectorShortName?: Maybe<String>;
  ConnectorSEOName?: Maybe<String>;
  ConnectorShortDesc?: Maybe<String>;
  ConnectorLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  Popular?: Maybe<Boolean>;
  Recent?: Maybe<Boolean>;
  testuser?: Maybe<String>;
  PrimaryPluginId?: Maybe<PluginCreateOneInput>;
  SecondaryPluginId?: Maybe<PluginCreateOneInput>;
}

export type ProcessWhereUniqueInput = AtLeastOne<{
  ProcessId: Maybe<ID_Input>;
}>;

export interface PluginCreateOneInput {
  create?: Maybe<PluginCreateInput>;
  connect?: Maybe<PluginWhereUniqueInput>;
}

export interface SubscriberProcessUpdateOneWithoutScheduleInput {
  create?: Maybe<SubscriberProcessCreateWithoutScheduleInput>;
  update?: Maybe<SubscriberProcessUpdateWithoutScheduleDataInput>;
  upsert?: Maybe<SubscriberProcessUpsertWithoutScheduleInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SubscriberProcessWhereUniqueInput>;
}

export interface PluginCreateInput {
  PluginID?: Maybe<ID_Input>;
  PluginName?: Maybe<String>;
  PluginTitle?: Maybe<String>;
  PluginShortName?: Maybe<String>;
  PluginSEOName?: Maybe<String>;
  PluginShortDesc?: Maybe<String>;
  PluginLongDesc?: Maybe<String>;
  AssemblyName?: Maybe<String>;
  Status?: Maybe<Status>;
  pluginType?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  ImageName?: Maybe<String>;
  ConnStructure?: Maybe<ConnStrctjsonCreateManyInput>;
  DefaultStructure?: Maybe<String>;
  ConnectUrl?: Maybe<String>;
  Popular?: Maybe<Boolean>;
  Recent?: Maybe<Boolean>;
  PluginCategoryId?: Maybe<PluginCategoryCreateOneInput>;
}

export interface SubscriberProcessCreateWithoutScheduleInput {
  SubscriberProcessID?: Maybe<ID_Input>;
  ProcessId?: Maybe<ProcessCreateOneInput>;
  TenantId?: Maybe<UserCreateOneInput>;
  ConnectorId?: Maybe<ConnectorCreateOneInput>;
  Status?: Maybe<Status>;
  Stage?: Maybe<Stage>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  LastSyncDate?: Maybe<String>;
  PrimaryEntity?: Maybe<EntityCreateOneInput>;
  SecondaryEntity?: Maybe<EntityCreateOneInput>;
}

export interface ConnStrctjsonCreateManyInput {
  create?: Maybe<ConnStrctjsonCreateInput[] | ConnStrctjsonCreateInput>;
}

export interface SubscriberProcessCreateOneWithoutScheduleInput {
  create?: Maybe<SubscriberProcessCreateWithoutScheduleInput>;
  connect?: Maybe<SubscriberProcessWhereUniqueInput>;
}

export interface ConnStrctjsonCreateInput {
  Name?: Maybe<String>;
  Label?: Maybe<String>;
  Value?: Maybe<String>;
  IsRequired?: Maybe<Boolean>;
  IsEditable?: Maybe<Boolean>;
  IsViewable?: Maybe<Boolean>;
  FieldType?: Maybe<String>;
  dropdownfieldName?: Maybe<ConnStrctjsonCreatedropdownfieldNameInput>;
  LookupValues?: Maybe<ConnStrctjsonCreateLookupValuesInput>;
  SortOrder?: Maybe<Int>;
}

export interface ConnStrctjsonRestrictedWhereInput {
  Name?: Maybe<String>;
  Name_not?: Maybe<String>;
  Name_in?: Maybe<String[] | String>;
  Name_not_in?: Maybe<String[] | String>;
  Name_lt?: Maybe<String>;
  Name_lte?: Maybe<String>;
  Name_gt?: Maybe<String>;
  Name_gte?: Maybe<String>;
  Name_contains?: Maybe<String>;
  Name_not_contains?: Maybe<String>;
  Name_starts_with?: Maybe<String>;
  Name_not_starts_with?: Maybe<String>;
  Name_ends_with?: Maybe<String>;
  Name_not_ends_with?: Maybe<String>;
  Label?: Maybe<String>;
  Label_not?: Maybe<String>;
  Label_in?: Maybe<String[] | String>;
  Label_not_in?: Maybe<String[] | String>;
  Label_lt?: Maybe<String>;
  Label_lte?: Maybe<String>;
  Label_gt?: Maybe<String>;
  Label_gte?: Maybe<String>;
  Label_contains?: Maybe<String>;
  Label_not_contains?: Maybe<String>;
  Label_starts_with?: Maybe<String>;
  Label_not_starts_with?: Maybe<String>;
  Label_ends_with?: Maybe<String>;
  Label_not_ends_with?: Maybe<String>;
  Value?: Maybe<String>;
  Value_not?: Maybe<String>;
  Value_in?: Maybe<String[] | String>;
  Value_not_in?: Maybe<String[] | String>;
  Value_lt?: Maybe<String>;
  Value_lte?: Maybe<String>;
  Value_gt?: Maybe<String>;
  Value_gte?: Maybe<String>;
  Value_contains?: Maybe<String>;
  Value_not_contains?: Maybe<String>;
  Value_starts_with?: Maybe<String>;
  Value_not_starts_with?: Maybe<String>;
  Value_ends_with?: Maybe<String>;
  Value_not_ends_with?: Maybe<String>;
  IsRequired?: Maybe<Boolean>;
  IsRequired_not?: Maybe<Boolean>;
  IsEditable?: Maybe<Boolean>;
  IsEditable_not?: Maybe<Boolean>;
  IsViewable?: Maybe<Boolean>;
  IsViewable_not?: Maybe<Boolean>;
  FieldType?: Maybe<String>;
  FieldType_not?: Maybe<String>;
  FieldType_in?: Maybe<String[] | String>;
  FieldType_not_in?: Maybe<String[] | String>;
  FieldType_lt?: Maybe<String>;
  FieldType_lte?: Maybe<String>;
  FieldType_gt?: Maybe<String>;
  FieldType_gte?: Maybe<String>;
  FieldType_contains?: Maybe<String>;
  FieldType_not_contains?: Maybe<String>;
  FieldType_starts_with?: Maybe<String>;
  FieldType_not_starts_with?: Maybe<String>;
  FieldType_ends_with?: Maybe<String>;
  FieldType_not_ends_with?: Maybe<String>;
  SortOrder?: Maybe<Int>;
  SortOrder_not?: Maybe<Int>;
  SortOrder_in?: Maybe<Int[] | Int>;
  SortOrder_not_in?: Maybe<Int[] | Int>;
  SortOrder_lt?: Maybe<Int>;
  SortOrder_lte?: Maybe<Int>;
  SortOrder_gt?: Maybe<Int>;
  SortOrder_gte?: Maybe<Int>;
  AND?: Maybe<
    ConnStrctjsonRestrictedWhereInput[] | ConnStrctjsonRestrictedWhereInput
  >;
}

export interface ConnStrctjsonCreatedropdownfieldNameInput {
  set?: Maybe<String[] | String>;
}

export interface ProcessHistoryUpdateManyMutationInput {
  LastSyncDate?: Maybe<String>;
  Stage?: Maybe<Stage>;
}

export interface ConnStrctjsonCreateLookupValuesInput {
  set?: Maybe<String[] | String>;
}

export type ScheduleWhereUniqueInput = AtLeastOne<{
  ScheduleID: Maybe<ID_Input>;
}>;

export interface PluginCategoryCreateOneInput {
  create?: Maybe<PluginCategoryCreateInput>;
  connect?: Maybe<PluginCategoryWhereUniqueInput>;
}

export interface ProcessUpdateManyMutationInput {
  ProcessShortDesc?: Maybe<String>;
  ProcessLongDesc?: Maybe<String>;
  Status?: Maybe<Status>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface PluginCategoryCreateInput {
  CategoryID?: Maybe<ID_Input>;
  CategoryName: String;
  CategoryDesc?: Maybe<String>;
}

export type SourceTargetFieldmappingWhereUniqueInput = AtLeastOne<{
  SourceTargetFieldmappingID: Maybe<ID_Input>;
}>;

export interface ConnectorUpdateInput {
  Status?: Maybe<Status>;
  ConnectorTitle?: Maybe<String>;
  ConnectorShortName?: Maybe<String>;
  ConnectorSEOName?: Maybe<String>;
  ConnectorShortDesc?: Maybe<String>;
  ConnectorLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  Popular?: Maybe<Boolean>;
  Recent?: Maybe<Boolean>;
  testuser?: Maybe<String>;
  PrimaryPluginId?: Maybe<PluginUpdateOneInput>;
  SecondaryPluginId?: Maybe<PluginUpdateOneInput>;
}

export interface SourceTargetFieldmappingWhereInput {
  SourceTargetFieldmappingID?: Maybe<ID_Input>;
  SourceTargetFieldmappingID_not?: Maybe<ID_Input>;
  SourceTargetFieldmappingID_in?: Maybe<ID_Input[] | ID_Input>;
  SourceTargetFieldmappingID_not_in?: Maybe<ID_Input[] | ID_Input>;
  SourceTargetFieldmappingID_lt?: Maybe<ID_Input>;
  SourceTargetFieldmappingID_lte?: Maybe<ID_Input>;
  SourceTargetFieldmappingID_gt?: Maybe<ID_Input>;
  SourceTargetFieldmappingID_gte?: Maybe<ID_Input>;
  SourceTargetFieldmappingID_contains?: Maybe<ID_Input>;
  SourceTargetFieldmappingID_not_contains?: Maybe<ID_Input>;
  SourceTargetFieldmappingID_starts_with?: Maybe<ID_Input>;
  SourceTargetFieldmappingID_not_starts_with?: Maybe<ID_Input>;
  SourceTargetFieldmappingID_ends_with?: Maybe<ID_Input>;
  SourceTargetFieldmappingID_not_ends_with?: Maybe<ID_Input>;
  Entity?: Maybe<EntityWhereInput>;
  Connector?: Maybe<ConnectorWhereInput>;
  TenantId?: Maybe<UserWhereInput>;
  FieldShortDesc?: Maybe<String>;
  FieldShortDesc_not?: Maybe<String>;
  FieldShortDesc_in?: Maybe<String[] | String>;
  FieldShortDesc_not_in?: Maybe<String[] | String>;
  FieldShortDesc_lt?: Maybe<String>;
  FieldShortDesc_lte?: Maybe<String>;
  FieldShortDesc_gt?: Maybe<String>;
  FieldShortDesc_gte?: Maybe<String>;
  FieldShortDesc_contains?: Maybe<String>;
  FieldShortDesc_not_contains?: Maybe<String>;
  FieldShortDesc_starts_with?: Maybe<String>;
  FieldShortDesc_not_starts_with?: Maybe<String>;
  FieldShortDesc_ends_with?: Maybe<String>;
  FieldShortDesc_not_ends_with?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  FieldLongDesc_not?: Maybe<String>;
  FieldLongDesc_in?: Maybe<String[] | String>;
  FieldLongDesc_not_in?: Maybe<String[] | String>;
  FieldLongDesc_lt?: Maybe<String>;
  FieldLongDesc_lte?: Maybe<String>;
  FieldLongDesc_gt?: Maybe<String>;
  FieldLongDesc_gte?: Maybe<String>;
  FieldLongDesc_contains?: Maybe<String>;
  FieldLongDesc_not_contains?: Maybe<String>;
  FieldLongDesc_starts_with?: Maybe<String>;
  FieldLongDesc_not_starts_with?: Maybe<String>;
  FieldLongDesc_ends_with?: Maybe<String>;
  FieldLongDesc_not_ends_with?: Maybe<String>;
  SourceKey?: Maybe<String>;
  SourceKey_not?: Maybe<String>;
  SourceKey_in?: Maybe<String[] | String>;
  SourceKey_not_in?: Maybe<String[] | String>;
  SourceKey_lt?: Maybe<String>;
  SourceKey_lte?: Maybe<String>;
  SourceKey_gt?: Maybe<String>;
  SourceKey_gte?: Maybe<String>;
  SourceKey_contains?: Maybe<String>;
  SourceKey_not_contains?: Maybe<String>;
  SourceKey_starts_with?: Maybe<String>;
  SourceKey_not_starts_with?: Maybe<String>;
  SourceKey_ends_with?: Maybe<String>;
  SourceKey_not_ends_with?: Maybe<String>;
  SourceKeyValue?: Maybe<String>;
  SourceKeyValue_not?: Maybe<String>;
  SourceKeyValue_in?: Maybe<String[] | String>;
  SourceKeyValue_not_in?: Maybe<String[] | String>;
  SourceKeyValue_lt?: Maybe<String>;
  SourceKeyValue_lte?: Maybe<String>;
  SourceKeyValue_gt?: Maybe<String>;
  SourceKeyValue_gte?: Maybe<String>;
  SourceKeyValue_contains?: Maybe<String>;
  SourceKeyValue_not_contains?: Maybe<String>;
  SourceKeyValue_starts_with?: Maybe<String>;
  SourceKeyValue_not_starts_with?: Maybe<String>;
  SourceKeyValue_ends_with?: Maybe<String>;
  SourceKeyValue_not_ends_with?: Maybe<String>;
  TargetKey?: Maybe<String>;
  TargetKey_not?: Maybe<String>;
  TargetKey_in?: Maybe<String[] | String>;
  TargetKey_not_in?: Maybe<String[] | String>;
  TargetKey_lt?: Maybe<String>;
  TargetKey_lte?: Maybe<String>;
  TargetKey_gt?: Maybe<String>;
  TargetKey_gte?: Maybe<String>;
  TargetKey_contains?: Maybe<String>;
  TargetKey_not_contains?: Maybe<String>;
  TargetKey_starts_with?: Maybe<String>;
  TargetKey_not_starts_with?: Maybe<String>;
  TargetKey_ends_with?: Maybe<String>;
  TargetKey_not_ends_with?: Maybe<String>;
  TargetKeyValue?: Maybe<String>;
  TargetKeyValue_not?: Maybe<String>;
  TargetKeyValue_in?: Maybe<String[] | String>;
  TargetKeyValue_not_in?: Maybe<String[] | String>;
  TargetKeyValue_lt?: Maybe<String>;
  TargetKeyValue_lte?: Maybe<String>;
  TargetKeyValue_gt?: Maybe<String>;
  TargetKeyValue_gte?: Maybe<String>;
  TargetKeyValue_contains?: Maybe<String>;
  TargetKeyValue_not_contains?: Maybe<String>;
  TargetKeyValue_starts_with?: Maybe<String>;
  TargetKeyValue_not_starts_with?: Maybe<String>;
  TargetKeyValue_ends_with?: Maybe<String>;
  TargetKeyValue_not_ends_with?: Maybe<String>;
  OtherParam?: Maybe<String>;
  OtherParam_not?: Maybe<String>;
  OtherParam_in?: Maybe<String[] | String>;
  OtherParam_not_in?: Maybe<String[] | String>;
  OtherParam_lt?: Maybe<String>;
  OtherParam_lte?: Maybe<String>;
  OtherParam_gt?: Maybe<String>;
  OtherParam_gte?: Maybe<String>;
  OtherParam_contains?: Maybe<String>;
  OtherParam_not_contains?: Maybe<String>;
  OtherParam_starts_with?: Maybe<String>;
  OtherParam_not_starts_with?: Maybe<String>;
  OtherParam_ends_with?: Maybe<String>;
  OtherParam_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    SourceTargetFieldmappingWhereInput[] | SourceTargetFieldmappingWhereInput
  >;
}

export interface PluginUpdateOneInput {
  create?: Maybe<PluginCreateInput>;
  update?: Maybe<PluginUpdateDataInput>;
  upsert?: Maybe<PluginUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PluginWhereUniqueInput>;
}

export interface PluginParamUpdateInput {
  FieldType?: Maybe<String>;
  FieldName?: Maybe<String>;
  Caption?: Maybe<String>;
  PluginID?: Maybe<PluginUpdateOneInput>;
  Status?: Maybe<Status>;
  Required?: Maybe<Boolean>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface PluginUpdateDataInput {
  PluginName?: Maybe<String>;
  PluginTitle?: Maybe<String>;
  PluginShortName?: Maybe<String>;
  PluginSEOName?: Maybe<String>;
  PluginShortDesc?: Maybe<String>;
  PluginLongDesc?: Maybe<String>;
  AssemblyName?: Maybe<String>;
  Status?: Maybe<Status>;
  pluginType?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  ImageName?: Maybe<String>;
  ConnStructure?: Maybe<ConnStrctjsonUpdateManyInput>;
  DefaultStructure?: Maybe<String>;
  ConnectUrl?: Maybe<String>;
  Popular?: Maybe<Boolean>;
  Recent?: Maybe<Boolean>;
  PluginCategoryId?: Maybe<PluginCategoryUpdateOneInput>;
}

export interface PluginCategoryUpdateManyMutationInput {
  CategoryName?: Maybe<String>;
  CategoryDesc?: Maybe<String>;
}

export interface ConnStrctjsonUpdateManyInput {
  create?: Maybe<ConnStrctjsonCreateInput[] | ConnStrctjsonCreateInput>;
  deleteMany?: Maybe<
    ConnStrctjsonScalarWhereInput[] | ConnStrctjsonScalarWhereInput
  >;
  updateMany?: Maybe<
    | ConnStrctjsonUpdateManyWithWhereNestedInput[]
    | ConnStrctjsonUpdateManyWithWhereNestedInput
  >;
}

export interface PluginWhereInput {
  PluginID?: Maybe<ID_Input>;
  PluginID_not?: Maybe<ID_Input>;
  PluginID_in?: Maybe<ID_Input[] | ID_Input>;
  PluginID_not_in?: Maybe<ID_Input[] | ID_Input>;
  PluginID_lt?: Maybe<ID_Input>;
  PluginID_lte?: Maybe<ID_Input>;
  PluginID_gt?: Maybe<ID_Input>;
  PluginID_gte?: Maybe<ID_Input>;
  PluginID_contains?: Maybe<ID_Input>;
  PluginID_not_contains?: Maybe<ID_Input>;
  PluginID_starts_with?: Maybe<ID_Input>;
  PluginID_not_starts_with?: Maybe<ID_Input>;
  PluginID_ends_with?: Maybe<ID_Input>;
  PluginID_not_ends_with?: Maybe<ID_Input>;
  PluginName?: Maybe<String>;
  PluginName_not?: Maybe<String>;
  PluginName_in?: Maybe<String[] | String>;
  PluginName_not_in?: Maybe<String[] | String>;
  PluginName_lt?: Maybe<String>;
  PluginName_lte?: Maybe<String>;
  PluginName_gt?: Maybe<String>;
  PluginName_gte?: Maybe<String>;
  PluginName_contains?: Maybe<String>;
  PluginName_not_contains?: Maybe<String>;
  PluginName_starts_with?: Maybe<String>;
  PluginName_not_starts_with?: Maybe<String>;
  PluginName_ends_with?: Maybe<String>;
  PluginName_not_ends_with?: Maybe<String>;
  PluginTitle?: Maybe<String>;
  PluginTitle_not?: Maybe<String>;
  PluginTitle_in?: Maybe<String[] | String>;
  PluginTitle_not_in?: Maybe<String[] | String>;
  PluginTitle_lt?: Maybe<String>;
  PluginTitle_lte?: Maybe<String>;
  PluginTitle_gt?: Maybe<String>;
  PluginTitle_gte?: Maybe<String>;
  PluginTitle_contains?: Maybe<String>;
  PluginTitle_not_contains?: Maybe<String>;
  PluginTitle_starts_with?: Maybe<String>;
  PluginTitle_not_starts_with?: Maybe<String>;
  PluginTitle_ends_with?: Maybe<String>;
  PluginTitle_not_ends_with?: Maybe<String>;
  PluginShortName?: Maybe<String>;
  PluginShortName_not?: Maybe<String>;
  PluginShortName_in?: Maybe<String[] | String>;
  PluginShortName_not_in?: Maybe<String[] | String>;
  PluginShortName_lt?: Maybe<String>;
  PluginShortName_lte?: Maybe<String>;
  PluginShortName_gt?: Maybe<String>;
  PluginShortName_gte?: Maybe<String>;
  PluginShortName_contains?: Maybe<String>;
  PluginShortName_not_contains?: Maybe<String>;
  PluginShortName_starts_with?: Maybe<String>;
  PluginShortName_not_starts_with?: Maybe<String>;
  PluginShortName_ends_with?: Maybe<String>;
  PluginShortName_not_ends_with?: Maybe<String>;
  PluginSEOName?: Maybe<String>;
  PluginSEOName_not?: Maybe<String>;
  PluginSEOName_in?: Maybe<String[] | String>;
  PluginSEOName_not_in?: Maybe<String[] | String>;
  PluginSEOName_lt?: Maybe<String>;
  PluginSEOName_lte?: Maybe<String>;
  PluginSEOName_gt?: Maybe<String>;
  PluginSEOName_gte?: Maybe<String>;
  PluginSEOName_contains?: Maybe<String>;
  PluginSEOName_not_contains?: Maybe<String>;
  PluginSEOName_starts_with?: Maybe<String>;
  PluginSEOName_not_starts_with?: Maybe<String>;
  PluginSEOName_ends_with?: Maybe<String>;
  PluginSEOName_not_ends_with?: Maybe<String>;
  PluginShortDesc?: Maybe<String>;
  PluginShortDesc_not?: Maybe<String>;
  PluginShortDesc_in?: Maybe<String[] | String>;
  PluginShortDesc_not_in?: Maybe<String[] | String>;
  PluginShortDesc_lt?: Maybe<String>;
  PluginShortDesc_lte?: Maybe<String>;
  PluginShortDesc_gt?: Maybe<String>;
  PluginShortDesc_gte?: Maybe<String>;
  PluginShortDesc_contains?: Maybe<String>;
  PluginShortDesc_not_contains?: Maybe<String>;
  PluginShortDesc_starts_with?: Maybe<String>;
  PluginShortDesc_not_starts_with?: Maybe<String>;
  PluginShortDesc_ends_with?: Maybe<String>;
  PluginShortDesc_not_ends_with?: Maybe<String>;
  PluginLongDesc?: Maybe<String>;
  PluginLongDesc_not?: Maybe<String>;
  PluginLongDesc_in?: Maybe<String[] | String>;
  PluginLongDesc_not_in?: Maybe<String[] | String>;
  PluginLongDesc_lt?: Maybe<String>;
  PluginLongDesc_lte?: Maybe<String>;
  PluginLongDesc_gt?: Maybe<String>;
  PluginLongDesc_gte?: Maybe<String>;
  PluginLongDesc_contains?: Maybe<String>;
  PluginLongDesc_not_contains?: Maybe<String>;
  PluginLongDesc_starts_with?: Maybe<String>;
  PluginLongDesc_not_starts_with?: Maybe<String>;
  PluginLongDesc_ends_with?: Maybe<String>;
  PluginLongDesc_not_ends_with?: Maybe<String>;
  AssemblyName?: Maybe<String>;
  AssemblyName_not?: Maybe<String>;
  AssemblyName_in?: Maybe<String[] | String>;
  AssemblyName_not_in?: Maybe<String[] | String>;
  AssemblyName_lt?: Maybe<String>;
  AssemblyName_lte?: Maybe<String>;
  AssemblyName_gt?: Maybe<String>;
  AssemblyName_gte?: Maybe<String>;
  AssemblyName_contains?: Maybe<String>;
  AssemblyName_not_contains?: Maybe<String>;
  AssemblyName_starts_with?: Maybe<String>;
  AssemblyName_not_starts_with?: Maybe<String>;
  AssemblyName_ends_with?: Maybe<String>;
  AssemblyName_not_ends_with?: Maybe<String>;
  Status?: Maybe<Status>;
  Status_not?: Maybe<Status>;
  Status_in?: Maybe<Status[] | Status>;
  Status_not_in?: Maybe<Status[] | Status>;
  pluginType?: Maybe<String>;
  pluginType_not?: Maybe<String>;
  pluginType_in?: Maybe<String[] | String>;
  pluginType_not_in?: Maybe<String[] | String>;
  pluginType_lt?: Maybe<String>;
  pluginType_lte?: Maybe<String>;
  pluginType_gt?: Maybe<String>;
  pluginType_gte?: Maybe<String>;
  pluginType_contains?: Maybe<String>;
  pluginType_not_contains?: Maybe<String>;
  pluginType_starts_with?: Maybe<String>;
  pluginType_not_starts_with?: Maybe<String>;
  pluginType_ends_with?: Maybe<String>;
  pluginType_not_ends_with?: Maybe<String>;
  CreatedDate?: Maybe<DateTimeInput>;
  CreatedDate_not?: Maybe<DateTimeInput>;
  CreatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_lt?: Maybe<DateTimeInput>;
  CreatedDate_lte?: Maybe<DateTimeInput>;
  CreatedDate_gt?: Maybe<DateTimeInput>;
  CreatedDate_gte?: Maybe<DateTimeInput>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  ModifiedDate?: Maybe<DateTimeInput>;
  ModifiedDate_not?: Maybe<DateTimeInput>;
  ModifiedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_lt?: Maybe<DateTimeInput>;
  ModifiedDate_lte?: Maybe<DateTimeInput>;
  ModifiedDate_gt?: Maybe<DateTimeInput>;
  ModifiedDate_gte?: Maybe<DateTimeInput>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  ImageName?: Maybe<String>;
  ImageName_not?: Maybe<String>;
  ImageName_in?: Maybe<String[] | String>;
  ImageName_not_in?: Maybe<String[] | String>;
  ImageName_lt?: Maybe<String>;
  ImageName_lte?: Maybe<String>;
  ImageName_gt?: Maybe<String>;
  ImageName_gte?: Maybe<String>;
  ImageName_contains?: Maybe<String>;
  ImageName_not_contains?: Maybe<String>;
  ImageName_starts_with?: Maybe<String>;
  ImageName_not_starts_with?: Maybe<String>;
  ImageName_ends_with?: Maybe<String>;
  ImageName_not_ends_with?: Maybe<String>;
  ConnStructure_some?: Maybe<ConnStrctjsonWhereInput>;
  ConnStructure_every?: Maybe<ConnStrctjsonRestrictedWhereInput>;
  ConnStructure_none?: Maybe<ConnStrctjsonRestrictedWhereInput>;
  DefaultStructure?: Maybe<String>;
  DefaultStructure_not?: Maybe<String>;
  DefaultStructure_in?: Maybe<String[] | String>;
  DefaultStructure_not_in?: Maybe<String[] | String>;
  DefaultStructure_lt?: Maybe<String>;
  DefaultStructure_lte?: Maybe<String>;
  DefaultStructure_gt?: Maybe<String>;
  DefaultStructure_gte?: Maybe<String>;
  DefaultStructure_contains?: Maybe<String>;
  DefaultStructure_not_contains?: Maybe<String>;
  DefaultStructure_starts_with?: Maybe<String>;
  DefaultStructure_not_starts_with?: Maybe<String>;
  DefaultStructure_ends_with?: Maybe<String>;
  DefaultStructure_not_ends_with?: Maybe<String>;
  ConnectUrl?: Maybe<String>;
  ConnectUrl_not?: Maybe<String>;
  ConnectUrl_in?: Maybe<String[] | String>;
  ConnectUrl_not_in?: Maybe<String[] | String>;
  ConnectUrl_lt?: Maybe<String>;
  ConnectUrl_lte?: Maybe<String>;
  ConnectUrl_gt?: Maybe<String>;
  ConnectUrl_gte?: Maybe<String>;
  ConnectUrl_contains?: Maybe<String>;
  ConnectUrl_not_contains?: Maybe<String>;
  ConnectUrl_starts_with?: Maybe<String>;
  ConnectUrl_not_starts_with?: Maybe<String>;
  ConnectUrl_ends_with?: Maybe<String>;
  ConnectUrl_not_ends_with?: Maybe<String>;
  Popular?: Maybe<Boolean>;
  Popular_not?: Maybe<Boolean>;
  Recent?: Maybe<Boolean>;
  Recent_not?: Maybe<Boolean>;
  PluginCategoryId?: Maybe<PluginCategoryWhereInput>;
  AND?: Maybe<PluginWhereInput[] | PluginWhereInput>;
}

export interface ConnStrctjsonScalarWhereInput {
  Name?: Maybe<String>;
  Name_not?: Maybe<String>;
  Name_in?: Maybe<String[] | String>;
  Name_not_in?: Maybe<String[] | String>;
  Name_lt?: Maybe<String>;
  Name_lte?: Maybe<String>;
  Name_gt?: Maybe<String>;
  Name_gte?: Maybe<String>;
  Name_contains?: Maybe<String>;
  Name_not_contains?: Maybe<String>;
  Name_starts_with?: Maybe<String>;
  Name_not_starts_with?: Maybe<String>;
  Name_ends_with?: Maybe<String>;
  Name_not_ends_with?: Maybe<String>;
  Label?: Maybe<String>;
  Label_not?: Maybe<String>;
  Label_in?: Maybe<String[] | String>;
  Label_not_in?: Maybe<String[] | String>;
  Label_lt?: Maybe<String>;
  Label_lte?: Maybe<String>;
  Label_gt?: Maybe<String>;
  Label_gte?: Maybe<String>;
  Label_contains?: Maybe<String>;
  Label_not_contains?: Maybe<String>;
  Label_starts_with?: Maybe<String>;
  Label_not_starts_with?: Maybe<String>;
  Label_ends_with?: Maybe<String>;
  Label_not_ends_with?: Maybe<String>;
  Value?: Maybe<String>;
  Value_not?: Maybe<String>;
  Value_in?: Maybe<String[] | String>;
  Value_not_in?: Maybe<String[] | String>;
  Value_lt?: Maybe<String>;
  Value_lte?: Maybe<String>;
  Value_gt?: Maybe<String>;
  Value_gte?: Maybe<String>;
  Value_contains?: Maybe<String>;
  Value_not_contains?: Maybe<String>;
  Value_starts_with?: Maybe<String>;
  Value_not_starts_with?: Maybe<String>;
  Value_ends_with?: Maybe<String>;
  Value_not_ends_with?: Maybe<String>;
  IsRequired?: Maybe<Boolean>;
  IsRequired_not?: Maybe<Boolean>;
  IsEditable?: Maybe<Boolean>;
  IsEditable_not?: Maybe<Boolean>;
  IsViewable?: Maybe<Boolean>;
  IsViewable_not?: Maybe<Boolean>;
  FieldType?: Maybe<String>;
  FieldType_not?: Maybe<String>;
  FieldType_in?: Maybe<String[] | String>;
  FieldType_not_in?: Maybe<String[] | String>;
  FieldType_lt?: Maybe<String>;
  FieldType_lte?: Maybe<String>;
  FieldType_gt?: Maybe<String>;
  FieldType_gte?: Maybe<String>;
  FieldType_contains?: Maybe<String>;
  FieldType_not_contains?: Maybe<String>;
  FieldType_starts_with?: Maybe<String>;
  FieldType_not_starts_with?: Maybe<String>;
  FieldType_ends_with?: Maybe<String>;
  FieldType_not_ends_with?: Maybe<String>;
  SortOrder?: Maybe<Int>;
  SortOrder_not?: Maybe<Int>;
  SortOrder_in?: Maybe<Int[] | Int>;
  SortOrder_not_in?: Maybe<Int[] | Int>;
  SortOrder_lt?: Maybe<Int>;
  SortOrder_lte?: Maybe<Int>;
  SortOrder_gt?: Maybe<Int>;
  SortOrder_gte?: Maybe<Int>;
  AND?: Maybe<ConnStrctjsonScalarWhereInput[] | ConnStrctjsonScalarWhereInput>;
  OR?: Maybe<ConnStrctjsonScalarWhereInput[] | ConnStrctjsonScalarWhereInput>;
  NOT?: Maybe<ConnStrctjsonScalarWhereInput[] | ConnStrctjsonScalarWhereInput>;
}

export interface PluginUpdateManyMutationInput {
  PluginName?: Maybe<String>;
  PluginTitle?: Maybe<String>;
  PluginShortName?: Maybe<String>;
  PluginSEOName?: Maybe<String>;
  PluginShortDesc?: Maybe<String>;
  PluginLongDesc?: Maybe<String>;
  AssemblyName?: Maybe<String>;
  Status?: Maybe<Status>;
  pluginType?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  ImageName?: Maybe<String>;
  DefaultStructure?: Maybe<String>;
  ConnectUrl?: Maybe<String>;
  Popular?: Maybe<Boolean>;
  Recent?: Maybe<Boolean>;
}

export interface ConnStrctjsonUpdateManyWithWhereNestedInput {
  where: ConnStrctjsonScalarWhereInput;
  data: ConnStrctjsonUpdateManyDataInput;
}

export type SubscriberEntityWhereUniqueInput = AtLeastOne<{
  SubscriberEntityID: Maybe<ID_Input>;
}>;

export interface ConnStrctjsonUpdateManyDataInput {
  Name?: Maybe<String>;
  Label?: Maybe<String>;
  Value?: Maybe<String>;
  IsRequired?: Maybe<Boolean>;
  IsEditable?: Maybe<Boolean>;
  IsViewable?: Maybe<Boolean>;
  FieldType?: Maybe<String>;
  dropdownfieldName?: Maybe<ConnStrctjsonUpdatedropdownfieldNameInput>;
  LookupValues?: Maybe<ConnStrctjsonUpdateLookupValuesInput>;
  SortOrder?: Maybe<Int>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface ConnStrctjsonUpdatedropdownfieldNameInput {
  set?: Maybe<String[] | String>;
}

export interface SubscriberProcessUpsertNestedInput {
  update: SubscriberProcessUpdateDataInput;
  create: SubscriberProcessCreateInput;
}

export interface ConnStrctjsonUpdateLookupValuesInput {
  set?: Maybe<String[] | String>;
}

export interface ScheduleUpdateManyWithWhereNestedInput {
  where: ScheduleScalarWhereInput;
  data: ScheduleUpdateManyDataInput;
}

export interface PluginCategoryUpdateOneInput {
  create?: Maybe<PluginCategoryCreateInput>;
  update?: Maybe<PluginCategoryUpdateDataInput>;
  upsert?: Maybe<PluginCategoryUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PluginCategoryWhereUniqueInput>;
}

export interface ScheduleScalarWhereInput {
  ScheduleID?: Maybe<ID_Input>;
  ScheduleID_not?: Maybe<ID_Input>;
  ScheduleID_in?: Maybe<ID_Input[] | ID_Input>;
  ScheduleID_not_in?: Maybe<ID_Input[] | ID_Input>;
  ScheduleID_lt?: Maybe<ID_Input>;
  ScheduleID_lte?: Maybe<ID_Input>;
  ScheduleID_gt?: Maybe<ID_Input>;
  ScheduleID_gte?: Maybe<ID_Input>;
  ScheduleID_contains?: Maybe<ID_Input>;
  ScheduleID_not_contains?: Maybe<ID_Input>;
  ScheduleID_starts_with?: Maybe<ID_Input>;
  ScheduleID_not_starts_with?: Maybe<ID_Input>;
  ScheduleID_ends_with?: Maybe<ID_Input>;
  ScheduleID_not_ends_with?: Maybe<ID_Input>;
  Field?: Maybe<String>;
  Field_not?: Maybe<String>;
  Field_in?: Maybe<String[] | String>;
  Field_not_in?: Maybe<String[] | String>;
  Field_lt?: Maybe<String>;
  Field_lte?: Maybe<String>;
  Field_gt?: Maybe<String>;
  Field_gte?: Maybe<String>;
  Field_contains?: Maybe<String>;
  Field_not_contains?: Maybe<String>;
  Field_starts_with?: Maybe<String>;
  Field_not_starts_with?: Maybe<String>;
  Field_ends_with?: Maybe<String>;
  Field_not_ends_with?: Maybe<String>;
  Status?: Maybe<Stage>;
  Status_not?: Maybe<Stage>;
  Status_in?: Maybe<Stage[] | Stage>;
  Status_not_in?: Maybe<Stage[] | Stage>;
  DailyOccurence?: Maybe<String>;
  DailyOccurence_not?: Maybe<String>;
  DailyOccurence_in?: Maybe<String[] | String>;
  DailyOccurence_not_in?: Maybe<String[] | String>;
  DailyOccurence_lt?: Maybe<String>;
  DailyOccurence_lte?: Maybe<String>;
  DailyOccurence_gt?: Maybe<String>;
  DailyOccurence_gte?: Maybe<String>;
  DailyOccurence_contains?: Maybe<String>;
  DailyOccurence_not_contains?: Maybe<String>;
  DailyOccurence_starts_with?: Maybe<String>;
  DailyOccurence_not_starts_with?: Maybe<String>;
  DailyOccurence_ends_with?: Maybe<String>;
  DailyOccurence_not_ends_with?: Maybe<String>;
  ScheduleType?: Maybe<String>;
  ScheduleType_not?: Maybe<String>;
  ScheduleType_in?: Maybe<String[] | String>;
  ScheduleType_not_in?: Maybe<String[] | String>;
  ScheduleType_lt?: Maybe<String>;
  ScheduleType_lte?: Maybe<String>;
  ScheduleType_gt?: Maybe<String>;
  ScheduleType_gte?: Maybe<String>;
  ScheduleType_contains?: Maybe<String>;
  ScheduleType_not_contains?: Maybe<String>;
  ScheduleType_starts_with?: Maybe<String>;
  ScheduleType_not_starts_with?: Maybe<String>;
  ScheduleType_ends_with?: Maybe<String>;
  ScheduleType_not_ends_with?: Maybe<String>;
  DailyRecurrenceType?: Maybe<String>;
  DailyRecurrenceType_not?: Maybe<String>;
  DailyRecurrenceType_in?: Maybe<String[] | String>;
  DailyRecurrenceType_not_in?: Maybe<String[] | String>;
  DailyRecurrenceType_lt?: Maybe<String>;
  DailyRecurrenceType_lte?: Maybe<String>;
  DailyRecurrenceType_gt?: Maybe<String>;
  DailyRecurrenceType_gte?: Maybe<String>;
  DailyRecurrenceType_contains?: Maybe<String>;
  DailyRecurrenceType_not_contains?: Maybe<String>;
  DailyRecurrenceType_starts_with?: Maybe<String>;
  DailyRecurrenceType_not_starts_with?: Maybe<String>;
  DailyRecurrenceType_ends_with?: Maybe<String>;
  DailyRecurrenceType_not_ends_with?: Maybe<String>;
  OccursAt?: Maybe<String>;
  OccursAt_not?: Maybe<String>;
  OccursAt_in?: Maybe<String[] | String>;
  OccursAt_not_in?: Maybe<String[] | String>;
  OccursAt_lt?: Maybe<String>;
  OccursAt_lte?: Maybe<String>;
  OccursAt_gt?: Maybe<String>;
  OccursAt_gte?: Maybe<String>;
  OccursAt_contains?: Maybe<String>;
  OccursAt_not_contains?: Maybe<String>;
  OccursAt_starts_with?: Maybe<String>;
  OccursAt_not_starts_with?: Maybe<String>;
  OccursAt_ends_with?: Maybe<String>;
  OccursAt_not_ends_with?: Maybe<String>;
  DailyInterval?: Maybe<String>;
  DailyInterval_not?: Maybe<String>;
  DailyInterval_in?: Maybe<String[] | String>;
  DailyInterval_not_in?: Maybe<String[] | String>;
  DailyInterval_lt?: Maybe<String>;
  DailyInterval_lte?: Maybe<String>;
  DailyInterval_gt?: Maybe<String>;
  DailyInterval_gte?: Maybe<String>;
  DailyInterval_contains?: Maybe<String>;
  DailyInterval_not_contains?: Maybe<String>;
  DailyInterval_starts_with?: Maybe<String>;
  DailyInterval_not_starts_with?: Maybe<String>;
  DailyInterval_ends_with?: Maybe<String>;
  DailyInterval_not_ends_with?: Maybe<String>;
  DailyIntervalSpan?: Maybe<String>;
  DailyIntervalSpan_not?: Maybe<String>;
  DailyIntervalSpan_in?: Maybe<String[] | String>;
  DailyIntervalSpan_not_in?: Maybe<String[] | String>;
  DailyIntervalSpan_lt?: Maybe<String>;
  DailyIntervalSpan_lte?: Maybe<String>;
  DailyIntervalSpan_gt?: Maybe<String>;
  DailyIntervalSpan_gte?: Maybe<String>;
  DailyIntervalSpan_contains?: Maybe<String>;
  DailyIntervalSpan_not_contains?: Maybe<String>;
  DailyIntervalSpan_starts_with?: Maybe<String>;
  DailyIntervalSpan_not_starts_with?: Maybe<String>;
  DailyIntervalSpan_ends_with?: Maybe<String>;
  DailyIntervalSpan_not_ends_with?: Maybe<String>;
  DayofMonth?: Maybe<String>;
  DayofMonth_not?: Maybe<String>;
  DayofMonth_in?: Maybe<String[] | String>;
  DayofMonth_not_in?: Maybe<String[] | String>;
  DayofMonth_lt?: Maybe<String>;
  DayofMonth_lte?: Maybe<String>;
  DayofMonth_gt?: Maybe<String>;
  DayofMonth_gte?: Maybe<String>;
  DayofMonth_contains?: Maybe<String>;
  DayofMonth_not_contains?: Maybe<String>;
  DayofMonth_starts_with?: Maybe<String>;
  DayofMonth_not_starts_with?: Maybe<String>;
  DayofMonth_ends_with?: Maybe<String>;
  DayofMonth_not_ends_with?: Maybe<String>;
  LastExecuted?: Maybe<String>;
  LastExecuted_not?: Maybe<String>;
  LastExecuted_in?: Maybe<String[] | String>;
  LastExecuted_not_in?: Maybe<String[] | String>;
  LastExecuted_lt?: Maybe<String>;
  LastExecuted_lte?: Maybe<String>;
  LastExecuted_gt?: Maybe<String>;
  LastExecuted_gte?: Maybe<String>;
  LastExecuted_contains?: Maybe<String>;
  LastExecuted_not_contains?: Maybe<String>;
  LastExecuted_starts_with?: Maybe<String>;
  LastExecuted_not_starts_with?: Maybe<String>;
  LastExecuted_ends_with?: Maybe<String>;
  LastExecuted_not_ends_with?: Maybe<String>;
  NextOccurence?: Maybe<String>;
  NextOccurence_not?: Maybe<String>;
  NextOccurence_in?: Maybe<String[] | String>;
  NextOccurence_not_in?: Maybe<String[] | String>;
  NextOccurence_lt?: Maybe<String>;
  NextOccurence_lte?: Maybe<String>;
  NextOccurence_gt?: Maybe<String>;
  NextOccurence_gte?: Maybe<String>;
  NextOccurence_contains?: Maybe<String>;
  NextOccurence_not_contains?: Maybe<String>;
  NextOccurence_starts_with?: Maybe<String>;
  NextOccurence_not_starts_with?: Maybe<String>;
  NextOccurence_ends_with?: Maybe<String>;
  NextOccurence_not_ends_with?: Maybe<String>;
  CreatedDate?: Maybe<String>;
  CreatedDate_not?: Maybe<String>;
  CreatedDate_in?: Maybe<String[] | String>;
  CreatedDate_not_in?: Maybe<String[] | String>;
  CreatedDate_lt?: Maybe<String>;
  CreatedDate_lte?: Maybe<String>;
  CreatedDate_gt?: Maybe<String>;
  CreatedDate_gte?: Maybe<String>;
  CreatedDate_contains?: Maybe<String>;
  CreatedDate_not_contains?: Maybe<String>;
  CreatedDate_starts_with?: Maybe<String>;
  CreatedDate_not_starts_with?: Maybe<String>;
  CreatedDate_ends_with?: Maybe<String>;
  CreatedDate_not_ends_with?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  ModifiedDate?: Maybe<String>;
  ModifiedDate_not?: Maybe<String>;
  ModifiedDate_in?: Maybe<String[] | String>;
  ModifiedDate_not_in?: Maybe<String[] | String>;
  ModifiedDate_lt?: Maybe<String>;
  ModifiedDate_lte?: Maybe<String>;
  ModifiedDate_gt?: Maybe<String>;
  ModifiedDate_gte?: Maybe<String>;
  ModifiedDate_contains?: Maybe<String>;
  ModifiedDate_not_contains?: Maybe<String>;
  ModifiedDate_starts_with?: Maybe<String>;
  ModifiedDate_not_starts_with?: Maybe<String>;
  ModifiedDate_ends_with?: Maybe<String>;
  ModifiedDate_not_ends_with?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  StartTime?: Maybe<String>;
  StartTime_not?: Maybe<String>;
  StartTime_in?: Maybe<String[] | String>;
  StartTime_not_in?: Maybe<String[] | String>;
  StartTime_lt?: Maybe<String>;
  StartTime_lte?: Maybe<String>;
  StartTime_gt?: Maybe<String>;
  StartTime_gte?: Maybe<String>;
  StartTime_contains?: Maybe<String>;
  StartTime_not_contains?: Maybe<String>;
  StartTime_starts_with?: Maybe<String>;
  StartTime_not_starts_with?: Maybe<String>;
  StartTime_ends_with?: Maybe<String>;
  StartTime_not_ends_with?: Maybe<String>;
  EndTime?: Maybe<String>;
  EndTime_not?: Maybe<String>;
  EndTime_in?: Maybe<String[] | String>;
  EndTime_not_in?: Maybe<String[] | String>;
  EndTime_lt?: Maybe<String>;
  EndTime_lte?: Maybe<String>;
  EndTime_gt?: Maybe<String>;
  EndTime_gte?: Maybe<String>;
  EndTime_contains?: Maybe<String>;
  EndTime_not_contains?: Maybe<String>;
  EndTime_starts_with?: Maybe<String>;
  EndTime_not_starts_with?: Maybe<String>;
  EndTime_ends_with?: Maybe<String>;
  EndTime_not_ends_with?: Maybe<String>;
  Type?: Maybe<String>;
  Type_not?: Maybe<String>;
  Type_in?: Maybe<String[] | String>;
  Type_not_in?: Maybe<String[] | String>;
  Type_lt?: Maybe<String>;
  Type_lte?: Maybe<String>;
  Type_gt?: Maybe<String>;
  Type_gte?: Maybe<String>;
  Type_contains?: Maybe<String>;
  Type_not_contains?: Maybe<String>;
  Type_starts_with?: Maybe<String>;
  Type_not_starts_with?: Maybe<String>;
  Type_ends_with?: Maybe<String>;
  Type_not_ends_with?: Maybe<String>;
  AND?: Maybe<ScheduleScalarWhereInput[] | ScheduleScalarWhereInput>;
  OR?: Maybe<ScheduleScalarWhereInput[] | ScheduleScalarWhereInput>;
  NOT?: Maybe<ScheduleScalarWhereInput[] | ScheduleScalarWhereInput>;
}

export interface PluginCategoryUpdateDataInput {
  CategoryName?: Maybe<String>;
  CategoryDesc?: Maybe<String>;
}

export interface SubscriberEntitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SubscriberEntityWhereInput>;
  AND?: Maybe<
    | SubscriberEntitySubscriptionWhereInput[]
    | SubscriberEntitySubscriptionWhereInput
  >;
}

export interface PluginCategoryUpsertNestedInput {
  update: PluginCategoryUpdateDataInput;
  create: PluginCategoryCreateInput;
}

export interface ScheduleUpdateWeekDaysInput {
  set?: Maybe<Int[] | Int>;
}

export interface PluginUpsertNestedInput {
  update: PluginUpdateDataInput;
  create: PluginCreateInput;
}

export type SubscriberFieldWhereUniqueInput = AtLeastOne<{
  SubscriberFieldID: Maybe<ID_Input>;
}>;

export interface ConnectorUpdateManyMutationInput {
  Status?: Maybe<Status>;
  ConnectorTitle?: Maybe<String>;
  ConnectorShortName?: Maybe<String>;
  ConnectorSEOName?: Maybe<String>;
  ConnectorShortDesc?: Maybe<String>;
  ConnectorLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  Popular?: Maybe<Boolean>;
  Recent?: Maybe<Boolean>;
  testuser?: Maybe<String>;
}

export interface SubscriberFieldWhereInput {
  SubscriberFieldID?: Maybe<ID_Input>;
  SubscriberFieldID_not?: Maybe<ID_Input>;
  SubscriberFieldID_in?: Maybe<ID_Input[] | ID_Input>;
  SubscriberFieldID_not_in?: Maybe<ID_Input[] | ID_Input>;
  SubscriberFieldID_lt?: Maybe<ID_Input>;
  SubscriberFieldID_lte?: Maybe<ID_Input>;
  SubscriberFieldID_gt?: Maybe<ID_Input>;
  SubscriberFieldID_gte?: Maybe<ID_Input>;
  SubscriberFieldID_contains?: Maybe<ID_Input>;
  SubscriberFieldID_not_contains?: Maybe<ID_Input>;
  SubscriberFieldID_starts_with?: Maybe<ID_Input>;
  SubscriberFieldID_not_starts_with?: Maybe<ID_Input>;
  SubscriberFieldID_ends_with?: Maybe<ID_Input>;
  SubscriberFieldID_not_ends_with?: Maybe<ID_Input>;
  PluginsID?: Maybe<PluginWhereInput>;
  EntityID?: Maybe<EntityWhereInput>;
  FieldName?: Maybe<String>;
  FieldName_not?: Maybe<String>;
  FieldName_in?: Maybe<String[] | String>;
  FieldName_not_in?: Maybe<String[] | String>;
  FieldName_lt?: Maybe<String>;
  FieldName_lte?: Maybe<String>;
  FieldName_gt?: Maybe<String>;
  FieldName_gte?: Maybe<String>;
  FieldName_contains?: Maybe<String>;
  FieldName_not_contains?: Maybe<String>;
  FieldName_starts_with?: Maybe<String>;
  FieldName_not_starts_with?: Maybe<String>;
  FieldName_ends_with?: Maybe<String>;
  FieldName_not_ends_with?: Maybe<String>;
  DataType?: Maybe<String>;
  DataType_not?: Maybe<String>;
  DataType_in?: Maybe<String[] | String>;
  DataType_not_in?: Maybe<String[] | String>;
  DataType_lt?: Maybe<String>;
  DataType_lte?: Maybe<String>;
  DataType_gt?: Maybe<String>;
  DataType_gte?: Maybe<String>;
  DataType_contains?: Maybe<String>;
  DataType_not_contains?: Maybe<String>;
  DataType_starts_with?: Maybe<String>;
  DataType_not_starts_with?: Maybe<String>;
  DataType_ends_with?: Maybe<String>;
  DataType_not_ends_with?: Maybe<String>;
  FieldType?: Maybe<String>;
  FieldType_not?: Maybe<String>;
  FieldType_in?: Maybe<String[] | String>;
  FieldType_not_in?: Maybe<String[] | String>;
  FieldType_lt?: Maybe<String>;
  FieldType_lte?: Maybe<String>;
  FieldType_gt?: Maybe<String>;
  FieldType_gte?: Maybe<String>;
  FieldType_contains?: Maybe<String>;
  FieldType_not_contains?: Maybe<String>;
  FieldType_starts_with?: Maybe<String>;
  FieldType_not_starts_with?: Maybe<String>;
  FieldType_ends_with?: Maybe<String>;
  FieldType_not_ends_with?: Maybe<String>;
  Status?: Maybe<Status>;
  Status_not?: Maybe<Status>;
  Status_in?: Maybe<Status[] | Status>;
  Status_not_in?: Maybe<Status[] | Status>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  CreatedDate?: Maybe<DateTimeInput>;
  CreatedDate_not?: Maybe<DateTimeInput>;
  CreatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_lt?: Maybe<DateTimeInput>;
  CreatedDate_lte?: Maybe<DateTimeInput>;
  CreatedDate_gt?: Maybe<DateTimeInput>;
  CreatedDate_gte?: Maybe<DateTimeInput>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  ModifiedDate?: Maybe<DateTimeInput>;
  ModifiedDate_not?: Maybe<DateTimeInput>;
  ModifiedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_lt?: Maybe<DateTimeInput>;
  ModifiedDate_lte?: Maybe<DateTimeInput>;
  ModifiedDate_gt?: Maybe<DateTimeInput>;
  ModifiedDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SubscriberFieldWhereInput[] | SubscriberFieldWhereInput>;
}

export interface ScheduleCreateWithoutSubscriberProcessInput {
  ScheduleID?: Maybe<ID_Input>;
  TenantId?: Maybe<UserCreateOneInput>;
  ProcessId?: Maybe<ProcessCreateOneInput>;
  SubcriptionHistoryId?: Maybe<SubcriptionHistoryCreateOneInput>;
  Field?: Maybe<String>;
  Status?: Maybe<Stage>;
  DailyOccurence?: Maybe<String>;
  ScheduleType?: Maybe<String>;
  DailyRecurrenceType?: Maybe<String>;
  OccursAt?: Maybe<String>;
  DailyInterval?: Maybe<String>;
  DailyIntervalSpan?: Maybe<String>;
  WeekDays?: Maybe<ScheduleCreateWeekDaysInput>;
  DayofMonth?: Maybe<String>;
  LastExecuted?: Maybe<String>;
  NextOccurence?: Maybe<String>;
  SubscriptionIntegrationId?: Maybe<SubscriptionIntegrationCreateOneInput>;
  CreatedDate?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedDate?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  StartTime?: Maybe<String>;
  EndTime?: Maybe<String>;
  Type?: Maybe<String>;
}

export interface EntityConnStrctjsonWhereInput {
  Name?: Maybe<String>;
  Name_not?: Maybe<String>;
  Name_in?: Maybe<String[] | String>;
  Name_not_in?: Maybe<String[] | String>;
  Name_lt?: Maybe<String>;
  Name_lte?: Maybe<String>;
  Name_gt?: Maybe<String>;
  Name_gte?: Maybe<String>;
  Name_contains?: Maybe<String>;
  Name_not_contains?: Maybe<String>;
  Name_starts_with?: Maybe<String>;
  Name_not_starts_with?: Maybe<String>;
  Name_ends_with?: Maybe<String>;
  Name_not_ends_with?: Maybe<String>;
  Value?: Maybe<String>;
  Value_not?: Maybe<String>;
  Value_in?: Maybe<String[] | String>;
  Value_not_in?: Maybe<String[] | String>;
  Value_lt?: Maybe<String>;
  Value_lte?: Maybe<String>;
  Value_gt?: Maybe<String>;
  Value_gte?: Maybe<String>;
  Value_contains?: Maybe<String>;
  Value_not_contains?: Maybe<String>;
  Value_starts_with?: Maybe<String>;
  Value_not_starts_with?: Maybe<String>;
  Value_ends_with?: Maybe<String>;
  Value_not_ends_with?: Maybe<String>;
  PluginId?: Maybe<String>;
  PluginId_not?: Maybe<String>;
  PluginId_in?: Maybe<String[] | String>;
  PluginId_not_in?: Maybe<String[] | String>;
  PluginId_lt?: Maybe<String>;
  PluginId_lte?: Maybe<String>;
  PluginId_gt?: Maybe<String>;
  PluginId_gte?: Maybe<String>;
  PluginId_contains?: Maybe<String>;
  PluginId_not_contains?: Maybe<String>;
  PluginId_starts_with?: Maybe<String>;
  PluginId_not_starts_with?: Maybe<String>;
  PluginId_ends_with?: Maybe<String>;
  PluginId_not_ends_with?: Maybe<String>;
  EntityID?: Maybe<String>;
  EntityID_not?: Maybe<String>;
  EntityID_in?: Maybe<String[] | String>;
  EntityID_not_in?: Maybe<String[] | String>;
  EntityID_lt?: Maybe<String>;
  EntityID_lte?: Maybe<String>;
  EntityID_gt?: Maybe<String>;
  EntityID_gte?: Maybe<String>;
  EntityID_contains?: Maybe<String>;
  EntityID_not_contains?: Maybe<String>;
  EntityID_starts_with?: Maybe<String>;
  EntityID_not_starts_with?: Maybe<String>;
  EntityID_ends_with?: Maybe<String>;
  EntityID_not_ends_with?: Maybe<String>;
  Question?: Maybe<String>;
  Question_not?: Maybe<String>;
  Question_in?: Maybe<String[] | String>;
  Question_not_in?: Maybe<String[] | String>;
  Question_lt?: Maybe<String>;
  Question_lte?: Maybe<String>;
  Question_gt?: Maybe<String>;
  Question_gte?: Maybe<String>;
  Question_contains?: Maybe<String>;
  Question_not_contains?: Maybe<String>;
  Question_starts_with?: Maybe<String>;
  Question_not_starts_with?: Maybe<String>;
  Question_ends_with?: Maybe<String>;
  Question_not_ends_with?: Maybe<String>;
  FieldType?: Maybe<String>;
  FieldType_not?: Maybe<String>;
  FieldType_in?: Maybe<String[] | String>;
  FieldType_not_in?: Maybe<String[] | String>;
  FieldType_lt?: Maybe<String>;
  FieldType_lte?: Maybe<String>;
  FieldType_gt?: Maybe<String>;
  FieldType_gte?: Maybe<String>;
  FieldType_contains?: Maybe<String>;
  FieldType_not_contains?: Maybe<String>;
  FieldType_starts_with?: Maybe<String>;
  FieldType_not_starts_with?: Maybe<String>;
  FieldType_ends_with?: Maybe<String>;
  FieldType_not_ends_with?: Maybe<String>;
  FieldLength?: Maybe<Int>;
  FieldLength_not?: Maybe<Int>;
  FieldLength_in?: Maybe<Int[] | Int>;
  FieldLength_not_in?: Maybe<Int[] | Int>;
  FieldLength_lt?: Maybe<Int>;
  FieldLength_lte?: Maybe<Int>;
  FieldLength_gt?: Maybe<Int>;
  FieldLength_gte?: Maybe<Int>;
  IsRequired?: Maybe<Boolean>;
  IsRequired_not?: Maybe<Boolean>;
  FieldName?: Maybe<String>;
  FieldName_not?: Maybe<String>;
  FieldName_in?: Maybe<String[] | String>;
  FieldName_not_in?: Maybe<String[] | String>;
  FieldName_lt?: Maybe<String>;
  FieldName_lte?: Maybe<String>;
  FieldName_gt?: Maybe<String>;
  FieldName_gte?: Maybe<String>;
  FieldName_contains?: Maybe<String>;
  FieldName_not_contains?: Maybe<String>;
  FieldName_starts_with?: Maybe<String>;
  FieldName_not_starts_with?: Maybe<String>;
  FieldName_ends_with?: Maybe<String>;
  FieldName_not_ends_with?: Maybe<String>;
  Answers?: Maybe<String>;
  Answers_not?: Maybe<String>;
  Answers_in?: Maybe<String[] | String>;
  Answers_not_in?: Maybe<String[] | String>;
  Answers_lt?: Maybe<String>;
  Answers_lte?: Maybe<String>;
  Answers_gt?: Maybe<String>;
  Answers_gte?: Maybe<String>;
  Answers_contains?: Maybe<String>;
  Answers_not_contains?: Maybe<String>;
  Answers_starts_with?: Maybe<String>;
  Answers_not_starts_with?: Maybe<String>;
  Answers_ends_with?: Maybe<String>;
  Answers_not_ends_with?: Maybe<String>;
  IsEditable?: Maybe<Boolean>;
  IsEditable_not?: Maybe<Boolean>;
  IsViewable?: Maybe<Boolean>;
  IsViewable_not?: Maybe<Boolean>;
  AND?: Maybe<EntityConnStrctjsonWhereInput[] | EntityConnStrctjsonWhereInput>;
}

export interface ScheduleCreateManyWithoutSubscriberProcessInput {
  create?: Maybe<
    | ScheduleCreateWithoutSubscriberProcessInput[]
    | ScheduleCreateWithoutSubscriberProcessInput
  >;
  connect?: Maybe<ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput>;
}

export interface EntityMapSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EntityMapWhereInput>;
  AND?: Maybe<
    EntityMapSubscriptionWhereInput[] | EntityMapSubscriptionWhereInput
  >;
}

export interface DatabaseUserCreateInput {
  UserId?: Maybe<ID_Input>;
  Name: String;
  Password: String;
  Claims?: Maybe<DBClaims>;
  Token?: Maybe<String>;
}

export interface EntityMapWhereInput {
  EntityMapID?: Maybe<ID_Input>;
  EntityMapID_not?: Maybe<ID_Input>;
  EntityMapID_in?: Maybe<ID_Input[] | ID_Input>;
  EntityMapID_not_in?: Maybe<ID_Input[] | ID_Input>;
  EntityMapID_lt?: Maybe<ID_Input>;
  EntityMapID_lte?: Maybe<ID_Input>;
  EntityMapID_gt?: Maybe<ID_Input>;
  EntityMapID_gte?: Maybe<ID_Input>;
  EntityMapID_contains?: Maybe<ID_Input>;
  EntityMapID_not_contains?: Maybe<ID_Input>;
  EntityMapID_starts_with?: Maybe<ID_Input>;
  EntityMapID_not_starts_with?: Maybe<ID_Input>;
  EntityMapID_ends_with?: Maybe<ID_Input>;
  EntityMapID_not_ends_with?: Maybe<ID_Input>;
  SourceEntityID_some?: Maybe<EntityWhereInput>;
  TargetEntityID_some?: Maybe<EntityWhereInput>;
  Status?: Maybe<Status>;
  Status_not?: Maybe<Status>;
  Status_in?: Maybe<Status[] | Status>;
  Status_not_in?: Maybe<Status[] | Status>;
  EntityShortDesc?: Maybe<String>;
  EntityShortDesc_not?: Maybe<String>;
  EntityShortDesc_in?: Maybe<String[] | String>;
  EntityShortDesc_not_in?: Maybe<String[] | String>;
  EntityShortDesc_lt?: Maybe<String>;
  EntityShortDesc_lte?: Maybe<String>;
  EntityShortDesc_gt?: Maybe<String>;
  EntityShortDesc_gte?: Maybe<String>;
  EntityShortDesc_contains?: Maybe<String>;
  EntityShortDesc_not_contains?: Maybe<String>;
  EntityShortDesc_starts_with?: Maybe<String>;
  EntityShortDesc_not_starts_with?: Maybe<String>;
  EntityShortDesc_ends_with?: Maybe<String>;
  EntityShortDesc_not_ends_with?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  EntityLongDesc_not?: Maybe<String>;
  EntityLongDesc_in?: Maybe<String[] | String>;
  EntityLongDesc_not_in?: Maybe<String[] | String>;
  EntityLongDesc_lt?: Maybe<String>;
  EntityLongDesc_lte?: Maybe<String>;
  EntityLongDesc_gt?: Maybe<String>;
  EntityLongDesc_gte?: Maybe<String>;
  EntityLongDesc_contains?: Maybe<String>;
  EntityLongDesc_not_contains?: Maybe<String>;
  EntityLongDesc_starts_with?: Maybe<String>;
  EntityLongDesc_not_starts_with?: Maybe<String>;
  EntityLongDesc_ends_with?: Maybe<String>;
  EntityLongDesc_not_ends_with?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  CreatedDate?: Maybe<DateTimeInput>;
  CreatedDate_not?: Maybe<DateTimeInput>;
  CreatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_lt?: Maybe<DateTimeInput>;
  CreatedDate_lte?: Maybe<DateTimeInput>;
  CreatedDate_gt?: Maybe<DateTimeInput>;
  CreatedDate_gte?: Maybe<DateTimeInput>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  ModifiedDate?: Maybe<DateTimeInput>;
  ModifiedDate_not?: Maybe<DateTimeInput>;
  ModifiedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_lt?: Maybe<DateTimeInput>;
  ModifiedDate_lte?: Maybe<DateTimeInput>;
  ModifiedDate_gt?: Maybe<DateTimeInput>;
  ModifiedDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EntityMapWhereInput[] | EntityMapWhereInput>;
}

export interface DatabaseUserUpdateInput {
  Name?: Maybe<String>;
  Password?: Maybe<String>;
  Claims?: Maybe<DBClaims>;
  Token?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  FirstName?: Maybe<String>;
  LastName?: Maybe<String>;
  UserName?: Maybe<String>;
  Address?: Maybe<String>;
  PhoneNumber?: Maybe<String>;
  PhoneCode?: Maybe<String>;
  Email?: Maybe<String>;
  TenantId?: Maybe<String>;
  CompanyName?: Maybe<String>;
  ZipCode?: Maybe<String>;
  Country?: Maybe<String>;
  State?: Maybe<String>;
  City?: Maybe<String>;
  IsAdmin?: Maybe<String>;
  Password?: Maybe<String>;
  ConfirmPassword?: Maybe<String>;
}

export interface DatabaseUserUpdateManyMutationInput {
  Name?: Maybe<String>;
  Password?: Maybe<String>;
  Claims?: Maybe<DBClaims>;
  Token?: Maybe<String>;
}

export interface PluginParamSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PluginParamWhereInput>;
  AND?: Maybe<
    PluginParamSubscriptionWhereInput[] | PluginParamSubscriptionWhereInput
  >;
}

export interface EntityCreateInput {
  EntityID?: Maybe<ID_Input>;
  PluginID?: Maybe<PluginCreateOneInput>;
  EntityName?: Maybe<String>;
  EntityType?: Maybe<String>;
  EntityShortDesc?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ConnectUrl?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  Status?: Maybe<Status>;
  ConfigStructure?: Maybe<EntityConnStrctjsonCreateManyInput>;
}

export type FieldMapWhereUniqueInput = AtLeastOne<{
  FieldMapID: Maybe<ID_Input>;
}>;

export interface EntityConnStrctjsonCreateManyInput {
  create?: Maybe<
    EntityConnStrctjsonCreateInput[] | EntityConnStrctjsonCreateInput
  >;
}

export interface SubscriptionIntegrationUpdateInput {
  NoOfLicenses?: Maybe<String>;
  NoOfUsers?: Maybe<String>;
  Status?: Maybe<Status>;
  TenantId?: Maybe<UserUpdateOneInput>;
  ConnectorId?: Maybe<ConnectorUpdateOneInput>;
  SubscriptionEndDate?: Maybe<DateTimeInput>;
  PrimaryPluginConnectionData?: Maybe<ConnStrctjsonUpdateManyInput>;
  SecondaryPluginConnectionData?: Maybe<ConnStrctjsonUpdateManyInput>;
  ConfigStructure?: Maybe<EntityConnStrctjsonUpdateManyInput>;
}

export interface EntityConnStrctjsonCreateInput {
  Name?: Maybe<String>;
  Value?: Maybe<String>;
  PluginId?: Maybe<String>;
  EntityID?: Maybe<String>;
  Question?: Maybe<String>;
  FieldType?: Maybe<String>;
  LookupValues?: Maybe<EntityConnStrctjsonCreateLookupValuesInput>;
  FieldLength?: Maybe<Int>;
  IsRequired?: Maybe<Boolean>;
  FieldName?: Maybe<String>;
  Answers?: Maybe<String>;
  IsEditable?: Maybe<Boolean>;
  IsViewable?: Maybe<Boolean>;
}

export interface SubscriberFieldMapUpdateManyMutationInput {
  Status?: Maybe<Status>;
  FieldShortDesc?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface EntityConnStrctjsonCreateLookupValuesInput {
  set?: Maybe<String[] | String>;
}

export interface SubscriberFieldUpdateInput {
  PluginsID?: Maybe<PluginUpdateOneInput>;
  EntityID?: Maybe<EntityUpdateOneInput>;
  FieldName?: Maybe<String>;
  DataType?: Maybe<String>;
  FieldType?: Maybe<String>;
  Status?: Maybe<Status>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface EntityUpdateInput {
  PluginID?: Maybe<PluginUpdateOneInput>;
  EntityName?: Maybe<String>;
  EntityType?: Maybe<String>;
  EntityShortDesc?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ConnectUrl?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  Status?: Maybe<Status>;
  ConfigStructure?: Maybe<EntityConnStrctjsonUpdateManyInput>;
}

export interface UserWhereInput {
  UserId?: Maybe<ID_Input>;
  UserId_not?: Maybe<ID_Input>;
  UserId_in?: Maybe<ID_Input[] | ID_Input>;
  UserId_not_in?: Maybe<ID_Input[] | ID_Input>;
  UserId_lt?: Maybe<ID_Input>;
  UserId_lte?: Maybe<ID_Input>;
  UserId_gt?: Maybe<ID_Input>;
  UserId_gte?: Maybe<ID_Input>;
  UserId_contains?: Maybe<ID_Input>;
  UserId_not_contains?: Maybe<ID_Input>;
  UserId_starts_with?: Maybe<ID_Input>;
  UserId_not_starts_with?: Maybe<ID_Input>;
  UserId_ends_with?: Maybe<ID_Input>;
  UserId_not_ends_with?: Maybe<ID_Input>;
  FirstName?: Maybe<String>;
  FirstName_not?: Maybe<String>;
  FirstName_in?: Maybe<String[] | String>;
  FirstName_not_in?: Maybe<String[] | String>;
  FirstName_lt?: Maybe<String>;
  FirstName_lte?: Maybe<String>;
  FirstName_gt?: Maybe<String>;
  FirstName_gte?: Maybe<String>;
  FirstName_contains?: Maybe<String>;
  FirstName_not_contains?: Maybe<String>;
  FirstName_starts_with?: Maybe<String>;
  FirstName_not_starts_with?: Maybe<String>;
  FirstName_ends_with?: Maybe<String>;
  FirstName_not_ends_with?: Maybe<String>;
  LastName?: Maybe<String>;
  LastName_not?: Maybe<String>;
  LastName_in?: Maybe<String[] | String>;
  LastName_not_in?: Maybe<String[] | String>;
  LastName_lt?: Maybe<String>;
  LastName_lte?: Maybe<String>;
  LastName_gt?: Maybe<String>;
  LastName_gte?: Maybe<String>;
  LastName_contains?: Maybe<String>;
  LastName_not_contains?: Maybe<String>;
  LastName_starts_with?: Maybe<String>;
  LastName_not_starts_with?: Maybe<String>;
  LastName_ends_with?: Maybe<String>;
  LastName_not_ends_with?: Maybe<String>;
  UserName?: Maybe<String>;
  UserName_not?: Maybe<String>;
  UserName_in?: Maybe<String[] | String>;
  UserName_not_in?: Maybe<String[] | String>;
  UserName_lt?: Maybe<String>;
  UserName_lte?: Maybe<String>;
  UserName_gt?: Maybe<String>;
  UserName_gte?: Maybe<String>;
  UserName_contains?: Maybe<String>;
  UserName_not_contains?: Maybe<String>;
  UserName_starts_with?: Maybe<String>;
  UserName_not_starts_with?: Maybe<String>;
  UserName_ends_with?: Maybe<String>;
  UserName_not_ends_with?: Maybe<String>;
  Address?: Maybe<String>;
  Address_not?: Maybe<String>;
  Address_in?: Maybe<String[] | String>;
  Address_not_in?: Maybe<String[] | String>;
  Address_lt?: Maybe<String>;
  Address_lte?: Maybe<String>;
  Address_gt?: Maybe<String>;
  Address_gte?: Maybe<String>;
  Address_contains?: Maybe<String>;
  Address_not_contains?: Maybe<String>;
  Address_starts_with?: Maybe<String>;
  Address_not_starts_with?: Maybe<String>;
  Address_ends_with?: Maybe<String>;
  Address_not_ends_with?: Maybe<String>;
  PhoneNumber?: Maybe<String>;
  PhoneNumber_not?: Maybe<String>;
  PhoneNumber_in?: Maybe<String[] | String>;
  PhoneNumber_not_in?: Maybe<String[] | String>;
  PhoneNumber_lt?: Maybe<String>;
  PhoneNumber_lte?: Maybe<String>;
  PhoneNumber_gt?: Maybe<String>;
  PhoneNumber_gte?: Maybe<String>;
  PhoneNumber_contains?: Maybe<String>;
  PhoneNumber_not_contains?: Maybe<String>;
  PhoneNumber_starts_with?: Maybe<String>;
  PhoneNumber_not_starts_with?: Maybe<String>;
  PhoneNumber_ends_with?: Maybe<String>;
  PhoneNumber_not_ends_with?: Maybe<String>;
  PhoneCode?: Maybe<String>;
  PhoneCode_not?: Maybe<String>;
  PhoneCode_in?: Maybe<String[] | String>;
  PhoneCode_not_in?: Maybe<String[] | String>;
  PhoneCode_lt?: Maybe<String>;
  PhoneCode_lte?: Maybe<String>;
  PhoneCode_gt?: Maybe<String>;
  PhoneCode_gte?: Maybe<String>;
  PhoneCode_contains?: Maybe<String>;
  PhoneCode_not_contains?: Maybe<String>;
  PhoneCode_starts_with?: Maybe<String>;
  PhoneCode_not_starts_with?: Maybe<String>;
  PhoneCode_ends_with?: Maybe<String>;
  PhoneCode_not_ends_with?: Maybe<String>;
  Email?: Maybe<String>;
  Email_not?: Maybe<String>;
  Email_in?: Maybe<String[] | String>;
  Email_not_in?: Maybe<String[] | String>;
  Email_lt?: Maybe<String>;
  Email_lte?: Maybe<String>;
  Email_gt?: Maybe<String>;
  Email_gte?: Maybe<String>;
  Email_contains?: Maybe<String>;
  Email_not_contains?: Maybe<String>;
  Email_starts_with?: Maybe<String>;
  Email_not_starts_with?: Maybe<String>;
  Email_ends_with?: Maybe<String>;
  Email_not_ends_with?: Maybe<String>;
  TenantId?: Maybe<String>;
  TenantId_not?: Maybe<String>;
  TenantId_in?: Maybe<String[] | String>;
  TenantId_not_in?: Maybe<String[] | String>;
  TenantId_lt?: Maybe<String>;
  TenantId_lte?: Maybe<String>;
  TenantId_gt?: Maybe<String>;
  TenantId_gte?: Maybe<String>;
  TenantId_contains?: Maybe<String>;
  TenantId_not_contains?: Maybe<String>;
  TenantId_starts_with?: Maybe<String>;
  TenantId_not_starts_with?: Maybe<String>;
  TenantId_ends_with?: Maybe<String>;
  TenantId_not_ends_with?: Maybe<String>;
  CompanyName?: Maybe<String>;
  CompanyName_not?: Maybe<String>;
  CompanyName_in?: Maybe<String[] | String>;
  CompanyName_not_in?: Maybe<String[] | String>;
  CompanyName_lt?: Maybe<String>;
  CompanyName_lte?: Maybe<String>;
  CompanyName_gt?: Maybe<String>;
  CompanyName_gte?: Maybe<String>;
  CompanyName_contains?: Maybe<String>;
  CompanyName_not_contains?: Maybe<String>;
  CompanyName_starts_with?: Maybe<String>;
  CompanyName_not_starts_with?: Maybe<String>;
  CompanyName_ends_with?: Maybe<String>;
  CompanyName_not_ends_with?: Maybe<String>;
  ZipCode?: Maybe<String>;
  ZipCode_not?: Maybe<String>;
  ZipCode_in?: Maybe<String[] | String>;
  ZipCode_not_in?: Maybe<String[] | String>;
  ZipCode_lt?: Maybe<String>;
  ZipCode_lte?: Maybe<String>;
  ZipCode_gt?: Maybe<String>;
  ZipCode_gte?: Maybe<String>;
  ZipCode_contains?: Maybe<String>;
  ZipCode_not_contains?: Maybe<String>;
  ZipCode_starts_with?: Maybe<String>;
  ZipCode_not_starts_with?: Maybe<String>;
  ZipCode_ends_with?: Maybe<String>;
  ZipCode_not_ends_with?: Maybe<String>;
  Country?: Maybe<String>;
  Country_not?: Maybe<String>;
  Country_in?: Maybe<String[] | String>;
  Country_not_in?: Maybe<String[] | String>;
  Country_lt?: Maybe<String>;
  Country_lte?: Maybe<String>;
  Country_gt?: Maybe<String>;
  Country_gte?: Maybe<String>;
  Country_contains?: Maybe<String>;
  Country_not_contains?: Maybe<String>;
  Country_starts_with?: Maybe<String>;
  Country_not_starts_with?: Maybe<String>;
  Country_ends_with?: Maybe<String>;
  Country_not_ends_with?: Maybe<String>;
  State?: Maybe<String>;
  State_not?: Maybe<String>;
  State_in?: Maybe<String[] | String>;
  State_not_in?: Maybe<String[] | String>;
  State_lt?: Maybe<String>;
  State_lte?: Maybe<String>;
  State_gt?: Maybe<String>;
  State_gte?: Maybe<String>;
  State_contains?: Maybe<String>;
  State_not_contains?: Maybe<String>;
  State_starts_with?: Maybe<String>;
  State_not_starts_with?: Maybe<String>;
  State_ends_with?: Maybe<String>;
  State_not_ends_with?: Maybe<String>;
  City?: Maybe<String>;
  City_not?: Maybe<String>;
  City_in?: Maybe<String[] | String>;
  City_not_in?: Maybe<String[] | String>;
  City_lt?: Maybe<String>;
  City_lte?: Maybe<String>;
  City_gt?: Maybe<String>;
  City_gte?: Maybe<String>;
  City_contains?: Maybe<String>;
  City_not_contains?: Maybe<String>;
  City_starts_with?: Maybe<String>;
  City_not_starts_with?: Maybe<String>;
  City_ends_with?: Maybe<String>;
  City_not_ends_with?: Maybe<String>;
  IsAdmin?: Maybe<String>;
  IsAdmin_not?: Maybe<String>;
  IsAdmin_in?: Maybe<String[] | String>;
  IsAdmin_not_in?: Maybe<String[] | String>;
  IsAdmin_lt?: Maybe<String>;
  IsAdmin_lte?: Maybe<String>;
  IsAdmin_gt?: Maybe<String>;
  IsAdmin_gte?: Maybe<String>;
  IsAdmin_contains?: Maybe<String>;
  IsAdmin_not_contains?: Maybe<String>;
  IsAdmin_starts_with?: Maybe<String>;
  IsAdmin_not_starts_with?: Maybe<String>;
  IsAdmin_ends_with?: Maybe<String>;
  IsAdmin_not_ends_with?: Maybe<String>;
  Password?: Maybe<String>;
  Password_not?: Maybe<String>;
  Password_in?: Maybe<String[] | String>;
  Password_not_in?: Maybe<String[] | String>;
  Password_lt?: Maybe<String>;
  Password_lte?: Maybe<String>;
  Password_gt?: Maybe<String>;
  Password_gte?: Maybe<String>;
  Password_contains?: Maybe<String>;
  Password_not_contains?: Maybe<String>;
  Password_starts_with?: Maybe<String>;
  Password_not_starts_with?: Maybe<String>;
  Password_ends_with?: Maybe<String>;
  Password_not_ends_with?: Maybe<String>;
  ConfirmPassword?: Maybe<String>;
  ConfirmPassword_not?: Maybe<String>;
  ConfirmPassword_in?: Maybe<String[] | String>;
  ConfirmPassword_not_in?: Maybe<String[] | String>;
  ConfirmPassword_lt?: Maybe<String>;
  ConfirmPassword_lte?: Maybe<String>;
  ConfirmPassword_gt?: Maybe<String>;
  ConfirmPassword_gte?: Maybe<String>;
  ConfirmPassword_contains?: Maybe<String>;
  ConfirmPassword_not_contains?: Maybe<String>;
  ConfirmPassword_starts_with?: Maybe<String>;
  ConfirmPassword_not_starts_with?: Maybe<String>;
  ConfirmPassword_ends_with?: Maybe<String>;
  ConfirmPassword_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface EntityConnStrctjsonUpdateManyInput {
  create?: Maybe<
    EntityConnStrctjsonCreateInput[] | EntityConnStrctjsonCreateInput
  >;
  deleteMany?: Maybe<
    EntityConnStrctjsonScalarWhereInput[] | EntityConnStrctjsonScalarWhereInput
  >;
  updateMany?: Maybe<
    | EntityConnStrctjsonUpdateManyWithWhereNestedInput[]
    | EntityConnStrctjsonUpdateManyWithWhereNestedInput
  >;
}

export interface SubscriptionIntegrationWhereInput {
  SubscriptionIntegrationId?: Maybe<ID_Input>;
  SubscriptionIntegrationId_not?: Maybe<ID_Input>;
  SubscriptionIntegrationId_in?: Maybe<ID_Input[] | ID_Input>;
  SubscriptionIntegrationId_not_in?: Maybe<ID_Input[] | ID_Input>;
  SubscriptionIntegrationId_lt?: Maybe<ID_Input>;
  SubscriptionIntegrationId_lte?: Maybe<ID_Input>;
  SubscriptionIntegrationId_gt?: Maybe<ID_Input>;
  SubscriptionIntegrationId_gte?: Maybe<ID_Input>;
  SubscriptionIntegrationId_contains?: Maybe<ID_Input>;
  SubscriptionIntegrationId_not_contains?: Maybe<ID_Input>;
  SubscriptionIntegrationId_starts_with?: Maybe<ID_Input>;
  SubscriptionIntegrationId_not_starts_with?: Maybe<ID_Input>;
  SubscriptionIntegrationId_ends_with?: Maybe<ID_Input>;
  SubscriptionIntegrationId_not_ends_with?: Maybe<ID_Input>;
  NoOfLicenses?: Maybe<String>;
  NoOfLicenses_not?: Maybe<String>;
  NoOfLicenses_in?: Maybe<String[] | String>;
  NoOfLicenses_not_in?: Maybe<String[] | String>;
  NoOfLicenses_lt?: Maybe<String>;
  NoOfLicenses_lte?: Maybe<String>;
  NoOfLicenses_gt?: Maybe<String>;
  NoOfLicenses_gte?: Maybe<String>;
  NoOfLicenses_contains?: Maybe<String>;
  NoOfLicenses_not_contains?: Maybe<String>;
  NoOfLicenses_starts_with?: Maybe<String>;
  NoOfLicenses_not_starts_with?: Maybe<String>;
  NoOfLicenses_ends_with?: Maybe<String>;
  NoOfLicenses_not_ends_with?: Maybe<String>;
  NoOfUsers?: Maybe<String>;
  NoOfUsers_not?: Maybe<String>;
  NoOfUsers_in?: Maybe<String[] | String>;
  NoOfUsers_not_in?: Maybe<String[] | String>;
  NoOfUsers_lt?: Maybe<String>;
  NoOfUsers_lte?: Maybe<String>;
  NoOfUsers_gt?: Maybe<String>;
  NoOfUsers_gte?: Maybe<String>;
  NoOfUsers_contains?: Maybe<String>;
  NoOfUsers_not_contains?: Maybe<String>;
  NoOfUsers_starts_with?: Maybe<String>;
  NoOfUsers_not_starts_with?: Maybe<String>;
  NoOfUsers_ends_with?: Maybe<String>;
  NoOfUsers_not_ends_with?: Maybe<String>;
  Status?: Maybe<Status>;
  Status_not?: Maybe<Status>;
  Status_in?: Maybe<Status[] | Status>;
  Status_not_in?: Maybe<Status[] | Status>;
  TenantId?: Maybe<UserWhereInput>;
  ConnectorId?: Maybe<ConnectorWhereInput>;
  SubscriptionStartDate?: Maybe<DateTimeInput>;
  SubscriptionStartDate_not?: Maybe<DateTimeInput>;
  SubscriptionStartDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  SubscriptionStartDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  SubscriptionStartDate_lt?: Maybe<DateTimeInput>;
  SubscriptionStartDate_lte?: Maybe<DateTimeInput>;
  SubscriptionStartDate_gt?: Maybe<DateTimeInput>;
  SubscriptionStartDate_gte?: Maybe<DateTimeInput>;
  SubscriptionEndDate?: Maybe<DateTimeInput>;
  SubscriptionEndDate_not?: Maybe<DateTimeInput>;
  SubscriptionEndDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  SubscriptionEndDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  SubscriptionEndDate_lt?: Maybe<DateTimeInput>;
  SubscriptionEndDate_lte?: Maybe<DateTimeInput>;
  SubscriptionEndDate_gt?: Maybe<DateTimeInput>;
  SubscriptionEndDate_gte?: Maybe<DateTimeInput>;
  PrimaryPluginConnectionData_some?: Maybe<ConnStrctjsonWhereInput>;
  PrimaryPluginConnectionData_every?: Maybe<ConnStrctjsonRestrictedWhereInput>;
  PrimaryPluginConnectionData_none?: Maybe<ConnStrctjsonRestrictedWhereInput>;
  SecondaryPluginConnectionData_some?: Maybe<ConnStrctjsonWhereInput>;
  SecondaryPluginConnectionData_every?: Maybe<
    ConnStrctjsonRestrictedWhereInput
  >;
  SecondaryPluginConnectionData_none?: Maybe<ConnStrctjsonRestrictedWhereInput>;
  ConfigStructure_some?: Maybe<EntityConnStrctjsonWhereInput>;
  ConfigStructure_every?: Maybe<EntityConnStrctjsonRestrictedWhereInput>;
  ConfigStructure_none?: Maybe<EntityConnStrctjsonRestrictedWhereInput>;
  AND?: Maybe<
    SubscriptionIntegrationWhereInput[] | SubscriptionIntegrationWhereInput
  >;
}

export interface EntityConnStrctjsonScalarWhereInput {
  Name?: Maybe<String>;
  Name_not?: Maybe<String>;
  Name_in?: Maybe<String[] | String>;
  Name_not_in?: Maybe<String[] | String>;
  Name_lt?: Maybe<String>;
  Name_lte?: Maybe<String>;
  Name_gt?: Maybe<String>;
  Name_gte?: Maybe<String>;
  Name_contains?: Maybe<String>;
  Name_not_contains?: Maybe<String>;
  Name_starts_with?: Maybe<String>;
  Name_not_starts_with?: Maybe<String>;
  Name_ends_with?: Maybe<String>;
  Name_not_ends_with?: Maybe<String>;
  Value?: Maybe<String>;
  Value_not?: Maybe<String>;
  Value_in?: Maybe<String[] | String>;
  Value_not_in?: Maybe<String[] | String>;
  Value_lt?: Maybe<String>;
  Value_lte?: Maybe<String>;
  Value_gt?: Maybe<String>;
  Value_gte?: Maybe<String>;
  Value_contains?: Maybe<String>;
  Value_not_contains?: Maybe<String>;
  Value_starts_with?: Maybe<String>;
  Value_not_starts_with?: Maybe<String>;
  Value_ends_with?: Maybe<String>;
  Value_not_ends_with?: Maybe<String>;
  PluginId?: Maybe<String>;
  PluginId_not?: Maybe<String>;
  PluginId_in?: Maybe<String[] | String>;
  PluginId_not_in?: Maybe<String[] | String>;
  PluginId_lt?: Maybe<String>;
  PluginId_lte?: Maybe<String>;
  PluginId_gt?: Maybe<String>;
  PluginId_gte?: Maybe<String>;
  PluginId_contains?: Maybe<String>;
  PluginId_not_contains?: Maybe<String>;
  PluginId_starts_with?: Maybe<String>;
  PluginId_not_starts_with?: Maybe<String>;
  PluginId_ends_with?: Maybe<String>;
  PluginId_not_ends_with?: Maybe<String>;
  EntityID?: Maybe<String>;
  EntityID_not?: Maybe<String>;
  EntityID_in?: Maybe<String[] | String>;
  EntityID_not_in?: Maybe<String[] | String>;
  EntityID_lt?: Maybe<String>;
  EntityID_lte?: Maybe<String>;
  EntityID_gt?: Maybe<String>;
  EntityID_gte?: Maybe<String>;
  EntityID_contains?: Maybe<String>;
  EntityID_not_contains?: Maybe<String>;
  EntityID_starts_with?: Maybe<String>;
  EntityID_not_starts_with?: Maybe<String>;
  EntityID_ends_with?: Maybe<String>;
  EntityID_not_ends_with?: Maybe<String>;
  Question?: Maybe<String>;
  Question_not?: Maybe<String>;
  Question_in?: Maybe<String[] | String>;
  Question_not_in?: Maybe<String[] | String>;
  Question_lt?: Maybe<String>;
  Question_lte?: Maybe<String>;
  Question_gt?: Maybe<String>;
  Question_gte?: Maybe<String>;
  Question_contains?: Maybe<String>;
  Question_not_contains?: Maybe<String>;
  Question_starts_with?: Maybe<String>;
  Question_not_starts_with?: Maybe<String>;
  Question_ends_with?: Maybe<String>;
  Question_not_ends_with?: Maybe<String>;
  FieldType?: Maybe<String>;
  FieldType_not?: Maybe<String>;
  FieldType_in?: Maybe<String[] | String>;
  FieldType_not_in?: Maybe<String[] | String>;
  FieldType_lt?: Maybe<String>;
  FieldType_lte?: Maybe<String>;
  FieldType_gt?: Maybe<String>;
  FieldType_gte?: Maybe<String>;
  FieldType_contains?: Maybe<String>;
  FieldType_not_contains?: Maybe<String>;
  FieldType_starts_with?: Maybe<String>;
  FieldType_not_starts_with?: Maybe<String>;
  FieldType_ends_with?: Maybe<String>;
  FieldType_not_ends_with?: Maybe<String>;
  FieldLength?: Maybe<Int>;
  FieldLength_not?: Maybe<Int>;
  FieldLength_in?: Maybe<Int[] | Int>;
  FieldLength_not_in?: Maybe<Int[] | Int>;
  FieldLength_lt?: Maybe<Int>;
  FieldLength_lte?: Maybe<Int>;
  FieldLength_gt?: Maybe<Int>;
  FieldLength_gte?: Maybe<Int>;
  IsRequired?: Maybe<Boolean>;
  IsRequired_not?: Maybe<Boolean>;
  FieldName?: Maybe<String>;
  FieldName_not?: Maybe<String>;
  FieldName_in?: Maybe<String[] | String>;
  FieldName_not_in?: Maybe<String[] | String>;
  FieldName_lt?: Maybe<String>;
  FieldName_lte?: Maybe<String>;
  FieldName_gt?: Maybe<String>;
  FieldName_gte?: Maybe<String>;
  FieldName_contains?: Maybe<String>;
  FieldName_not_contains?: Maybe<String>;
  FieldName_starts_with?: Maybe<String>;
  FieldName_not_starts_with?: Maybe<String>;
  FieldName_ends_with?: Maybe<String>;
  FieldName_not_ends_with?: Maybe<String>;
  Answers?: Maybe<String>;
  Answers_not?: Maybe<String>;
  Answers_in?: Maybe<String[] | String>;
  Answers_not_in?: Maybe<String[] | String>;
  Answers_lt?: Maybe<String>;
  Answers_lte?: Maybe<String>;
  Answers_gt?: Maybe<String>;
  Answers_gte?: Maybe<String>;
  Answers_contains?: Maybe<String>;
  Answers_not_contains?: Maybe<String>;
  Answers_starts_with?: Maybe<String>;
  Answers_not_starts_with?: Maybe<String>;
  Answers_ends_with?: Maybe<String>;
  Answers_not_ends_with?: Maybe<String>;
  IsEditable?: Maybe<Boolean>;
  IsEditable_not?: Maybe<Boolean>;
  IsViewable?: Maybe<Boolean>;
  IsViewable_not?: Maybe<Boolean>;
  AND?: Maybe<
    EntityConnStrctjsonScalarWhereInput[] | EntityConnStrctjsonScalarWhereInput
  >;
  OR?: Maybe<
    EntityConnStrctjsonScalarWhereInput[] | EntityConnStrctjsonScalarWhereInput
  >;
  NOT?: Maybe<
    EntityConnStrctjsonScalarWhereInput[] | EntityConnStrctjsonScalarWhereInput
  >;
}

export interface ProcessHistorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProcessHistoryWhereInput>;
  AND?: Maybe<
    | ProcessHistorySubscriptionWhereInput[]
    | ProcessHistorySubscriptionWhereInput
  >;
}

export interface EntityConnStrctjsonUpdateManyWithWhereNestedInput {
  where: EntityConnStrctjsonScalarWhereInput;
  data: EntityConnStrctjsonUpdateManyDataInput;
}

export type PluginWhereUniqueInput = AtLeastOne<{
  PluginID: Maybe<ID_Input>;
  PluginSEOName?: Maybe<String>;
}>;

export interface EntityConnStrctjsonUpdateManyDataInput {
  Name?: Maybe<String>;
  Value?: Maybe<String>;
  PluginId?: Maybe<String>;
  EntityID?: Maybe<String>;
  Question?: Maybe<String>;
  FieldType?: Maybe<String>;
  LookupValues?: Maybe<EntityConnStrctjsonUpdateLookupValuesInput>;
  FieldLength?: Maybe<Int>;
  IsRequired?: Maybe<Boolean>;
  FieldName?: Maybe<String>;
  Answers?: Maybe<String>;
  IsEditable?: Maybe<Boolean>;
  IsViewable?: Maybe<Boolean>;
}

export interface SubcriptionHistoryUpdateManyMutationInput {
  SubcriptionHistoryName?: Maybe<String>;
  Status?: Maybe<Status>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface EntityConnStrctjsonUpdateLookupValuesInput {
  set?: Maybe<String[] | String>;
}

export interface SourceTargetFieldmappingUpdateManyMutationInput {
  FieldShortDesc?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  SourceKey?: Maybe<String>;
  SourceKeyValue?: Maybe<String>;
  TargetKey?: Maybe<String>;
  TargetKeyValue?: Maybe<String>;
  OtherParam?: Maybe<String>;
}

export interface EntityUpdateManyMutationInput {
  EntityName?: Maybe<String>;
  EntityType?: Maybe<String>;
  EntityShortDesc?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ConnectUrl?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  Status?: Maybe<Status>;
}

export interface PluginParamWhereInput {
  PluginParamID?: Maybe<ID_Input>;
  PluginParamID_not?: Maybe<ID_Input>;
  PluginParamID_in?: Maybe<ID_Input[] | ID_Input>;
  PluginParamID_not_in?: Maybe<ID_Input[] | ID_Input>;
  PluginParamID_lt?: Maybe<ID_Input>;
  PluginParamID_lte?: Maybe<ID_Input>;
  PluginParamID_gt?: Maybe<ID_Input>;
  PluginParamID_gte?: Maybe<ID_Input>;
  PluginParamID_contains?: Maybe<ID_Input>;
  PluginParamID_not_contains?: Maybe<ID_Input>;
  PluginParamID_starts_with?: Maybe<ID_Input>;
  PluginParamID_not_starts_with?: Maybe<ID_Input>;
  PluginParamID_ends_with?: Maybe<ID_Input>;
  PluginParamID_not_ends_with?: Maybe<ID_Input>;
  FieldType?: Maybe<String>;
  FieldType_not?: Maybe<String>;
  FieldType_in?: Maybe<String[] | String>;
  FieldType_not_in?: Maybe<String[] | String>;
  FieldType_lt?: Maybe<String>;
  FieldType_lte?: Maybe<String>;
  FieldType_gt?: Maybe<String>;
  FieldType_gte?: Maybe<String>;
  FieldType_contains?: Maybe<String>;
  FieldType_not_contains?: Maybe<String>;
  FieldType_starts_with?: Maybe<String>;
  FieldType_not_starts_with?: Maybe<String>;
  FieldType_ends_with?: Maybe<String>;
  FieldType_not_ends_with?: Maybe<String>;
  FieldName?: Maybe<String>;
  FieldName_not?: Maybe<String>;
  FieldName_in?: Maybe<String[] | String>;
  FieldName_not_in?: Maybe<String[] | String>;
  FieldName_lt?: Maybe<String>;
  FieldName_lte?: Maybe<String>;
  FieldName_gt?: Maybe<String>;
  FieldName_gte?: Maybe<String>;
  FieldName_contains?: Maybe<String>;
  FieldName_not_contains?: Maybe<String>;
  FieldName_starts_with?: Maybe<String>;
  FieldName_not_starts_with?: Maybe<String>;
  FieldName_ends_with?: Maybe<String>;
  FieldName_not_ends_with?: Maybe<String>;
  Caption?: Maybe<String>;
  Caption_not?: Maybe<String>;
  Caption_in?: Maybe<String[] | String>;
  Caption_not_in?: Maybe<String[] | String>;
  Caption_lt?: Maybe<String>;
  Caption_lte?: Maybe<String>;
  Caption_gt?: Maybe<String>;
  Caption_gte?: Maybe<String>;
  Caption_contains?: Maybe<String>;
  Caption_not_contains?: Maybe<String>;
  Caption_starts_with?: Maybe<String>;
  Caption_not_starts_with?: Maybe<String>;
  Caption_ends_with?: Maybe<String>;
  Caption_not_ends_with?: Maybe<String>;
  PluginID?: Maybe<PluginWhereInput>;
  Status?: Maybe<Status>;
  Status_not?: Maybe<Status>;
  Status_in?: Maybe<Status[] | Status>;
  Status_not_in?: Maybe<Status[] | Status>;
  Required?: Maybe<Boolean>;
  Required_not?: Maybe<Boolean>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  CreatedDate?: Maybe<DateTimeInput>;
  CreatedDate_not?: Maybe<DateTimeInput>;
  CreatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_lt?: Maybe<DateTimeInput>;
  CreatedDate_lte?: Maybe<DateTimeInput>;
  CreatedDate_gt?: Maybe<DateTimeInput>;
  CreatedDate_gte?: Maybe<DateTimeInput>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  ModifiedDate?: Maybe<DateTimeInput>;
  ModifiedDate_not?: Maybe<DateTimeInput>;
  ModifiedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_lt?: Maybe<DateTimeInput>;
  ModifiedDate_lte?: Maybe<DateTimeInput>;
  ModifiedDate_gt?: Maybe<DateTimeInput>;
  ModifiedDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PluginParamWhereInput[] | PluginParamWhereInput>;
}

export interface EntityMapCreateInput {
  EntityMapID?: Maybe<ID_Input>;
  SourceEntityID?: Maybe<EntityCreateManyInput>;
  TargetEntityID?: Maybe<EntityCreateManyInput>;
  Status?: Maybe<Status>;
  EntityShortDesc?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface SubscriberProcessUpdateWithoutScheduleDataInput {
  ProcessId?: Maybe<ProcessUpdateOneInput>;
  TenantId?: Maybe<UserUpdateOneInput>;
  ConnectorId?: Maybe<ConnectorUpdateOneInput>;
  Status?: Maybe<Status>;
  Stage?: Maybe<Stage>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  LastSyncDate?: Maybe<String>;
  PrimaryEntity?: Maybe<EntityUpdateOneInput>;
  SecondaryEntity?: Maybe<EntityUpdateOneInput>;
}

export interface EntityCreateManyInput {
  create?: Maybe<EntityCreateInput[] | EntityCreateInput>;
  connect?: Maybe<EntityWhereUniqueInput[] | EntityWhereUniqueInput>;
}

export interface ScheduleUpdateInput {
  TenantId?: Maybe<UserUpdateOneInput>;
  ProcessId?: Maybe<ProcessUpdateOneInput>;
  SubscriberProcess?: Maybe<SubscriberProcessUpdateOneWithoutScheduleInput>;
  SubcriptionHistoryId?: Maybe<SubcriptionHistoryUpdateOneInput>;
  Field?: Maybe<String>;
  Status?: Maybe<Stage>;
  DailyOccurence?: Maybe<String>;
  ScheduleType?: Maybe<String>;
  DailyRecurrenceType?: Maybe<String>;
  OccursAt?: Maybe<String>;
  DailyInterval?: Maybe<String>;
  DailyIntervalSpan?: Maybe<String>;
  WeekDays?: Maybe<ScheduleUpdateWeekDaysInput>;
  DayofMonth?: Maybe<String>;
  LastExecuted?: Maybe<String>;
  NextOccurence?: Maybe<String>;
  SubscriptionIntegrationId?: Maybe<SubscriptionIntegrationUpdateOneInput>;
  CreatedDate?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedDate?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  StartTime?: Maybe<String>;
  EndTime?: Maybe<String>;
  Type?: Maybe<String>;
}

export interface EntityMapUpdateInput {
  SourceEntityID?: Maybe<EntityUpdateManyInput>;
  TargetEntityID?: Maybe<EntityUpdateManyInput>;
  Status?: Maybe<Status>;
  EntityShortDesc?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface ProcessHistoryWhereInput {
  ProcessHistoryId?: Maybe<ID_Input>;
  ProcessHistoryId_not?: Maybe<ID_Input>;
  ProcessHistoryId_in?: Maybe<ID_Input[] | ID_Input>;
  ProcessHistoryId_not_in?: Maybe<ID_Input[] | ID_Input>;
  ProcessHistoryId_lt?: Maybe<ID_Input>;
  ProcessHistoryId_lte?: Maybe<ID_Input>;
  ProcessHistoryId_gt?: Maybe<ID_Input>;
  ProcessHistoryId_gte?: Maybe<ID_Input>;
  ProcessHistoryId_contains?: Maybe<ID_Input>;
  ProcessHistoryId_not_contains?: Maybe<ID_Input>;
  ProcessHistoryId_starts_with?: Maybe<ID_Input>;
  ProcessHistoryId_not_starts_with?: Maybe<ID_Input>;
  ProcessHistoryId_ends_with?: Maybe<ID_Input>;
  ProcessHistoryId_not_ends_with?: Maybe<ID_Input>;
  ProcessId?: Maybe<ProcessWhereInput>;
  TenantId?: Maybe<UserWhereInput>;
  LastSyncDate?: Maybe<String>;
  LastSyncDate_not?: Maybe<String>;
  LastSyncDate_in?: Maybe<String[] | String>;
  LastSyncDate_not_in?: Maybe<String[] | String>;
  LastSyncDate_lt?: Maybe<String>;
  LastSyncDate_lte?: Maybe<String>;
  LastSyncDate_gt?: Maybe<String>;
  LastSyncDate_gte?: Maybe<String>;
  LastSyncDate_contains?: Maybe<String>;
  LastSyncDate_not_contains?: Maybe<String>;
  LastSyncDate_starts_with?: Maybe<String>;
  LastSyncDate_not_starts_with?: Maybe<String>;
  LastSyncDate_ends_with?: Maybe<String>;
  LastSyncDate_not_ends_with?: Maybe<String>;
  CreatedDate?: Maybe<DateTimeInput>;
  CreatedDate_not?: Maybe<DateTimeInput>;
  CreatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_lt?: Maybe<DateTimeInput>;
  CreatedDate_lte?: Maybe<DateTimeInput>;
  CreatedDate_gt?: Maybe<DateTimeInput>;
  CreatedDate_gte?: Maybe<DateTimeInput>;
  ModifiedDate?: Maybe<DateTimeInput>;
  ModifiedDate_not?: Maybe<DateTimeInput>;
  ModifiedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_lt?: Maybe<DateTimeInput>;
  ModifiedDate_lte?: Maybe<DateTimeInput>;
  ModifiedDate_gt?: Maybe<DateTimeInput>;
  ModifiedDate_gte?: Maybe<DateTimeInput>;
  Stage?: Maybe<Stage>;
  Stage_not?: Maybe<Stage>;
  Stage_in?: Maybe<Stage[] | Stage>;
  Stage_not_in?: Maybe<Stage[] | Stage>;
  AND?: Maybe<ProcessHistoryWhereInput[] | ProcessHistoryWhereInput>;
}

export interface EntityUpdateManyInput {
  create?: Maybe<EntityCreateInput[] | EntityCreateInput>;
  update?: Maybe<
    | EntityUpdateWithWhereUniqueNestedInput[]
    | EntityUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | EntityUpsertWithWhereUniqueNestedInput[]
    | EntityUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<EntityWhereUniqueInput[] | EntityWhereUniqueInput>;
  connect?: Maybe<EntityWhereUniqueInput[] | EntityWhereUniqueInput>;
  set?: Maybe<EntityWhereUniqueInput[] | EntityWhereUniqueInput>;
  disconnect?: Maybe<EntityWhereUniqueInput[] | EntityWhereUniqueInput>;
  deleteMany?: Maybe<EntityScalarWhereInput[] | EntityScalarWhereInput>;
  updateMany?: Maybe<
    | EntityUpdateManyWithWhereNestedInput[]
    | EntityUpdateManyWithWhereNestedInput
  >;
}

export interface ProcessHistoryUpdateInput {
  ProcessId?: Maybe<ProcessUpdateOneInput>;
  TenantId?: Maybe<UserUpdateOneInput>;
  LastSyncDate?: Maybe<String>;
  Stage?: Maybe<Stage>;
}

export interface EntityUpdateWithWhereUniqueNestedInput {
  where: EntityWhereUniqueInput;
  data: EntityUpdateDataInput;
}

export interface ProcessUpdateInput {
  ConnectorId?: Maybe<ConnectorUpdateOneInput>;
  ProcessShortDesc?: Maybe<String>;
  ProcessLongDesc?: Maybe<String>;
  Status?: Maybe<Status>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  PrimaryEntity?: Maybe<EntityUpdateOneInput>;
  SecondaryEntity?: Maybe<EntityUpdateOneInput>;
}

export interface EntityUpdateDataInput {
  PluginID?: Maybe<PluginUpdateOneInput>;
  EntityName?: Maybe<String>;
  EntityType?: Maybe<String>;
  EntityShortDesc?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ConnectUrl?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  Status?: Maybe<Status>;
  ConfigStructure?: Maybe<EntityConnStrctjsonUpdateManyInput>;
}

export interface ConnStrctjsonWhereInput {
  Name?: Maybe<String>;
  Name_not?: Maybe<String>;
  Name_in?: Maybe<String[] | String>;
  Name_not_in?: Maybe<String[] | String>;
  Name_lt?: Maybe<String>;
  Name_lte?: Maybe<String>;
  Name_gt?: Maybe<String>;
  Name_gte?: Maybe<String>;
  Name_contains?: Maybe<String>;
  Name_not_contains?: Maybe<String>;
  Name_starts_with?: Maybe<String>;
  Name_not_starts_with?: Maybe<String>;
  Name_ends_with?: Maybe<String>;
  Name_not_ends_with?: Maybe<String>;
  Label?: Maybe<String>;
  Label_not?: Maybe<String>;
  Label_in?: Maybe<String[] | String>;
  Label_not_in?: Maybe<String[] | String>;
  Label_lt?: Maybe<String>;
  Label_lte?: Maybe<String>;
  Label_gt?: Maybe<String>;
  Label_gte?: Maybe<String>;
  Label_contains?: Maybe<String>;
  Label_not_contains?: Maybe<String>;
  Label_starts_with?: Maybe<String>;
  Label_not_starts_with?: Maybe<String>;
  Label_ends_with?: Maybe<String>;
  Label_not_ends_with?: Maybe<String>;
  Value?: Maybe<String>;
  Value_not?: Maybe<String>;
  Value_in?: Maybe<String[] | String>;
  Value_not_in?: Maybe<String[] | String>;
  Value_lt?: Maybe<String>;
  Value_lte?: Maybe<String>;
  Value_gt?: Maybe<String>;
  Value_gte?: Maybe<String>;
  Value_contains?: Maybe<String>;
  Value_not_contains?: Maybe<String>;
  Value_starts_with?: Maybe<String>;
  Value_not_starts_with?: Maybe<String>;
  Value_ends_with?: Maybe<String>;
  Value_not_ends_with?: Maybe<String>;
  IsRequired?: Maybe<Boolean>;
  IsRequired_not?: Maybe<Boolean>;
  IsEditable?: Maybe<Boolean>;
  IsEditable_not?: Maybe<Boolean>;
  IsViewable?: Maybe<Boolean>;
  IsViewable_not?: Maybe<Boolean>;
  FieldType?: Maybe<String>;
  FieldType_not?: Maybe<String>;
  FieldType_in?: Maybe<String[] | String>;
  FieldType_not_in?: Maybe<String[] | String>;
  FieldType_lt?: Maybe<String>;
  FieldType_lte?: Maybe<String>;
  FieldType_gt?: Maybe<String>;
  FieldType_gte?: Maybe<String>;
  FieldType_contains?: Maybe<String>;
  FieldType_not_contains?: Maybe<String>;
  FieldType_starts_with?: Maybe<String>;
  FieldType_not_starts_with?: Maybe<String>;
  FieldType_ends_with?: Maybe<String>;
  FieldType_not_ends_with?: Maybe<String>;
  SortOrder?: Maybe<Int>;
  SortOrder_not?: Maybe<Int>;
  SortOrder_in?: Maybe<Int[] | Int>;
  SortOrder_not_in?: Maybe<Int[] | Int>;
  SortOrder_lt?: Maybe<Int>;
  SortOrder_lte?: Maybe<Int>;
  SortOrder_gt?: Maybe<Int>;
  SortOrder_gte?: Maybe<Int>;
  AND?: Maybe<ConnStrctjsonWhereInput[] | ConnStrctjsonWhereInput>;
}

export interface EntityUpsertWithWhereUniqueNestedInput {
  where: EntityWhereUniqueInput;
  update: EntityUpdateDataInput;
  create: EntityCreateInput;
}

export type SubcriptionHistoryWhereUniqueInput = AtLeastOne<{
  SubcriptionHistoryId: Maybe<ID_Input>;
}>;

export interface EntityScalarWhereInput {
  EntityID?: Maybe<ID_Input>;
  EntityID_not?: Maybe<ID_Input>;
  EntityID_in?: Maybe<ID_Input[] | ID_Input>;
  EntityID_not_in?: Maybe<ID_Input[] | ID_Input>;
  EntityID_lt?: Maybe<ID_Input>;
  EntityID_lte?: Maybe<ID_Input>;
  EntityID_gt?: Maybe<ID_Input>;
  EntityID_gte?: Maybe<ID_Input>;
  EntityID_contains?: Maybe<ID_Input>;
  EntityID_not_contains?: Maybe<ID_Input>;
  EntityID_starts_with?: Maybe<ID_Input>;
  EntityID_not_starts_with?: Maybe<ID_Input>;
  EntityID_ends_with?: Maybe<ID_Input>;
  EntityID_not_ends_with?: Maybe<ID_Input>;
  EntityName?: Maybe<String>;
  EntityName_not?: Maybe<String>;
  EntityName_in?: Maybe<String[] | String>;
  EntityName_not_in?: Maybe<String[] | String>;
  EntityName_lt?: Maybe<String>;
  EntityName_lte?: Maybe<String>;
  EntityName_gt?: Maybe<String>;
  EntityName_gte?: Maybe<String>;
  EntityName_contains?: Maybe<String>;
  EntityName_not_contains?: Maybe<String>;
  EntityName_starts_with?: Maybe<String>;
  EntityName_not_starts_with?: Maybe<String>;
  EntityName_ends_with?: Maybe<String>;
  EntityName_not_ends_with?: Maybe<String>;
  EntityType?: Maybe<String>;
  EntityType_not?: Maybe<String>;
  EntityType_in?: Maybe<String[] | String>;
  EntityType_not_in?: Maybe<String[] | String>;
  EntityType_lt?: Maybe<String>;
  EntityType_lte?: Maybe<String>;
  EntityType_gt?: Maybe<String>;
  EntityType_gte?: Maybe<String>;
  EntityType_contains?: Maybe<String>;
  EntityType_not_contains?: Maybe<String>;
  EntityType_starts_with?: Maybe<String>;
  EntityType_not_starts_with?: Maybe<String>;
  EntityType_ends_with?: Maybe<String>;
  EntityType_not_ends_with?: Maybe<String>;
  EntityShortDesc?: Maybe<String>;
  EntityShortDesc_not?: Maybe<String>;
  EntityShortDesc_in?: Maybe<String[] | String>;
  EntityShortDesc_not_in?: Maybe<String[] | String>;
  EntityShortDesc_lt?: Maybe<String>;
  EntityShortDesc_lte?: Maybe<String>;
  EntityShortDesc_gt?: Maybe<String>;
  EntityShortDesc_gte?: Maybe<String>;
  EntityShortDesc_contains?: Maybe<String>;
  EntityShortDesc_not_contains?: Maybe<String>;
  EntityShortDesc_starts_with?: Maybe<String>;
  EntityShortDesc_not_starts_with?: Maybe<String>;
  EntityShortDesc_ends_with?: Maybe<String>;
  EntityShortDesc_not_ends_with?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  EntityLongDesc_not?: Maybe<String>;
  EntityLongDesc_in?: Maybe<String[] | String>;
  EntityLongDesc_not_in?: Maybe<String[] | String>;
  EntityLongDesc_lt?: Maybe<String>;
  EntityLongDesc_lte?: Maybe<String>;
  EntityLongDesc_gt?: Maybe<String>;
  EntityLongDesc_gte?: Maybe<String>;
  EntityLongDesc_contains?: Maybe<String>;
  EntityLongDesc_not_contains?: Maybe<String>;
  EntityLongDesc_starts_with?: Maybe<String>;
  EntityLongDesc_not_starts_with?: Maybe<String>;
  EntityLongDesc_ends_with?: Maybe<String>;
  EntityLongDesc_not_ends_with?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  ConnectUrl?: Maybe<String>;
  ConnectUrl_not?: Maybe<String>;
  ConnectUrl_in?: Maybe<String[] | String>;
  ConnectUrl_not_in?: Maybe<String[] | String>;
  ConnectUrl_lt?: Maybe<String>;
  ConnectUrl_lte?: Maybe<String>;
  ConnectUrl_gt?: Maybe<String>;
  ConnectUrl_gte?: Maybe<String>;
  ConnectUrl_contains?: Maybe<String>;
  ConnectUrl_not_contains?: Maybe<String>;
  ConnectUrl_starts_with?: Maybe<String>;
  ConnectUrl_not_starts_with?: Maybe<String>;
  ConnectUrl_ends_with?: Maybe<String>;
  ConnectUrl_not_ends_with?: Maybe<String>;
  CreatedDate?: Maybe<DateTimeInput>;
  CreatedDate_not?: Maybe<DateTimeInput>;
  CreatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_lt?: Maybe<DateTimeInput>;
  CreatedDate_lte?: Maybe<DateTimeInput>;
  CreatedDate_gt?: Maybe<DateTimeInput>;
  CreatedDate_gte?: Maybe<DateTimeInput>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  ModifiedDate?: Maybe<DateTimeInput>;
  ModifiedDate_not?: Maybe<DateTimeInput>;
  ModifiedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_lt?: Maybe<DateTimeInput>;
  ModifiedDate_lte?: Maybe<DateTimeInput>;
  ModifiedDate_gt?: Maybe<DateTimeInput>;
  ModifiedDate_gte?: Maybe<DateTimeInput>;
  Status?: Maybe<Status>;
  Status_not?: Maybe<Status>;
  Status_in?: Maybe<Status[] | Status>;
  Status_not_in?: Maybe<Status[] | Status>;
  AND?: Maybe<EntityScalarWhereInput[] | EntityScalarWhereInput>;
  OR?: Maybe<EntityScalarWhereInput[] | EntityScalarWhereInput>;
  NOT?: Maybe<EntityScalarWhereInput[] | EntityScalarWhereInput>;
}

export interface PluginUpdateInput {
  PluginName?: Maybe<String>;
  PluginTitle?: Maybe<String>;
  PluginShortName?: Maybe<String>;
  PluginSEOName?: Maybe<String>;
  PluginShortDesc?: Maybe<String>;
  PluginLongDesc?: Maybe<String>;
  AssemblyName?: Maybe<String>;
  Status?: Maybe<Status>;
  pluginType?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  ImageName?: Maybe<String>;
  ConnStructure?: Maybe<ConnStrctjsonUpdateManyInput>;
  DefaultStructure?: Maybe<String>;
  ConnectUrl?: Maybe<String>;
  Popular?: Maybe<Boolean>;
  Recent?: Maybe<Boolean>;
  PluginCategoryId?: Maybe<PluginCategoryUpdateOneInput>;
}

export interface EntityUpdateManyWithWhereNestedInput {
  where: EntityScalarWhereInput;
  data: EntityUpdateManyDataInput;
}

export interface ConnectorWhereInput {
  ConnectorId?: Maybe<ID_Input>;
  ConnectorId_not?: Maybe<ID_Input>;
  ConnectorId_in?: Maybe<ID_Input[] | ID_Input>;
  ConnectorId_not_in?: Maybe<ID_Input[] | ID_Input>;
  ConnectorId_lt?: Maybe<ID_Input>;
  ConnectorId_lte?: Maybe<ID_Input>;
  ConnectorId_gt?: Maybe<ID_Input>;
  ConnectorId_gte?: Maybe<ID_Input>;
  ConnectorId_contains?: Maybe<ID_Input>;
  ConnectorId_not_contains?: Maybe<ID_Input>;
  ConnectorId_starts_with?: Maybe<ID_Input>;
  ConnectorId_not_starts_with?: Maybe<ID_Input>;
  ConnectorId_ends_with?: Maybe<ID_Input>;
  ConnectorId_not_ends_with?: Maybe<ID_Input>;
  Status?: Maybe<Status>;
  Status_not?: Maybe<Status>;
  Status_in?: Maybe<Status[] | Status>;
  Status_not_in?: Maybe<Status[] | Status>;
  ConnectorTitle?: Maybe<String>;
  ConnectorTitle_not?: Maybe<String>;
  ConnectorTitle_in?: Maybe<String[] | String>;
  ConnectorTitle_not_in?: Maybe<String[] | String>;
  ConnectorTitle_lt?: Maybe<String>;
  ConnectorTitle_lte?: Maybe<String>;
  ConnectorTitle_gt?: Maybe<String>;
  ConnectorTitle_gte?: Maybe<String>;
  ConnectorTitle_contains?: Maybe<String>;
  ConnectorTitle_not_contains?: Maybe<String>;
  ConnectorTitle_starts_with?: Maybe<String>;
  ConnectorTitle_not_starts_with?: Maybe<String>;
  ConnectorTitle_ends_with?: Maybe<String>;
  ConnectorTitle_not_ends_with?: Maybe<String>;
  ConnectorShortName?: Maybe<String>;
  ConnectorShortName_not?: Maybe<String>;
  ConnectorShortName_in?: Maybe<String[] | String>;
  ConnectorShortName_not_in?: Maybe<String[] | String>;
  ConnectorShortName_lt?: Maybe<String>;
  ConnectorShortName_lte?: Maybe<String>;
  ConnectorShortName_gt?: Maybe<String>;
  ConnectorShortName_gte?: Maybe<String>;
  ConnectorShortName_contains?: Maybe<String>;
  ConnectorShortName_not_contains?: Maybe<String>;
  ConnectorShortName_starts_with?: Maybe<String>;
  ConnectorShortName_not_starts_with?: Maybe<String>;
  ConnectorShortName_ends_with?: Maybe<String>;
  ConnectorShortName_not_ends_with?: Maybe<String>;
  ConnectorSEOName?: Maybe<String>;
  ConnectorSEOName_not?: Maybe<String>;
  ConnectorSEOName_in?: Maybe<String[] | String>;
  ConnectorSEOName_not_in?: Maybe<String[] | String>;
  ConnectorSEOName_lt?: Maybe<String>;
  ConnectorSEOName_lte?: Maybe<String>;
  ConnectorSEOName_gt?: Maybe<String>;
  ConnectorSEOName_gte?: Maybe<String>;
  ConnectorSEOName_contains?: Maybe<String>;
  ConnectorSEOName_not_contains?: Maybe<String>;
  ConnectorSEOName_starts_with?: Maybe<String>;
  ConnectorSEOName_not_starts_with?: Maybe<String>;
  ConnectorSEOName_ends_with?: Maybe<String>;
  ConnectorSEOName_not_ends_with?: Maybe<String>;
  ConnectorShortDesc?: Maybe<String>;
  ConnectorShortDesc_not?: Maybe<String>;
  ConnectorShortDesc_in?: Maybe<String[] | String>;
  ConnectorShortDesc_not_in?: Maybe<String[] | String>;
  ConnectorShortDesc_lt?: Maybe<String>;
  ConnectorShortDesc_lte?: Maybe<String>;
  ConnectorShortDesc_gt?: Maybe<String>;
  ConnectorShortDesc_gte?: Maybe<String>;
  ConnectorShortDesc_contains?: Maybe<String>;
  ConnectorShortDesc_not_contains?: Maybe<String>;
  ConnectorShortDesc_starts_with?: Maybe<String>;
  ConnectorShortDesc_not_starts_with?: Maybe<String>;
  ConnectorShortDesc_ends_with?: Maybe<String>;
  ConnectorShortDesc_not_ends_with?: Maybe<String>;
  ConnectorLongDesc?: Maybe<String>;
  ConnectorLongDesc_not?: Maybe<String>;
  ConnectorLongDesc_in?: Maybe<String[] | String>;
  ConnectorLongDesc_not_in?: Maybe<String[] | String>;
  ConnectorLongDesc_lt?: Maybe<String>;
  ConnectorLongDesc_lte?: Maybe<String>;
  ConnectorLongDesc_gt?: Maybe<String>;
  ConnectorLongDesc_gte?: Maybe<String>;
  ConnectorLongDesc_contains?: Maybe<String>;
  ConnectorLongDesc_not_contains?: Maybe<String>;
  ConnectorLongDesc_starts_with?: Maybe<String>;
  ConnectorLongDesc_not_starts_with?: Maybe<String>;
  ConnectorLongDesc_ends_with?: Maybe<String>;
  ConnectorLongDesc_not_ends_with?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  CreatedDate?: Maybe<DateTimeInput>;
  CreatedDate_not?: Maybe<DateTimeInput>;
  CreatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_lt?: Maybe<DateTimeInput>;
  CreatedDate_lte?: Maybe<DateTimeInput>;
  CreatedDate_gt?: Maybe<DateTimeInput>;
  CreatedDate_gte?: Maybe<DateTimeInput>;
  ModifiedDate?: Maybe<DateTimeInput>;
  ModifiedDate_not?: Maybe<DateTimeInput>;
  ModifiedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_lt?: Maybe<DateTimeInput>;
  ModifiedDate_lte?: Maybe<DateTimeInput>;
  ModifiedDate_gt?: Maybe<DateTimeInput>;
  ModifiedDate_gte?: Maybe<DateTimeInput>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  Popular?: Maybe<Boolean>;
  Popular_not?: Maybe<Boolean>;
  Recent?: Maybe<Boolean>;
  Recent_not?: Maybe<Boolean>;
  testuser?: Maybe<String>;
  testuser_not?: Maybe<String>;
  testuser_in?: Maybe<String[] | String>;
  testuser_not_in?: Maybe<String[] | String>;
  testuser_lt?: Maybe<String>;
  testuser_lte?: Maybe<String>;
  testuser_gt?: Maybe<String>;
  testuser_gte?: Maybe<String>;
  testuser_contains?: Maybe<String>;
  testuser_not_contains?: Maybe<String>;
  testuser_starts_with?: Maybe<String>;
  testuser_not_starts_with?: Maybe<String>;
  testuser_ends_with?: Maybe<String>;
  testuser_not_ends_with?: Maybe<String>;
  PrimaryPluginId?: Maybe<PluginWhereInput>;
  SecondaryPluginId?: Maybe<PluginWhereInput>;
  AND?: Maybe<ConnectorWhereInput[] | ConnectorWhereInput>;
}

export interface EntityUpdateManyDataInput {
  EntityName?: Maybe<String>;
  EntityType?: Maybe<String>;
  EntityShortDesc?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ConnectUrl?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  Status?: Maybe<Status>;
}

export type SubscriberEntityMapWhereUniqueInput = AtLeastOne<{
  SubscriberEntityMapID: Maybe<ID_Input>;
}>;

export interface EntityMapUpdateManyMutationInput {
  Status?: Maybe<Status>;
  EntityShortDesc?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface ScheduleUpsertWithWhereUniqueWithoutSubscriberProcessInput {
  where: ScheduleWhereUniqueInput;
  update: ScheduleUpdateWithoutSubscriberProcessDataInput;
  create: ScheduleCreateWithoutSubscriberProcessInput;
}

export interface FieldCreateInput {
  FieldID?: Maybe<ID_Input>;
  PluginsID?: Maybe<PluginCreateOneInput>;
  EntityID?: Maybe<EntityCreateOneInput>;
  FieldName?: Maybe<String>;
  FieldShortDesc?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  DataType?: Maybe<String>;
  FieldType?: Maybe<String>;
  Status?: Maybe<Status>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface ScheduleUpdateWithWhereUniqueWithoutSubscriberProcessInput {
  where: ScheduleWhereUniqueInput;
  data: ScheduleUpdateWithoutSubscriberProcessDataInput;
}

export interface EntityCreateOneInput {
  create?: Maybe<EntityCreateInput>;
  connect?: Maybe<EntityWhereUniqueInput>;
}

export type EntityWhereUniqueInput = AtLeastOne<{
  EntityID: Maybe<ID_Input>;
}>;

export interface FieldUpdateInput {
  PluginsID?: Maybe<PluginUpdateOneInput>;
  EntityID?: Maybe<EntityUpdateOneInput>;
  FieldName?: Maybe<String>;
  FieldShortDesc?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  DataType?: Maybe<String>;
  FieldType?: Maybe<String>;
  Status?: Maybe<Status>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface PluginCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PluginCategoryWhereInput>;
  AND?: Maybe<
    | PluginCategorySubscriptionWhereInput[]
    | PluginCategorySubscriptionWhereInput
  >;
}

export interface EntityUpdateOneInput {
  create?: Maybe<EntityCreateInput>;
  update?: Maybe<EntityUpdateDataInput>;
  upsert?: Maybe<EntityUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EntityWhereUniqueInput>;
}

export interface TestimonialUpdateInput {
  Message?: Maybe<String>;
  Author?: Maybe<String>;
  Designation?: Maybe<String>;
  CompanyName?: Maybe<String>;
  ImageName?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface EntityUpsertNestedInput {
  update: EntityUpdateDataInput;
  create: EntityCreateInput;
}

export interface SubscriberProcessUpdateInput {
  ProcessId?: Maybe<ProcessUpdateOneInput>;
  TenantId?: Maybe<UserUpdateOneInput>;
  ConnectorId?: Maybe<ConnectorUpdateOneInput>;
  Status?: Maybe<Status>;
  Stage?: Maybe<Stage>;
  CreatedBy?: Maybe<String>;
  Schedule?: Maybe<ScheduleUpdateManyWithoutSubscriberProcessInput>;
  ModifiedBy?: Maybe<String>;
  LastSyncDate?: Maybe<String>;
  PrimaryEntity?: Maybe<EntityUpdateOneInput>;
  SecondaryEntity?: Maybe<EntityUpdateOneInput>;
}

export interface FieldUpdateManyMutationInput {
  FieldName?: Maybe<String>;
  FieldShortDesc?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  DataType?: Maybe<String>;
  FieldType?: Maybe<String>;
  Status?: Maybe<Status>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface ProcessSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProcessWhereInput>;
  AND?: Maybe<ProcessSubscriptionWhereInput[] | ProcessSubscriptionWhereInput>;
}

export interface FieldMapCreateInput {
  FieldMapID?: Maybe<ID_Input>;
  SourceEntityID?: Maybe<EntityCreateOneInput>;
  TargetEntityID?: Maybe<EntityCreateOneInput>;
  SourceField?: Maybe<FieldCreateManyInput>;
  TargetField?: Maybe<FieldCreateManyInput>;
  Status?: Maybe<Status>;
  FieldShortDesc?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface SubscriberEntityMapUpdateManyMutationInput {
  Status?: Maybe<Status>;
  EntityShortDesc?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface FieldCreateManyInput {
  create?: Maybe<FieldCreateInput[] | FieldCreateInput>;
  connect?: Maybe<FieldWhereUniqueInput[] | FieldWhereUniqueInput>;
}

export interface SubscriberEntityUpdateInput {
  PluginID?: Maybe<PluginUpdateOneInput>;
  EntityName?: Maybe<String>;
  EntityType?: Maybe<String>;
  EntityShortDesc?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  Status?: Maybe<Status>;
}

export interface FieldMapUpdateInput {
  SourceEntityID?: Maybe<EntityUpdateOneInput>;
  TargetEntityID?: Maybe<EntityUpdateOneInput>;
  SourceField?: Maybe<FieldUpdateManyInput>;
  TargetField?: Maybe<FieldUpdateManyInput>;
  Status?: Maybe<Status>;
  FieldShortDesc?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export type PluginParamWhereUniqueInput = AtLeastOne<{
  PluginParamID: Maybe<ID_Input>;
}>;

export interface FieldUpdateManyInput {
  create?: Maybe<FieldCreateInput[] | FieldCreateInput>;
  update?: Maybe<
    | FieldUpdateWithWhereUniqueNestedInput[]
    | FieldUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | FieldUpsertWithWhereUniqueNestedInput[]
    | FieldUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<FieldWhereUniqueInput[] | FieldWhereUniqueInput>;
  connect?: Maybe<FieldWhereUniqueInput[] | FieldWhereUniqueInput>;
  set?: Maybe<FieldWhereUniqueInput[] | FieldWhereUniqueInput>;
  disconnect?: Maybe<FieldWhereUniqueInput[] | FieldWhereUniqueInput>;
  deleteMany?: Maybe<FieldScalarWhereInput[] | FieldScalarWhereInput>;
  updateMany?: Maybe<
    FieldUpdateManyWithWhereNestedInput[] | FieldUpdateManyWithWhereNestedInput
  >;
}

export interface PluginCategoryWhereInput {
  CategoryID?: Maybe<ID_Input>;
  CategoryID_not?: Maybe<ID_Input>;
  CategoryID_in?: Maybe<ID_Input[] | ID_Input>;
  CategoryID_not_in?: Maybe<ID_Input[] | ID_Input>;
  CategoryID_lt?: Maybe<ID_Input>;
  CategoryID_lte?: Maybe<ID_Input>;
  CategoryID_gt?: Maybe<ID_Input>;
  CategoryID_gte?: Maybe<ID_Input>;
  CategoryID_contains?: Maybe<ID_Input>;
  CategoryID_not_contains?: Maybe<ID_Input>;
  CategoryID_starts_with?: Maybe<ID_Input>;
  CategoryID_not_starts_with?: Maybe<ID_Input>;
  CategoryID_ends_with?: Maybe<ID_Input>;
  CategoryID_not_ends_with?: Maybe<ID_Input>;
  CategoryName?: Maybe<String>;
  CategoryName_not?: Maybe<String>;
  CategoryName_in?: Maybe<String[] | String>;
  CategoryName_not_in?: Maybe<String[] | String>;
  CategoryName_lt?: Maybe<String>;
  CategoryName_lte?: Maybe<String>;
  CategoryName_gt?: Maybe<String>;
  CategoryName_gte?: Maybe<String>;
  CategoryName_contains?: Maybe<String>;
  CategoryName_not_contains?: Maybe<String>;
  CategoryName_starts_with?: Maybe<String>;
  CategoryName_not_starts_with?: Maybe<String>;
  CategoryName_ends_with?: Maybe<String>;
  CategoryName_not_ends_with?: Maybe<String>;
  CategoryDesc?: Maybe<String>;
  CategoryDesc_not?: Maybe<String>;
  CategoryDesc_in?: Maybe<String[] | String>;
  CategoryDesc_not_in?: Maybe<String[] | String>;
  CategoryDesc_lt?: Maybe<String>;
  CategoryDesc_lte?: Maybe<String>;
  CategoryDesc_gt?: Maybe<String>;
  CategoryDesc_gte?: Maybe<String>;
  CategoryDesc_contains?: Maybe<String>;
  CategoryDesc_not_contains?: Maybe<String>;
  CategoryDesc_starts_with?: Maybe<String>;
  CategoryDesc_not_starts_with?: Maybe<String>;
  CategoryDesc_ends_with?: Maybe<String>;
  CategoryDesc_not_ends_with?: Maybe<String>;
  AND?: Maybe<PluginCategoryWhereInput[] | PluginCategoryWhereInput>;
}

export interface FieldUpdateWithWhereUniqueNestedInput {
  where: FieldWhereUniqueInput;
  data: FieldUpdateDataInput;
}

export interface ScheduleCreateInput {
  ScheduleID?: Maybe<ID_Input>;
  TenantId?: Maybe<UserCreateOneInput>;
  ProcessId?: Maybe<ProcessCreateOneInput>;
  SubscriberProcess?: Maybe<SubscriberProcessCreateOneWithoutScheduleInput>;
  SubcriptionHistoryId?: Maybe<SubcriptionHistoryCreateOneInput>;
  Field?: Maybe<String>;
  Status?: Maybe<Stage>;
  DailyOccurence?: Maybe<String>;
  ScheduleType?: Maybe<String>;
  DailyRecurrenceType?: Maybe<String>;
  OccursAt?: Maybe<String>;
  DailyInterval?: Maybe<String>;
  DailyIntervalSpan?: Maybe<String>;
  WeekDays?: Maybe<ScheduleCreateWeekDaysInput>;
  DayofMonth?: Maybe<String>;
  LastExecuted?: Maybe<String>;
  NextOccurence?: Maybe<String>;
  SubscriptionIntegrationId?: Maybe<SubscriptionIntegrationCreateOneInput>;
  CreatedDate?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedDate?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  StartTime?: Maybe<String>;
  EndTime?: Maybe<String>;
  Type?: Maybe<String>;
}

export interface FieldUpdateDataInput {
  PluginsID?: Maybe<PluginUpdateOneInput>;
  EntityID?: Maybe<EntityUpdateOneInput>;
  FieldName?: Maybe<String>;
  FieldShortDesc?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  DataType?: Maybe<String>;
  FieldType?: Maybe<String>;
  Status?: Maybe<Status>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface PluginParamUpdateManyMutationInput {
  FieldType?: Maybe<String>;
  FieldName?: Maybe<String>;
  Caption?: Maybe<String>;
  Status?: Maybe<Status>;
  Required?: Maybe<Boolean>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface FieldUpsertWithWhereUniqueNestedInput {
  where: FieldWhereUniqueInput;
  update: FieldUpdateDataInput;
  create: FieldCreateInput;
}

export interface PluginCategoryUpdateInput {
  CategoryName?: Maybe<String>;
  CategoryDesc?: Maybe<String>;
}

export interface FieldScalarWhereInput {
  FieldID?: Maybe<ID_Input>;
  FieldID_not?: Maybe<ID_Input>;
  FieldID_in?: Maybe<ID_Input[] | ID_Input>;
  FieldID_not_in?: Maybe<ID_Input[] | ID_Input>;
  FieldID_lt?: Maybe<ID_Input>;
  FieldID_lte?: Maybe<ID_Input>;
  FieldID_gt?: Maybe<ID_Input>;
  FieldID_gte?: Maybe<ID_Input>;
  FieldID_contains?: Maybe<ID_Input>;
  FieldID_not_contains?: Maybe<ID_Input>;
  FieldID_starts_with?: Maybe<ID_Input>;
  FieldID_not_starts_with?: Maybe<ID_Input>;
  FieldID_ends_with?: Maybe<ID_Input>;
  FieldID_not_ends_with?: Maybe<ID_Input>;
  FieldName?: Maybe<String>;
  FieldName_not?: Maybe<String>;
  FieldName_in?: Maybe<String[] | String>;
  FieldName_not_in?: Maybe<String[] | String>;
  FieldName_lt?: Maybe<String>;
  FieldName_lte?: Maybe<String>;
  FieldName_gt?: Maybe<String>;
  FieldName_gte?: Maybe<String>;
  FieldName_contains?: Maybe<String>;
  FieldName_not_contains?: Maybe<String>;
  FieldName_starts_with?: Maybe<String>;
  FieldName_not_starts_with?: Maybe<String>;
  FieldName_ends_with?: Maybe<String>;
  FieldName_not_ends_with?: Maybe<String>;
  FieldShortDesc?: Maybe<String>;
  FieldShortDesc_not?: Maybe<String>;
  FieldShortDesc_in?: Maybe<String[] | String>;
  FieldShortDesc_not_in?: Maybe<String[] | String>;
  FieldShortDesc_lt?: Maybe<String>;
  FieldShortDesc_lte?: Maybe<String>;
  FieldShortDesc_gt?: Maybe<String>;
  FieldShortDesc_gte?: Maybe<String>;
  FieldShortDesc_contains?: Maybe<String>;
  FieldShortDesc_not_contains?: Maybe<String>;
  FieldShortDesc_starts_with?: Maybe<String>;
  FieldShortDesc_not_starts_with?: Maybe<String>;
  FieldShortDesc_ends_with?: Maybe<String>;
  FieldShortDesc_not_ends_with?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  FieldLongDesc_not?: Maybe<String>;
  FieldLongDesc_in?: Maybe<String[] | String>;
  FieldLongDesc_not_in?: Maybe<String[] | String>;
  FieldLongDesc_lt?: Maybe<String>;
  FieldLongDesc_lte?: Maybe<String>;
  FieldLongDesc_gt?: Maybe<String>;
  FieldLongDesc_gte?: Maybe<String>;
  FieldLongDesc_contains?: Maybe<String>;
  FieldLongDesc_not_contains?: Maybe<String>;
  FieldLongDesc_starts_with?: Maybe<String>;
  FieldLongDesc_not_starts_with?: Maybe<String>;
  FieldLongDesc_ends_with?: Maybe<String>;
  FieldLongDesc_not_ends_with?: Maybe<String>;
  DataType?: Maybe<String>;
  DataType_not?: Maybe<String>;
  DataType_in?: Maybe<String[] | String>;
  DataType_not_in?: Maybe<String[] | String>;
  DataType_lt?: Maybe<String>;
  DataType_lte?: Maybe<String>;
  DataType_gt?: Maybe<String>;
  DataType_gte?: Maybe<String>;
  DataType_contains?: Maybe<String>;
  DataType_not_contains?: Maybe<String>;
  DataType_starts_with?: Maybe<String>;
  DataType_not_starts_with?: Maybe<String>;
  DataType_ends_with?: Maybe<String>;
  DataType_not_ends_with?: Maybe<String>;
  FieldType?: Maybe<String>;
  FieldType_not?: Maybe<String>;
  FieldType_in?: Maybe<String[] | String>;
  FieldType_not_in?: Maybe<String[] | String>;
  FieldType_lt?: Maybe<String>;
  FieldType_lte?: Maybe<String>;
  FieldType_gt?: Maybe<String>;
  FieldType_gte?: Maybe<String>;
  FieldType_contains?: Maybe<String>;
  FieldType_not_contains?: Maybe<String>;
  FieldType_starts_with?: Maybe<String>;
  FieldType_not_starts_with?: Maybe<String>;
  FieldType_ends_with?: Maybe<String>;
  FieldType_not_ends_with?: Maybe<String>;
  Status?: Maybe<Status>;
  Status_not?: Maybe<Status>;
  Status_in?: Maybe<Status[] | Status>;
  Status_not_in?: Maybe<Status[] | Status>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  CreatedDate?: Maybe<DateTimeInput>;
  CreatedDate_not?: Maybe<DateTimeInput>;
  CreatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_lt?: Maybe<DateTimeInput>;
  CreatedDate_lte?: Maybe<DateTimeInput>;
  CreatedDate_gt?: Maybe<DateTimeInput>;
  CreatedDate_gte?: Maybe<DateTimeInput>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  ModifiedDate?: Maybe<DateTimeInput>;
  ModifiedDate_not?: Maybe<DateTimeInput>;
  ModifiedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_lt?: Maybe<DateTimeInput>;
  ModifiedDate_lte?: Maybe<DateTimeInput>;
  ModifiedDate_gt?: Maybe<DateTimeInput>;
  ModifiedDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FieldScalarWhereInput[] | FieldScalarWhereInput>;
  OR?: Maybe<FieldScalarWhereInput[] | FieldScalarWhereInput>;
  NOT?: Maybe<FieldScalarWhereInput[] | FieldScalarWhereInput>;
}

export interface ScheduleUpdateManyDataInput {
  Field?: Maybe<String>;
  Status?: Maybe<Stage>;
  DailyOccurence?: Maybe<String>;
  ScheduleType?: Maybe<String>;
  DailyRecurrenceType?: Maybe<String>;
  OccursAt?: Maybe<String>;
  DailyInterval?: Maybe<String>;
  DailyIntervalSpan?: Maybe<String>;
  WeekDays?: Maybe<ScheduleUpdateWeekDaysInput>;
  DayofMonth?: Maybe<String>;
  LastExecuted?: Maybe<String>;
  NextOccurence?: Maybe<String>;
  CreatedDate?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedDate?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  StartTime?: Maybe<String>;
  EndTime?: Maybe<String>;
  Type?: Maybe<String>;
}

export interface FieldUpdateManyWithWhereNestedInput {
  where: FieldScalarWhereInput;
  data: FieldUpdateManyDataInput;
}

export interface ScheduleUpdateWithoutSubscriberProcessDataInput {
  TenantId?: Maybe<UserUpdateOneInput>;
  ProcessId?: Maybe<ProcessUpdateOneInput>;
  SubcriptionHistoryId?: Maybe<SubcriptionHistoryUpdateOneInput>;
  Field?: Maybe<String>;
  Status?: Maybe<Stage>;
  DailyOccurence?: Maybe<String>;
  ScheduleType?: Maybe<String>;
  DailyRecurrenceType?: Maybe<String>;
  OccursAt?: Maybe<String>;
  DailyInterval?: Maybe<String>;
  DailyIntervalSpan?: Maybe<String>;
  WeekDays?: Maybe<ScheduleUpdateWeekDaysInput>;
  DayofMonth?: Maybe<String>;
  LastExecuted?: Maybe<String>;
  NextOccurence?: Maybe<String>;
  SubscriptionIntegrationId?: Maybe<SubscriptionIntegrationUpdateOneInput>;
  CreatedDate?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedDate?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  StartTime?: Maybe<String>;
  EndTime?: Maybe<String>;
  Type?: Maybe<String>;
}

export interface FieldUpdateManyDataInput {
  FieldName?: Maybe<String>;
  FieldShortDesc?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  DataType?: Maybe<String>;
  FieldType?: Maybe<String>;
  Status?: Maybe<Status>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export type EntityMapWhereUniqueInput = AtLeastOne<{
  EntityMapID: Maybe<ID_Input>;
}>;

export interface FieldMapUpdateManyMutationInput {
  Status?: Maybe<Status>;
  FieldShortDesc?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface FieldMapWhereInput {
  FieldMapID?: Maybe<ID_Input>;
  FieldMapID_not?: Maybe<ID_Input>;
  FieldMapID_in?: Maybe<ID_Input[] | ID_Input>;
  FieldMapID_not_in?: Maybe<ID_Input[] | ID_Input>;
  FieldMapID_lt?: Maybe<ID_Input>;
  FieldMapID_lte?: Maybe<ID_Input>;
  FieldMapID_gt?: Maybe<ID_Input>;
  FieldMapID_gte?: Maybe<ID_Input>;
  FieldMapID_contains?: Maybe<ID_Input>;
  FieldMapID_not_contains?: Maybe<ID_Input>;
  FieldMapID_starts_with?: Maybe<ID_Input>;
  FieldMapID_not_starts_with?: Maybe<ID_Input>;
  FieldMapID_ends_with?: Maybe<ID_Input>;
  FieldMapID_not_ends_with?: Maybe<ID_Input>;
  SourceEntityID?: Maybe<EntityWhereInput>;
  TargetEntityID?: Maybe<EntityWhereInput>;
  SourceField_some?: Maybe<FieldWhereInput>;
  TargetField_some?: Maybe<FieldWhereInput>;
  Status?: Maybe<Status>;
  Status_not?: Maybe<Status>;
  Status_in?: Maybe<Status[] | Status>;
  Status_not_in?: Maybe<Status[] | Status>;
  FieldShortDesc?: Maybe<String>;
  FieldShortDesc_not?: Maybe<String>;
  FieldShortDesc_in?: Maybe<String[] | String>;
  FieldShortDesc_not_in?: Maybe<String[] | String>;
  FieldShortDesc_lt?: Maybe<String>;
  FieldShortDesc_lte?: Maybe<String>;
  FieldShortDesc_gt?: Maybe<String>;
  FieldShortDesc_gte?: Maybe<String>;
  FieldShortDesc_contains?: Maybe<String>;
  FieldShortDesc_not_contains?: Maybe<String>;
  FieldShortDesc_starts_with?: Maybe<String>;
  FieldShortDesc_not_starts_with?: Maybe<String>;
  FieldShortDesc_ends_with?: Maybe<String>;
  FieldShortDesc_not_ends_with?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  FieldLongDesc_not?: Maybe<String>;
  FieldLongDesc_in?: Maybe<String[] | String>;
  FieldLongDesc_not_in?: Maybe<String[] | String>;
  FieldLongDesc_lt?: Maybe<String>;
  FieldLongDesc_lte?: Maybe<String>;
  FieldLongDesc_gt?: Maybe<String>;
  FieldLongDesc_gte?: Maybe<String>;
  FieldLongDesc_contains?: Maybe<String>;
  FieldLongDesc_not_contains?: Maybe<String>;
  FieldLongDesc_starts_with?: Maybe<String>;
  FieldLongDesc_not_starts_with?: Maybe<String>;
  FieldLongDesc_ends_with?: Maybe<String>;
  FieldLongDesc_not_ends_with?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  CreatedDate?: Maybe<DateTimeInput>;
  CreatedDate_not?: Maybe<DateTimeInput>;
  CreatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_lt?: Maybe<DateTimeInput>;
  CreatedDate_lte?: Maybe<DateTimeInput>;
  CreatedDate_gt?: Maybe<DateTimeInput>;
  CreatedDate_gte?: Maybe<DateTimeInput>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  ModifiedDate?: Maybe<DateTimeInput>;
  ModifiedDate_not?: Maybe<DateTimeInput>;
  ModifiedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_lt?: Maybe<DateTimeInput>;
  ModifiedDate_lte?: Maybe<DateTimeInput>;
  ModifiedDate_gt?: Maybe<DateTimeInput>;
  ModifiedDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FieldMapWhereInput[] | FieldMapWhereInput>;
}

export interface LogCreateInput {
  LogId?: Maybe<ID_Input>;
  SubcriptionHistoryId?: Maybe<SubcriptionHistoryCreateOneInput>;
  SubscriberProcess?: Maybe<SubscriberProcessCreateOneInput>;
  SubscriptionIntegrationId?: Maybe<SubscriptionIntegrationCreateOneInput>;
  ConnectorId?: Maybe<ConnectorCreateOneInput>;
  LogDate?: Maybe<DateTimeInput>;
  Thread?: Maybe<String>;
  Level?: Maybe<String>;
  ProcessId?: Maybe<ProcessCreateOneInput>;
  Operation?: Maybe<String>;
  Event?: Maybe<String>;
  Sourcekeyfields?: Maybe<String>;
  Sourcekeyvalue?: Maybe<String>;
  Targetkeyfields?: Maybe<String>;
  Targetkeyvalue?: Maybe<String>;
  Message?: Maybe<String>;
  Exceptions?: Maybe<String>;
  TenantId?: Maybe<UserCreateOneInput>;
}

export interface SubscriberProcessWhereInput {
  SubscriberProcessID?: Maybe<ID_Input>;
  SubscriberProcessID_not?: Maybe<ID_Input>;
  SubscriberProcessID_in?: Maybe<ID_Input[] | ID_Input>;
  SubscriberProcessID_not_in?: Maybe<ID_Input[] | ID_Input>;
  SubscriberProcessID_lt?: Maybe<ID_Input>;
  SubscriberProcessID_lte?: Maybe<ID_Input>;
  SubscriberProcessID_gt?: Maybe<ID_Input>;
  SubscriberProcessID_gte?: Maybe<ID_Input>;
  SubscriberProcessID_contains?: Maybe<ID_Input>;
  SubscriberProcessID_not_contains?: Maybe<ID_Input>;
  SubscriberProcessID_starts_with?: Maybe<ID_Input>;
  SubscriberProcessID_not_starts_with?: Maybe<ID_Input>;
  SubscriberProcessID_ends_with?: Maybe<ID_Input>;
  SubscriberProcessID_not_ends_with?: Maybe<ID_Input>;
  ProcessId?: Maybe<ProcessWhereInput>;
  TenantId?: Maybe<UserWhereInput>;
  ConnectorId?: Maybe<ConnectorWhereInput>;
  Status?: Maybe<Status>;
  Status_not?: Maybe<Status>;
  Status_in?: Maybe<Status[] | Status>;
  Status_not_in?: Maybe<Status[] | Status>;
  Stage?: Maybe<Stage>;
  Stage_not?: Maybe<Stage>;
  Stage_in?: Maybe<Stage[] | Stage>;
  Stage_not_in?: Maybe<Stage[] | Stage>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  Schedule_some?: Maybe<ScheduleWhereInput>;
  CreatedDate?: Maybe<DateTimeInput>;
  CreatedDate_not?: Maybe<DateTimeInput>;
  CreatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_lt?: Maybe<DateTimeInput>;
  CreatedDate_lte?: Maybe<DateTimeInput>;
  CreatedDate_gt?: Maybe<DateTimeInput>;
  CreatedDate_gte?: Maybe<DateTimeInput>;
  ModifiedDate?: Maybe<DateTimeInput>;
  ModifiedDate_not?: Maybe<DateTimeInput>;
  ModifiedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_lt?: Maybe<DateTimeInput>;
  ModifiedDate_lte?: Maybe<DateTimeInput>;
  ModifiedDate_gt?: Maybe<DateTimeInput>;
  ModifiedDate_gte?: Maybe<DateTimeInput>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  LastSyncDate?: Maybe<String>;
  LastSyncDate_not?: Maybe<String>;
  LastSyncDate_in?: Maybe<String[] | String>;
  LastSyncDate_not_in?: Maybe<String[] | String>;
  LastSyncDate_lt?: Maybe<String>;
  LastSyncDate_lte?: Maybe<String>;
  LastSyncDate_gt?: Maybe<String>;
  LastSyncDate_gte?: Maybe<String>;
  LastSyncDate_contains?: Maybe<String>;
  LastSyncDate_not_contains?: Maybe<String>;
  LastSyncDate_starts_with?: Maybe<String>;
  LastSyncDate_not_starts_with?: Maybe<String>;
  LastSyncDate_ends_with?: Maybe<String>;
  LastSyncDate_not_ends_with?: Maybe<String>;
  PrimaryEntity?: Maybe<EntityWhereInput>;
  SecondaryEntity?: Maybe<EntityWhereInput>;
  AND?: Maybe<SubscriberProcessWhereInput[] | SubscriberProcessWhereInput>;
}

export interface SubcriptionHistoryCreateOneInput {
  create?: Maybe<SubcriptionHistoryCreateInput>;
  connect?: Maybe<SubcriptionHistoryWhereUniqueInput>;
}

export interface SourceTargetFieldmappingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SourceTargetFieldmappingWhereInput>;
  AND?: Maybe<
    | SourceTargetFieldmappingSubscriptionWhereInput[]
    | SourceTargetFieldmappingSubscriptionWhereInput
  >;
}

export interface SubcriptionHistoryCreateInput {
  SubcriptionHistoryId?: Maybe<ID_Input>;
  TenantId?: Maybe<UserCreateOneInput>;
  ConnectorId?: Maybe<ConnectorCreateOneInput>;
  SubscriberID?: Maybe<SubscriptionIntegrationCreateOneInput>;
  SubcriptionHistoryName: String;
  PrimaryPluginID?: Maybe<PluginCreateOneInput>;
  SecondaryPluginID?: Maybe<PluginCreateOneInput>;
  Status?: Maybe<Status>;
  CreatedBy: String;
  ModifiedBy: String;
}

export type ProcessHistoryWhereUniqueInput = AtLeastOne<{
  ProcessHistoryId: Maybe<ID_Input>;
}>;

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface PluginParamCreateInput {
  PluginParamID?: Maybe<ID_Input>;
  FieldType?: Maybe<String>;
  FieldName?: Maybe<String>;
  Caption?: Maybe<String>;
  PluginID?: Maybe<PluginCreateOneInput>;
  Status?: Maybe<Status>;
  Required?: Maybe<Boolean>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface UserCreateInput {
  UserId?: Maybe<ID_Input>;
  FirstName?: Maybe<String>;
  LastName?: Maybe<String>;
  UserName?: Maybe<String>;
  Address?: Maybe<String>;
  PhoneNumber?: Maybe<String>;
  PhoneCode?: Maybe<String>;
  Email?: Maybe<String>;
  TenantId?: Maybe<String>;
  CompanyName?: Maybe<String>;
  ZipCode?: Maybe<String>;
  Country?: Maybe<String>;
  State?: Maybe<String>;
  City?: Maybe<String>;
  IsAdmin?: Maybe<String>;
  Password?: Maybe<String>;
  ConfirmPassword?: Maybe<String>;
}

export interface SubscriberEntityMapWhereInput {
  SubscriberEntityMapID?: Maybe<ID_Input>;
  SubscriberEntityMapID_not?: Maybe<ID_Input>;
  SubscriberEntityMapID_in?: Maybe<ID_Input[] | ID_Input>;
  SubscriberEntityMapID_not_in?: Maybe<ID_Input[] | ID_Input>;
  SubscriberEntityMapID_lt?: Maybe<ID_Input>;
  SubscriberEntityMapID_lte?: Maybe<ID_Input>;
  SubscriberEntityMapID_gt?: Maybe<ID_Input>;
  SubscriberEntityMapID_gte?: Maybe<ID_Input>;
  SubscriberEntityMapID_contains?: Maybe<ID_Input>;
  SubscriberEntityMapID_not_contains?: Maybe<ID_Input>;
  SubscriberEntityMapID_starts_with?: Maybe<ID_Input>;
  SubscriberEntityMapID_not_starts_with?: Maybe<ID_Input>;
  SubscriberEntityMapID_ends_with?: Maybe<ID_Input>;
  SubscriberEntityMapID_not_ends_with?: Maybe<ID_Input>;
  SourceEntityID_some?: Maybe<EntityWhereInput>;
  TargetEntityID_some?: Maybe<EntityWhereInput>;
  Status?: Maybe<Status>;
  Status_not?: Maybe<Status>;
  Status_in?: Maybe<Status[] | Status>;
  Status_not_in?: Maybe<Status[] | Status>;
  EntityShortDesc?: Maybe<String>;
  EntityShortDesc_not?: Maybe<String>;
  EntityShortDesc_in?: Maybe<String[] | String>;
  EntityShortDesc_not_in?: Maybe<String[] | String>;
  EntityShortDesc_lt?: Maybe<String>;
  EntityShortDesc_lte?: Maybe<String>;
  EntityShortDesc_gt?: Maybe<String>;
  EntityShortDesc_gte?: Maybe<String>;
  EntityShortDesc_contains?: Maybe<String>;
  EntityShortDesc_not_contains?: Maybe<String>;
  EntityShortDesc_starts_with?: Maybe<String>;
  EntityShortDesc_not_starts_with?: Maybe<String>;
  EntityShortDesc_ends_with?: Maybe<String>;
  EntityShortDesc_not_ends_with?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  EntityLongDesc_not?: Maybe<String>;
  EntityLongDesc_in?: Maybe<String[] | String>;
  EntityLongDesc_not_in?: Maybe<String[] | String>;
  EntityLongDesc_lt?: Maybe<String>;
  EntityLongDesc_lte?: Maybe<String>;
  EntityLongDesc_gt?: Maybe<String>;
  EntityLongDesc_gte?: Maybe<String>;
  EntityLongDesc_contains?: Maybe<String>;
  EntityLongDesc_not_contains?: Maybe<String>;
  EntityLongDesc_starts_with?: Maybe<String>;
  EntityLongDesc_not_starts_with?: Maybe<String>;
  EntityLongDesc_ends_with?: Maybe<String>;
  EntityLongDesc_not_ends_with?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  CreatedBy_not?: Maybe<String>;
  CreatedBy_in?: Maybe<String[] | String>;
  CreatedBy_not_in?: Maybe<String[] | String>;
  CreatedBy_lt?: Maybe<String>;
  CreatedBy_lte?: Maybe<String>;
  CreatedBy_gt?: Maybe<String>;
  CreatedBy_gte?: Maybe<String>;
  CreatedBy_contains?: Maybe<String>;
  CreatedBy_not_contains?: Maybe<String>;
  CreatedBy_starts_with?: Maybe<String>;
  CreatedBy_not_starts_with?: Maybe<String>;
  CreatedBy_ends_with?: Maybe<String>;
  CreatedBy_not_ends_with?: Maybe<String>;
  CreatedDate?: Maybe<DateTimeInput>;
  CreatedDate_not?: Maybe<DateTimeInput>;
  CreatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  CreatedDate_lt?: Maybe<DateTimeInput>;
  CreatedDate_lte?: Maybe<DateTimeInput>;
  CreatedDate_gt?: Maybe<DateTimeInput>;
  CreatedDate_gte?: Maybe<DateTimeInput>;
  ModifiedBy?: Maybe<String>;
  ModifiedBy_not?: Maybe<String>;
  ModifiedBy_in?: Maybe<String[] | String>;
  ModifiedBy_not_in?: Maybe<String[] | String>;
  ModifiedBy_lt?: Maybe<String>;
  ModifiedBy_lte?: Maybe<String>;
  ModifiedBy_gt?: Maybe<String>;
  ModifiedBy_gte?: Maybe<String>;
  ModifiedBy_contains?: Maybe<String>;
  ModifiedBy_not_contains?: Maybe<String>;
  ModifiedBy_starts_with?: Maybe<String>;
  ModifiedBy_not_starts_with?: Maybe<String>;
  ModifiedBy_ends_with?: Maybe<String>;
  ModifiedBy_not_ends_with?: Maybe<String>;
  ModifiedDate?: Maybe<DateTimeInput>;
  ModifiedDate_not?: Maybe<DateTimeInput>;
  ModifiedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ModifiedDate_lt?: Maybe<DateTimeInput>;
  ModifiedDate_lte?: Maybe<DateTimeInput>;
  ModifiedDate_gt?: Maybe<DateTimeInput>;
  ModifiedDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SubscriberEntityMapWhereInput[] | SubscriberEntityMapWhereInput>;
}

export interface ConnectorCreateOneInput {
  create?: Maybe<ConnectorCreateInput>;
  connect?: Maybe<ConnectorWhereUniqueInput>;
}

export interface UserUpdateInput {
  FirstName?: Maybe<String>;
  LastName?: Maybe<String>;
  UserName?: Maybe<String>;
  Address?: Maybe<String>;
  PhoneNumber?: Maybe<String>;
  PhoneCode?: Maybe<String>;
  Email?: Maybe<String>;
  TenantId?: Maybe<String>;
  CompanyName?: Maybe<String>;
  ZipCode?: Maybe<String>;
  Country?: Maybe<String>;
  State?: Maybe<String>;
  City?: Maybe<String>;
  IsAdmin?: Maybe<String>;
  Password?: Maybe<String>;
  ConfirmPassword?: Maybe<String>;
}

export interface SubscriptionIntegrationCreateOneInput {
  create?: Maybe<SubscriptionIntegrationCreateInput>;
  connect?: Maybe<SubscriptionIntegrationWhereUniqueInput>;
}

export interface SubscriberEntityMapCreateInput {
  SubscriberEntityMapID?: Maybe<ID_Input>;
  SourceEntityID?: Maybe<EntityCreateManyInput>;
  TargetEntityID?: Maybe<EntityCreateManyInput>;
  Status?: Maybe<Status>;
  EntityShortDesc?: Maybe<String>;
  EntityLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface ProcessCreateOneInput {
  create?: Maybe<ProcessCreateInput>;
  connect?: Maybe<ProcessWhereUniqueInput>;
}

export interface SubscriberProcessCreateInput {
  SubscriberProcessID?: Maybe<ID_Input>;
  ProcessId?: Maybe<ProcessCreateOneInput>;
  TenantId?: Maybe<UserCreateOneInput>;
  ConnectorId?: Maybe<ConnectorCreateOneInput>;
  Status?: Maybe<Status>;
  Stage?: Maybe<Stage>;
  CreatedBy?: Maybe<String>;
  Schedule?: Maybe<ScheduleCreateManyWithoutSubscriberProcessInput>;
  ModifiedBy?: Maybe<String>;
  LastSyncDate?: Maybe<String>;
  PrimaryEntity?: Maybe<EntityCreateOneInput>;
  SecondaryEntity?: Maybe<EntityCreateOneInput>;
}

export interface SubscriberProcessCreateOneInput {
  create?: Maybe<SubscriberProcessCreateInput>;
  connect?: Maybe<SubscriberProcessWhereUniqueInput>;
}

export interface SubscriptionIntegrationCreateInput {
  SubscriptionIntegrationId?: Maybe<ID_Input>;
  NoOfLicenses?: Maybe<String>;
  NoOfUsers?: Maybe<String>;
  Status?: Maybe<Status>;
  TenantId?: Maybe<UserCreateOneInput>;
  ConnectorId?: Maybe<ConnectorCreateOneInput>;
  SubscriptionEndDate?: Maybe<DateTimeInput>;
  PrimaryPluginConnectionData?: Maybe<ConnStrctjsonCreateManyInput>;
  SecondaryPluginConnectionData?: Maybe<ConnStrctjsonCreateManyInput>;
  ConfigStructure?: Maybe<EntityConnStrctjsonCreateManyInput>;
}

export interface ScheduleUpdateManyMutationInput {
  Field?: Maybe<String>;
  Status?: Maybe<Stage>;
  DailyOccurence?: Maybe<String>;
  ScheduleType?: Maybe<String>;
  DailyRecurrenceType?: Maybe<String>;
  OccursAt?: Maybe<String>;
  DailyInterval?: Maybe<String>;
  DailyIntervalSpan?: Maybe<String>;
  WeekDays?: Maybe<ScheduleUpdateWeekDaysInput>;
  DayofMonth?: Maybe<String>;
  LastExecuted?: Maybe<String>;
  NextOccurence?: Maybe<String>;
  CreatedDate?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedDate?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
  StartTime?: Maybe<String>;
  EndTime?: Maybe<String>;
  Type?: Maybe<String>;
}

export interface SubscriberFieldMapCreateInput {
  SubscriberFieldMapID?: Maybe<ID_Input>;
  SourceEntityID?: Maybe<EntityCreateOneInput>;
  TargetEntityID?: Maybe<EntityCreateOneInput>;
  SourceField?: Maybe<FieldCreateManyInput>;
  TargetField?: Maybe<FieldCreateManyInput>;
  Status?: Maybe<Status>;
  FieldShortDesc?: Maybe<String>;
  FieldLongDesc?: Maybe<String>;
  CreatedBy?: Maybe<String>;
  ModifiedBy?: Maybe<String>;
}

export interface FieldMapSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FieldMapWhereInput>;
  AND?: Maybe<
    FieldMapSubscriptionWhereInput[] | FieldMapSubscriptionWhereInput
  >;
}

export interface LogUpdateManyMutationInput {
  LogDate?: Maybe<DateTimeInput>;
  Thread?: Maybe<String>;
  Level?: Maybe<String>;
  Operation?: Maybe<String>;
  Event?: Maybe<String>;
  Sourcekeyfields?: Maybe<String>;
  Sourcekeyvalue?: Maybe<String>;
  Targetkeyfields?: Maybe<String>;
  Targetkeyvalue?: Maybe<String>;
  Message?: Maybe<String>;
  Exceptions?: Maybe<String>;
}

export interface ProcessHistoryCreateInput {
  ProcessHistoryId?: Maybe<ID_Input>;
  ProcessId?: Maybe<ProcessCreateOneInput>;
  TenantId?: Maybe<UserCreateOneInput>;
  LastSyncDate?: Maybe<String>;
  Stage?: Maybe<Stage>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  UserId: ID_Output;
  FirstName?: String;
  LastName?: String;
  UserName?: String;
  Address?: String;
  PhoneNumber?: String;
  PhoneCode?: String;
  Email?: String;
  TenantId?: String;
  CompanyName?: String;
  ZipCode?: String;
  Country?: String;
  State?: String;
  City?: String;
  IsAdmin?: String;
  Password?: String;
  ConfirmPassword?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  UserId: () => Promise<ID_Output>;
  FirstName: () => Promise<String>;
  LastName: () => Promise<String>;
  UserName: () => Promise<String>;
  Address: () => Promise<String>;
  PhoneNumber: () => Promise<String>;
  PhoneCode: () => Promise<String>;
  Email: () => Promise<String>;
  TenantId: () => Promise<String>;
  CompanyName: () => Promise<String>;
  ZipCode: () => Promise<String>;
  Country: () => Promise<String>;
  State: () => Promise<String>;
  City: () => Promise<String>;
  IsAdmin: () => Promise<String>;
  Password: () => Promise<String>;
  ConfirmPassword: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  UserId: () => Promise<AsyncIterator<ID_Output>>;
  FirstName: () => Promise<AsyncIterator<String>>;
  LastName: () => Promise<AsyncIterator<String>>;
  UserName: () => Promise<AsyncIterator<String>>;
  Address: () => Promise<AsyncIterator<String>>;
  PhoneNumber: () => Promise<AsyncIterator<String>>;
  PhoneCode: () => Promise<AsyncIterator<String>>;
  Email: () => Promise<AsyncIterator<String>>;
  TenantId: () => Promise<AsyncIterator<String>>;
  CompanyName: () => Promise<AsyncIterator<String>>;
  ZipCode: () => Promise<AsyncIterator<String>>;
  Country: () => Promise<AsyncIterator<String>>;
  State: () => Promise<AsyncIterator<String>>;
  City: () => Promise<AsyncIterator<String>>;
  IsAdmin: () => Promise<AsyncIterator<String>>;
  Password: () => Promise<AsyncIterator<String>>;
  ConfirmPassword: () => Promise<AsyncIterator<String>>;
}

export interface FieldMap {
  FieldMapID: ID_Output;
  Status?: Status;
  FieldShortDesc?: String;
  FieldLongDesc?: String;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
}

export interface FieldMapPromise extends Promise<FieldMap>, Fragmentable {
  FieldMapID: () => Promise<ID_Output>;
  SourceEntityID: <T = EntityPromise>() => T;
  TargetEntityID: <T = EntityPromise>() => T;
  SourceField: <T = FragmentableArray<Field>>(args?: {
    where?: FieldWhereInput;
    orderBy?: FieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  TargetField: <T = FragmentableArray<Field>>(args?: {
    where?: FieldWhereInput;
    orderBy?: FieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  Status: () => Promise<Status>;
  FieldShortDesc: () => Promise<String>;
  FieldLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface FieldMapSubscription
  extends Promise<AsyncIterator<FieldMap>>,
    Fragmentable {
  FieldMapID: () => Promise<AsyncIterator<ID_Output>>;
  SourceEntityID: <T = EntitySubscription>() => T;
  TargetEntityID: <T = EntitySubscription>() => T;
  SourceField: <T = Promise<AsyncIterator<FieldSubscription>>>(args?: {
    where?: FieldWhereInput;
    orderBy?: FieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  TargetField: <T = Promise<AsyncIterator<FieldSubscription>>>(args?: {
    where?: FieldWhereInput;
    orderBy?: FieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  Status: () => Promise<AsyncIterator<Status>>;
  FieldShortDesc: () => Promise<AsyncIterator<String>>;
  FieldLongDesc: () => Promise<AsyncIterator<String>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FieldMapNullablePromise
  extends Promise<FieldMap | null>,
    Fragmentable {
  FieldMapID: () => Promise<ID_Output>;
  SourceEntityID: <T = EntityPromise>() => T;
  TargetEntityID: <T = EntityPromise>() => T;
  SourceField: <T = FragmentableArray<Field>>(args?: {
    where?: FieldWhereInput;
    orderBy?: FieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  TargetField: <T = FragmentableArray<Field>>(args?: {
    where?: FieldWhereInput;
    orderBy?: FieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  Status: () => Promise<Status>;
  FieldShortDesc: () => Promise<String>;
  FieldLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface Connector {
  ConnectorId: ID_Output;
  Status?: Status;
  ConnectorTitle?: String;
  ConnectorShortName?: String;
  ConnectorSEOName?: String;
  ConnectorShortDesc?: String;
  ConnectorLongDesc?: String;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedDate?: DateTimeOutput;
  ModifiedBy?: String;
  Popular?: Boolean;
  Recent?: Boolean;
  testuser?: String;
}

export interface ConnectorPromise extends Promise<Connector>, Fragmentable {
  ConnectorId: () => Promise<ID_Output>;
  Status: () => Promise<Status>;
  ConnectorTitle: () => Promise<String>;
  ConnectorShortName: () => Promise<String>;
  ConnectorSEOName: () => Promise<String>;
  ConnectorShortDesc: () => Promise<String>;
  ConnectorLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  Popular: () => Promise<Boolean>;
  Recent: () => Promise<Boolean>;
  testuser: () => Promise<String>;
  PrimaryPluginId: <T = PluginPromise>() => T;
  SecondaryPluginId: <T = PluginPromise>() => T;
}

export interface ConnectorSubscription
  extends Promise<AsyncIterator<Connector>>,
    Fragmentable {
  ConnectorId: () => Promise<AsyncIterator<ID_Output>>;
  Status: () => Promise<AsyncIterator<Status>>;
  ConnectorTitle: () => Promise<AsyncIterator<String>>;
  ConnectorShortName: () => Promise<AsyncIterator<String>>;
  ConnectorSEOName: () => Promise<AsyncIterator<String>>;
  ConnectorShortDesc: () => Promise<AsyncIterator<String>>;
  ConnectorLongDesc: () => Promise<AsyncIterator<String>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  Popular: () => Promise<AsyncIterator<Boolean>>;
  Recent: () => Promise<AsyncIterator<Boolean>>;
  testuser: () => Promise<AsyncIterator<String>>;
  PrimaryPluginId: <T = PluginSubscription>() => T;
  SecondaryPluginId: <T = PluginSubscription>() => T;
}

export interface ConnectorNullablePromise
  extends Promise<Connector | null>,
    Fragmentable {
  ConnectorId: () => Promise<ID_Output>;
  Status: () => Promise<Status>;
  ConnectorTitle: () => Promise<String>;
  ConnectorShortName: () => Promise<String>;
  ConnectorSEOName: () => Promise<String>;
  ConnectorShortDesc: () => Promise<String>;
  ConnectorLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  Popular: () => Promise<Boolean>;
  Recent: () => Promise<Boolean>;
  testuser: () => Promise<String>;
  PrimaryPluginId: <T = PluginPromise>() => T;
  SecondaryPluginId: <T = PluginPromise>() => T;
}

export interface AggregateField {
  count: Int;
}

export interface AggregateFieldPromise
  extends Promise<AggregateField>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFieldSubscription
  extends Promise<AsyncIterator<AggregateField>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FieldEdge {
  node: Field;
  cursor: String;
}

export interface FieldEdgePromise extends Promise<FieldEdge>, Fragmentable {
  node: <T = FieldPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FieldEdgeSubscription
  extends Promise<AsyncIterator<FieldEdge>>,
    Fragmentable {
  node: <T = FieldSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FieldConnection {
  pageInfo: PageInfo;
  edges: FieldEdge[];
}

export interface FieldConnectionPromise
  extends Promise<FieldConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FieldEdge>>() => T;
  aggregate: <T = AggregateFieldPromise>() => T;
}

export interface FieldConnectionSubscription
  extends Promise<AsyncIterator<FieldConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FieldEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFieldSubscription>() => T;
}

export interface AggregateTestimonial {
  count: Int;
}

export interface AggregateTestimonialPromise
  extends Promise<AggregateTestimonial>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTestimonialSubscription
  extends Promise<AsyncIterator<AggregateTestimonial>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Field {
  FieldID: ID_Output;
  FieldName?: String;
  FieldShortDesc?: String;
  FieldLongDesc?: String;
  DataType?: String;
  FieldType?: String;
  Status?: Status;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
}

export interface FieldPromise extends Promise<Field>, Fragmentable {
  FieldID: () => Promise<ID_Output>;
  PluginsID: <T = PluginPromise>() => T;
  EntityID: <T = EntityPromise>() => T;
  FieldName: () => Promise<String>;
  FieldShortDesc: () => Promise<String>;
  FieldLongDesc: () => Promise<String>;
  DataType: () => Promise<String>;
  FieldType: () => Promise<String>;
  Status: () => Promise<Status>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface FieldSubscription
  extends Promise<AsyncIterator<Field>>,
    Fragmentable {
  FieldID: () => Promise<AsyncIterator<ID_Output>>;
  PluginsID: <T = PluginSubscription>() => T;
  EntityID: <T = EntitySubscription>() => T;
  FieldName: () => Promise<AsyncIterator<String>>;
  FieldShortDesc: () => Promise<AsyncIterator<String>>;
  FieldLongDesc: () => Promise<AsyncIterator<String>>;
  DataType: () => Promise<AsyncIterator<String>>;
  FieldType: () => Promise<AsyncIterator<String>>;
  Status: () => Promise<AsyncIterator<Status>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FieldNullablePromise
  extends Promise<Field | null>,
    Fragmentable {
  FieldID: () => Promise<ID_Output>;
  PluginsID: <T = PluginPromise>() => T;
  EntityID: <T = EntityPromise>() => T;
  FieldName: () => Promise<String>;
  FieldShortDesc: () => Promise<String>;
  FieldLongDesc: () => Promise<String>;
  DataType: () => Promise<String>;
  FieldType: () => Promise<String>;
  Status: () => Promise<Status>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface TestimonialConnection {
  pageInfo: PageInfo;
  edges: TestimonialEdge[];
}

export interface TestimonialConnectionPromise
  extends Promise<TestimonialConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TestimonialEdge>>() => T;
  aggregate: <T = AggregateTestimonialPromise>() => T;
}

export interface TestimonialConnectionSubscription
  extends Promise<AsyncIterator<TestimonialConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TestimonialEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTestimonialSubscription>() => T;
}

export interface AggregateEntityMap {
  count: Int;
}

export interface AggregateEntityMapPromise
  extends Promise<AggregateEntityMap>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEntityMapSubscription
  extends Promise<AsyncIterator<AggregateEntityMap>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateSubscriptionIntegration {
  count: Int;
}

export interface AggregateSubscriptionIntegrationPromise
  extends Promise<AggregateSubscriptionIntegration>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubscriptionIntegrationSubscription
  extends Promise<AsyncIterator<AggregateSubscriptionIntegration>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EntityMapEdge {
  node: EntityMap;
  cursor: String;
}

export interface EntityMapEdgePromise
  extends Promise<EntityMapEdge>,
    Fragmentable {
  node: <T = EntityMapPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EntityMapEdgeSubscription
  extends Promise<AsyncIterator<EntityMapEdge>>,
    Fragmentable {
  node: <T = EntityMapSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SubscriptionIntegrationConnection {
  pageInfo: PageInfo;
  edges: SubscriptionIntegrationEdge[];
}

export interface SubscriptionIntegrationConnectionPromise
  extends Promise<SubscriptionIntegrationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubscriptionIntegrationEdge>>() => T;
  aggregate: <T = AggregateSubscriptionIntegrationPromise>() => T;
}

export interface SubscriptionIntegrationConnectionSubscription
  extends Promise<AsyncIterator<SubscriptionIntegrationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<SubscriptionIntegrationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateSubscriptionIntegrationSubscription>() => T;
}

export interface EntityMapConnection {
  pageInfo: PageInfo;
  edges: EntityMapEdge[];
}

export interface EntityMapConnectionPromise
  extends Promise<EntityMapConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EntityMapEdge>>() => T;
  aggregate: <T = AggregateEntityMapPromise>() => T;
}

export interface EntityMapConnectionSubscription
  extends Promise<AsyncIterator<EntityMapConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EntityMapEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEntityMapSubscription>() => T;
}

export interface SubscriberProcessEdge {
  node: SubscriberProcess;
  cursor: String;
}

export interface SubscriberProcessEdgePromise
  extends Promise<SubscriberProcessEdge>,
    Fragmentable {
  node: <T = SubscriberProcessPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubscriberProcessEdgeSubscription
  extends Promise<AsyncIterator<SubscriberProcessEdge>>,
    Fragmentable {
  node: <T = SubscriberProcessSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ConnectorSubscriptionPayload {
  mutation: MutationType;
  node: Connector;
  updatedFields: String[];
  previousValues: ConnectorPreviousValues;
}

export interface ConnectorSubscriptionPayloadPromise
  extends Promise<ConnectorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ConnectorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ConnectorPreviousValuesPromise>() => T;
}

export interface ConnectorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ConnectorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ConnectorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ConnectorPreviousValuesSubscription>() => T;
}

export interface AggregateSubscriberFieldMap {
  count: Int;
}

export interface AggregateSubscriberFieldMapPromise
  extends Promise<AggregateSubscriberFieldMap>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubscriberFieldMapSubscription
  extends Promise<AsyncIterator<AggregateSubscriberFieldMap>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ConnectorPreviousValues {
  ConnectorId: ID_Output;
  Status?: Status;
  ConnectorTitle?: String;
  ConnectorShortName?: String;
  ConnectorSEOName?: String;
  ConnectorShortDesc?: String;
  ConnectorLongDesc?: String;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedDate?: DateTimeOutput;
  ModifiedBy?: String;
  Popular?: Boolean;
  Recent?: Boolean;
  testuser?: String;
}

export interface ConnectorPreviousValuesPromise
  extends Promise<ConnectorPreviousValues>,
    Fragmentable {
  ConnectorId: () => Promise<ID_Output>;
  Status: () => Promise<Status>;
  ConnectorTitle: () => Promise<String>;
  ConnectorShortName: () => Promise<String>;
  ConnectorSEOName: () => Promise<String>;
  ConnectorShortDesc: () => Promise<String>;
  ConnectorLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  Popular: () => Promise<Boolean>;
  Recent: () => Promise<Boolean>;
  testuser: () => Promise<String>;
}

export interface ConnectorPreviousValuesSubscription
  extends Promise<AsyncIterator<ConnectorPreviousValues>>,
    Fragmentable {
  ConnectorId: () => Promise<AsyncIterator<ID_Output>>;
  Status: () => Promise<AsyncIterator<Status>>;
  ConnectorTitle: () => Promise<AsyncIterator<String>>;
  ConnectorShortName: () => Promise<AsyncIterator<String>>;
  ConnectorSEOName: () => Promise<AsyncIterator<String>>;
  ConnectorShortDesc: () => Promise<AsyncIterator<String>>;
  ConnectorLongDesc: () => Promise<AsyncIterator<String>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  Popular: () => Promise<AsyncIterator<Boolean>>;
  Recent: () => Promise<AsyncIterator<Boolean>>;
  testuser: () => Promise<AsyncIterator<String>>;
}

export interface SubscriberFieldMapConnection {
  pageInfo: PageInfo;
  edges: SubscriberFieldMapEdge[];
}

export interface SubscriberFieldMapConnectionPromise
  extends Promise<SubscriberFieldMapConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubscriberFieldMapEdge>>() => T;
  aggregate: <T = AggregateSubscriberFieldMapPromise>() => T;
}

export interface SubscriberFieldMapConnectionSubscription
  extends Promise<AsyncIterator<SubscriberFieldMapConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<SubscriberFieldMapEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateSubscriberFieldMapSubscription>() => T;
}

export interface EntityMap {
  EntityMapID: ID_Output;
  Status?: Status;
  EntityShortDesc?: String;
  EntityLongDesc?: String;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
}

export interface EntityMapPromise extends Promise<EntityMap>, Fragmentable {
  EntityMapID: () => Promise<ID_Output>;
  SourceEntityID: <T = FragmentableArray<Entity>>(args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  TargetEntityID: <T = FragmentableArray<Entity>>(args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  Status: () => Promise<Status>;
  EntityShortDesc: () => Promise<String>;
  EntityLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface EntityMapSubscription
  extends Promise<AsyncIterator<EntityMap>>,
    Fragmentable {
  EntityMapID: () => Promise<AsyncIterator<ID_Output>>;
  SourceEntityID: <T = Promise<AsyncIterator<EntitySubscription>>>(args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  TargetEntityID: <T = Promise<AsyncIterator<EntitySubscription>>>(args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  Status: () => Promise<AsyncIterator<Status>>;
  EntityShortDesc: () => Promise<AsyncIterator<String>>;
  EntityLongDesc: () => Promise<AsyncIterator<String>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EntityMapNullablePromise
  extends Promise<EntityMap | null>,
    Fragmentable {
  EntityMapID: () => Promise<ID_Output>;
  SourceEntityID: <T = FragmentableArray<Entity>>(args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  TargetEntityID: <T = FragmentableArray<Entity>>(args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  Status: () => Promise<Status>;
  EntityShortDesc: () => Promise<String>;
  EntityLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface AggregateSubscriberField {
  count: Int;
}

export interface AggregateSubscriberFieldPromise
  extends Promise<AggregateSubscriberField>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubscriberFieldSubscription
  extends Promise<AsyncIterator<AggregateSubscriberField>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DatabaseUserSubscriptionPayload {
  mutation: MutationType;
  node: DatabaseUser;
  updatedFields: String[];
  previousValues: DatabaseUserPreviousValues;
}

export interface DatabaseUserSubscriptionPayloadPromise
  extends Promise<DatabaseUserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DatabaseUserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DatabaseUserPreviousValuesPromise>() => T;
}

export interface DatabaseUserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DatabaseUserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DatabaseUserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DatabaseUserPreviousValuesSubscription>() => T;
}

export interface SubscriberFieldConnection {
  pageInfo: PageInfo;
  edges: SubscriberFieldEdge[];
}

export interface SubscriberFieldConnectionPromise
  extends Promise<SubscriberFieldConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubscriberFieldEdge>>() => T;
  aggregate: <T = AggregateSubscriberFieldPromise>() => T;
}

export interface SubscriberFieldConnectionSubscription
  extends Promise<AsyncIterator<SubscriberFieldConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubscriberFieldEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubscriberFieldSubscription>() => T;
}

export interface DatabaseUserPreviousValues {
  UserId: ID_Output;
  Name: String;
  Password: String;
  Claims?: DBClaims;
  Token?: String;
}

export interface DatabaseUserPreviousValuesPromise
  extends Promise<DatabaseUserPreviousValues>,
    Fragmentable {
  UserId: () => Promise<ID_Output>;
  Name: () => Promise<String>;
  Password: () => Promise<String>;
  Claims: () => Promise<DBClaims>;
  Token: () => Promise<String>;
}

export interface DatabaseUserPreviousValuesSubscription
  extends Promise<AsyncIterator<DatabaseUserPreviousValues>>,
    Fragmentable {
  UserId: () => Promise<AsyncIterator<ID_Output>>;
  Name: () => Promise<AsyncIterator<String>>;
  Password: () => Promise<AsyncIterator<String>>;
  Claims: () => Promise<AsyncIterator<DBClaims>>;
  Token: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSubscriberEntityMap {
  count: Int;
}

export interface AggregateSubscriberEntityMapPromise
  extends Promise<AggregateSubscriberEntityMap>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubscriberEntityMapSubscription
  extends Promise<AsyncIterator<AggregateSubscriberEntityMap>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateEntity {
  count: Int;
}

export interface AggregateEntityPromise
  extends Promise<AggregateEntity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEntitySubscription
  extends Promise<AsyncIterator<AggregateEntity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubscriberEntityMapConnection {
  pageInfo: PageInfo;
  edges: SubscriberEntityMapEdge[];
}

export interface SubscriberEntityMapConnectionPromise
  extends Promise<SubscriberEntityMapConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubscriberEntityMapEdge>>() => T;
  aggregate: <T = AggregateSubscriberEntityMapPromise>() => T;
}

export interface SubscriberEntityMapConnectionSubscription
  extends Promise<AsyncIterator<SubscriberEntityMapConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<SubscriberEntityMapEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateSubscriberEntityMapSubscription>() => T;
}

export interface EntitySubscriptionPayload {
  mutation: MutationType;
  node: Entity;
  updatedFields: String[];
  previousValues: EntityPreviousValues;
}

export interface EntitySubscriptionPayloadPromise
  extends Promise<EntitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EntityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EntityPreviousValuesPromise>() => T;
}

export interface EntitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EntitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EntitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EntityPreviousValuesSubscription>() => T;
}

export interface AggregateSubscriberEntity {
  count: Int;
}

export interface AggregateSubscriberEntityPromise
  extends Promise<AggregateSubscriberEntity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubscriberEntitySubscription
  extends Promise<AsyncIterator<AggregateSubscriberEntity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EntityPreviousValues {
  EntityID: ID_Output;
  EntityName?: String;
  EntityType?: String;
  EntityShortDesc?: String;
  EntityLongDesc?: String;
  CreatedBy?: String;
  ConnectUrl?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
  Status?: Status;
}

export interface EntityPreviousValuesPromise
  extends Promise<EntityPreviousValues>,
    Fragmentable {
  EntityID: () => Promise<ID_Output>;
  EntityName: () => Promise<String>;
  EntityType: () => Promise<String>;
  EntityShortDesc: () => Promise<String>;
  EntityLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  ConnectUrl: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  Status: () => Promise<Status>;
}

export interface EntityPreviousValuesSubscription
  extends Promise<AsyncIterator<EntityPreviousValues>>,
    Fragmentable {
  EntityID: () => Promise<AsyncIterator<ID_Output>>;
  EntityName: () => Promise<AsyncIterator<String>>;
  EntityType: () => Promise<AsyncIterator<String>>;
  EntityShortDesc: () => Promise<AsyncIterator<String>>;
  EntityLongDesc: () => Promise<AsyncIterator<String>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  ConnectUrl: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  Status: () => Promise<AsyncIterator<Status>>;
}

export interface SubscriberEntityConnection {
  pageInfo: PageInfo;
  edges: SubscriberEntityEdge[];
}

export interface SubscriberEntityConnectionPromise
  extends Promise<SubscriberEntityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubscriberEntityEdge>>() => T;
  aggregate: <T = AggregateSubscriberEntityPromise>() => T;
}

export interface SubscriberEntityConnectionSubscription
  extends Promise<AsyncIterator<SubscriberEntityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubscriberEntityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubscriberEntitySubscription>() => T;
}

export interface EntityEdge {
  node: Entity;
  cursor: String;
}

export interface EntityEdgePromise extends Promise<EntityEdge>, Fragmentable {
  node: <T = EntityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EntityEdgeSubscription
  extends Promise<AsyncIterator<EntityEdge>>,
    Fragmentable {
  node: <T = EntitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSubcriptionHistory {
  count: Int;
}

export interface AggregateSubcriptionHistoryPromise
  extends Promise<AggregateSubcriptionHistory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubcriptionHistorySubscription
  extends Promise<AsyncIterator<AggregateSubcriptionHistory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EntityMapSubscriptionPayload {
  mutation: MutationType;
  node: EntityMap;
  updatedFields: String[];
  previousValues: EntityMapPreviousValues;
}

export interface EntityMapSubscriptionPayloadPromise
  extends Promise<EntityMapSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EntityMapPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EntityMapPreviousValuesPromise>() => T;
}

export interface EntityMapSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EntityMapSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EntityMapSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EntityMapPreviousValuesSubscription>() => T;
}

export interface SubcriptionHistoryConnection {
  pageInfo: PageInfo;
  edges: SubcriptionHistoryEdge[];
}

export interface SubcriptionHistoryConnectionPromise
  extends Promise<SubcriptionHistoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubcriptionHistoryEdge>>() => T;
  aggregate: <T = AggregateSubcriptionHistoryPromise>() => T;
}

export interface SubcriptionHistoryConnectionSubscription
  extends Promise<AsyncIterator<SubcriptionHistoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<SubcriptionHistoryEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateSubcriptionHistorySubscription>() => T;
}

export interface EntityMapPreviousValues {
  EntityMapID: ID_Output;
  Status?: Status;
  EntityShortDesc?: String;
  EntityLongDesc?: String;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
}

export interface EntityMapPreviousValuesPromise
  extends Promise<EntityMapPreviousValues>,
    Fragmentable {
  EntityMapID: () => Promise<ID_Output>;
  Status: () => Promise<Status>;
  EntityShortDesc: () => Promise<String>;
  EntityLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface EntityMapPreviousValuesSubscription
  extends Promise<AsyncIterator<EntityMapPreviousValues>>,
    Fragmentable {
  EntityMapID: () => Promise<AsyncIterator<ID_Output>>;
  Status: () => Promise<AsyncIterator<Status>>;
  EntityShortDesc: () => Promise<AsyncIterator<String>>;
  EntityLongDesc: () => Promise<AsyncIterator<String>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SourceTargetFieldmappingEdge {
  node: SourceTargetFieldmapping;
  cursor: String;
}

export interface SourceTargetFieldmappingEdgePromise
  extends Promise<SourceTargetFieldmappingEdge>,
    Fragmentable {
  node: <T = SourceTargetFieldmappingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SourceTargetFieldmappingEdgeSubscription
  extends Promise<AsyncIterator<SourceTargetFieldmappingEdge>>,
    Fragmentable {
  node: <T = SourceTargetFieldmappingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EntityConnection {
  pageInfo: PageInfo;
  edges: EntityEdge[];
}

export interface EntityConnectionPromise
  extends Promise<EntityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EntityEdge>>() => T;
  aggregate: <T = AggregateEntityPromise>() => T;
}

export interface EntityConnectionSubscription
  extends Promise<AsyncIterator<EntityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EntityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEntitySubscription>() => T;
}

export interface SourceTargetFieldmapping {
  SourceTargetFieldmappingID: ID_Output;
  FieldShortDesc?: String;
  FieldLongDesc?: String;
  SourceKey?: String;
  SourceKeyValue?: String;
  TargetKey?: String;
  TargetKeyValue?: String;
  OtherParam?: String;
}

export interface SourceTargetFieldmappingPromise
  extends Promise<SourceTargetFieldmapping>,
    Fragmentable {
  SourceTargetFieldmappingID: () => Promise<ID_Output>;
  Entity: <T = EntityPromise>() => T;
  Connector: <T = ConnectorPromise>() => T;
  TenantId: <T = UserPromise>() => T;
  FieldShortDesc: () => Promise<String>;
  FieldLongDesc: () => Promise<String>;
  SourceKey: () => Promise<String>;
  SourceKeyValue: () => Promise<String>;
  TargetKey: () => Promise<String>;
  TargetKeyValue: () => Promise<String>;
  OtherParam: () => Promise<String>;
}

export interface SourceTargetFieldmappingSubscription
  extends Promise<AsyncIterator<SourceTargetFieldmapping>>,
    Fragmentable {
  SourceTargetFieldmappingID: () => Promise<AsyncIterator<ID_Output>>;
  Entity: <T = EntitySubscription>() => T;
  Connector: <T = ConnectorSubscription>() => T;
  TenantId: <T = UserSubscription>() => T;
  FieldShortDesc: () => Promise<AsyncIterator<String>>;
  FieldLongDesc: () => Promise<AsyncIterator<String>>;
  SourceKey: () => Promise<AsyncIterator<String>>;
  SourceKeyValue: () => Promise<AsyncIterator<String>>;
  TargetKey: () => Promise<AsyncIterator<String>>;
  TargetKeyValue: () => Promise<AsyncIterator<String>>;
  OtherParam: () => Promise<AsyncIterator<String>>;
}

export interface SourceTargetFieldmappingNullablePromise
  extends Promise<SourceTargetFieldmapping | null>,
    Fragmentable {
  SourceTargetFieldmappingID: () => Promise<ID_Output>;
  Entity: <T = EntityPromise>() => T;
  Connector: <T = ConnectorPromise>() => T;
  TenantId: <T = UserPromise>() => T;
  FieldShortDesc: () => Promise<String>;
  FieldLongDesc: () => Promise<String>;
  SourceKey: () => Promise<String>;
  SourceKeyValue: () => Promise<String>;
  TargetKey: () => Promise<String>;
  TargetKeyValue: () => Promise<String>;
  OtherParam: () => Promise<String>;
}

export interface FieldSubscriptionPayload {
  mutation: MutationType;
  node: Field;
  updatedFields: String[];
  previousValues: FieldPreviousValues;
}

export interface FieldSubscriptionPayloadPromise
  extends Promise<FieldSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FieldPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FieldPreviousValuesPromise>() => T;
}

export interface FieldSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FieldSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FieldSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FieldPreviousValuesSubscription>() => T;
}

export interface ScheduleEdge {
  node: Schedule;
  cursor: String;
}

export interface ScheduleEdgePromise
  extends Promise<ScheduleEdge>,
    Fragmentable {
  node: <T = SchedulePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleEdgeSubscription
  extends Promise<AsyncIterator<ScheduleEdge>>,
    Fragmentable {
  node: <T = ScheduleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FieldPreviousValues {
  FieldID: ID_Output;
  FieldName?: String;
  FieldShortDesc?: String;
  FieldLongDesc?: String;
  DataType?: String;
  FieldType?: String;
  Status?: Status;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
}

export interface FieldPreviousValuesPromise
  extends Promise<FieldPreviousValues>,
    Fragmentable {
  FieldID: () => Promise<ID_Output>;
  FieldName: () => Promise<String>;
  FieldShortDesc: () => Promise<String>;
  FieldLongDesc: () => Promise<String>;
  DataType: () => Promise<String>;
  FieldType: () => Promise<String>;
  Status: () => Promise<Status>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface FieldPreviousValuesSubscription
  extends Promise<AsyncIterator<FieldPreviousValues>>,
    Fragmentable {
  FieldID: () => Promise<AsyncIterator<ID_Output>>;
  FieldName: () => Promise<AsyncIterator<String>>;
  FieldShortDesc: () => Promise<AsyncIterator<String>>;
  FieldLongDesc: () => Promise<AsyncIterator<String>>;
  DataType: () => Promise<AsyncIterator<String>>;
  FieldType: () => Promise<AsyncIterator<String>>;
  Status: () => Promise<AsyncIterator<Status>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateProcessHistory {
  count: Int;
}

export interface AggregateProcessHistoryPromise
  extends Promise<AggregateProcessHistory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProcessHistorySubscription
  extends Promise<AsyncIterator<AggregateProcessHistory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EntityConnStrctjson {
  Name?: String;
  Value?: String;
  PluginId?: String;
  EntityID?: String;
  Question?: String;
  FieldType?: String;
  LookupValues: String[];
  FieldLength?: Int;
  IsRequired?: Boolean;
  FieldName?: String;
  Answers?: String;
  IsEditable?: Boolean;
  IsViewable?: Boolean;
}

export interface EntityConnStrctjsonPromise
  extends Promise<EntityConnStrctjson>,
    Fragmentable {
  Name: () => Promise<String>;
  Value: () => Promise<String>;
  PluginId: () => Promise<String>;
  EntityID: () => Promise<String>;
  Question: () => Promise<String>;
  FieldType: () => Promise<String>;
  LookupValues: () => Promise<String[]>;
  FieldLength: () => Promise<Int>;
  IsRequired: () => Promise<Boolean>;
  FieldName: () => Promise<String>;
  Answers: () => Promise<String>;
  IsEditable: () => Promise<Boolean>;
  IsViewable: () => Promise<Boolean>;
}

export interface EntityConnStrctjsonSubscription
  extends Promise<AsyncIterator<EntityConnStrctjson>>,
    Fragmentable {
  Name: () => Promise<AsyncIterator<String>>;
  Value: () => Promise<AsyncIterator<String>>;
  PluginId: () => Promise<AsyncIterator<String>>;
  EntityID: () => Promise<AsyncIterator<String>>;
  Question: () => Promise<AsyncIterator<String>>;
  FieldType: () => Promise<AsyncIterator<String>>;
  LookupValues: () => Promise<AsyncIterator<String[]>>;
  FieldLength: () => Promise<AsyncIterator<Int>>;
  IsRequired: () => Promise<AsyncIterator<Boolean>>;
  FieldName: () => Promise<AsyncIterator<String>>;
  Answers: () => Promise<AsyncIterator<String>>;
  IsEditable: () => Promise<AsyncIterator<Boolean>>;
  IsViewable: () => Promise<AsyncIterator<Boolean>>;
}

export interface EntityConnStrctjsonNullablePromise
  extends Promise<EntityConnStrctjson | null>,
    Fragmentable {
  Name: () => Promise<String>;
  Value: () => Promise<String>;
  PluginId: () => Promise<String>;
  EntityID: () => Promise<String>;
  Question: () => Promise<String>;
  FieldType: () => Promise<String>;
  LookupValues: () => Promise<String[]>;
  FieldLength: () => Promise<Int>;
  IsRequired: () => Promise<Boolean>;
  FieldName: () => Promise<String>;
  Answers: () => Promise<String>;
  IsEditable: () => Promise<Boolean>;
  IsViewable: () => Promise<Boolean>;
}

export interface ProcessHistoryConnection {
  pageInfo: PageInfo;
  edges: ProcessHistoryEdge[];
}

export interface ProcessHistoryConnectionPromise
  extends Promise<ProcessHistoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProcessHistoryEdge>>() => T;
  aggregate: <T = AggregateProcessHistoryPromise>() => T;
}

export interface ProcessHistoryConnectionSubscription
  extends Promise<AsyncIterator<ProcessHistoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProcessHistoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProcessHistorySubscription>() => T;
}

export interface FieldMapSubscriptionPayload {
  mutation: MutationType;
  node: FieldMap;
  updatedFields: String[];
  previousValues: FieldMapPreviousValues;
}

export interface FieldMapSubscriptionPayloadPromise
  extends Promise<FieldMapSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FieldMapPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FieldMapPreviousValuesPromise>() => T;
}

export interface FieldMapSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FieldMapSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FieldMapSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FieldMapPreviousValuesSubscription>() => T;
}

export interface AggregateProcess {
  count: Int;
}

export interface AggregateProcessPromise
  extends Promise<AggregateProcess>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProcessSubscription
  extends Promise<AsyncIterator<AggregateProcess>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FieldMapPreviousValues {
  FieldMapID: ID_Output;
  Status?: Status;
  FieldShortDesc?: String;
  FieldLongDesc?: String;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
}

export interface FieldMapPreviousValuesPromise
  extends Promise<FieldMapPreviousValues>,
    Fragmentable {
  FieldMapID: () => Promise<ID_Output>;
  Status: () => Promise<Status>;
  FieldShortDesc: () => Promise<String>;
  FieldLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface FieldMapPreviousValuesSubscription
  extends Promise<AsyncIterator<FieldMapPreviousValues>>,
    Fragmentable {
  FieldMapID: () => Promise<AsyncIterator<ID_Output>>;
  Status: () => Promise<AsyncIterator<Status>>;
  FieldShortDesc: () => Promise<AsyncIterator<String>>;
  FieldLongDesc: () => Promise<AsyncIterator<String>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProcessConnection {
  pageInfo: PageInfo;
  edges: ProcessEdge[];
}

export interface ProcessConnectionPromise
  extends Promise<ProcessConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProcessEdge>>() => T;
  aggregate: <T = AggregateProcessPromise>() => T;
}

export interface ProcessConnectionSubscription
  extends Promise<AsyncIterator<ProcessConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProcessEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProcessSubscription>() => T;
}

export interface Entity {
  EntityID: ID_Output;
  EntityName?: String;
  EntityType?: String;
  EntityShortDesc?: String;
  EntityLongDesc?: String;
  CreatedBy?: String;
  ConnectUrl?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
  Status?: Status;
  ConfigStructure?: <T = FragmentableArray<EntityConnStrctjson>>() => T;
}

export interface EntityPromise extends Promise<Entity>, Fragmentable {
  EntityID: () => Promise<ID_Output>;
  PluginID: <T = PluginPromise>() => T;
  EntityName: () => Promise<String>;
  EntityType: () => Promise<String>;
  EntityShortDesc: () => Promise<String>;
  EntityLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  ConnectUrl: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  Status: () => Promise<Status>;
  ConfigStructure: <T = FragmentableArray<EntityConnStrctjson>>() => T;
}

export interface EntitySubscription
  extends Promise<AsyncIterator<Entity>>,
    Fragmentable {
  EntityID: () => Promise<AsyncIterator<ID_Output>>;
  PluginID: <T = PluginSubscription>() => T;
  EntityName: () => Promise<AsyncIterator<String>>;
  EntityType: () => Promise<AsyncIterator<String>>;
  EntityShortDesc: () => Promise<AsyncIterator<String>>;
  EntityLongDesc: () => Promise<AsyncIterator<String>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  ConnectUrl: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  Status: () => Promise<AsyncIterator<Status>>;
  ConfigStructure: <
    T = Promise<AsyncIterator<EntityConnStrctjsonSubscription>>
  >() => T;
}

export interface EntityNullablePromise
  extends Promise<Entity | null>,
    Fragmentable {
  EntityID: () => Promise<ID_Output>;
  PluginID: <T = PluginPromise>() => T;
  EntityName: () => Promise<String>;
  EntityType: () => Promise<String>;
  EntityShortDesc: () => Promise<String>;
  EntityLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  ConnectUrl: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  Status: () => Promise<Status>;
  ConfigStructure: <T = FragmentableArray<EntityConnStrctjson>>() => T;
}

export interface PluginParamEdge {
  node: PluginParam;
  cursor: String;
}

export interface PluginParamEdgePromise
  extends Promise<PluginParamEdge>,
    Fragmentable {
  node: <T = PluginParamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PluginParamEdgeSubscription
  extends Promise<AsyncIterator<PluginParamEdge>>,
    Fragmentable {
  node: <T = PluginParamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LogSubscriptionPayload {
  mutation: MutationType;
  node: Log;
  updatedFields: String[];
  previousValues: LogPreviousValues;
}

export interface LogSubscriptionPayloadPromise
  extends Promise<LogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LogPreviousValuesPromise>() => T;
}

export interface LogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LogPreviousValuesSubscription>() => T;
}

export interface PluginParam {
  PluginParamID: ID_Output;
  FieldType?: String;
  FieldName?: String;
  Caption?: String;
  Status?: Status;
  Required?: Boolean;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
}

export interface PluginParamPromise extends Promise<PluginParam>, Fragmentable {
  PluginParamID: () => Promise<ID_Output>;
  FieldType: () => Promise<String>;
  FieldName: () => Promise<String>;
  Caption: () => Promise<String>;
  PluginID: <T = PluginPromise>() => T;
  Status: () => Promise<Status>;
  Required: () => Promise<Boolean>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface PluginParamSubscription
  extends Promise<AsyncIterator<PluginParam>>,
    Fragmentable {
  PluginParamID: () => Promise<AsyncIterator<ID_Output>>;
  FieldType: () => Promise<AsyncIterator<String>>;
  FieldName: () => Promise<AsyncIterator<String>>;
  Caption: () => Promise<AsyncIterator<String>>;
  PluginID: <T = PluginSubscription>() => T;
  Status: () => Promise<AsyncIterator<Status>>;
  Required: () => Promise<AsyncIterator<Boolean>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PluginParamNullablePromise
  extends Promise<PluginParam | null>,
    Fragmentable {
  PluginParamID: () => Promise<ID_Output>;
  FieldType: () => Promise<String>;
  FieldName: () => Promise<String>;
  Caption: () => Promise<String>;
  PluginID: <T = PluginPromise>() => T;
  Status: () => Promise<Status>;
  Required: () => Promise<Boolean>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface LogPreviousValues {
  LogId: ID_Output;
  LogDate?: DateTimeOutput;
  Thread?: String;
  Level?: String;
  Operation?: String;
  Event?: String;
  Sourcekeyfields?: String;
  Sourcekeyvalue?: String;
  Targetkeyfields?: String;
  Targetkeyvalue?: String;
  Message?: String;
  Exceptions?: String;
}

export interface LogPreviousValuesPromise
  extends Promise<LogPreviousValues>,
    Fragmentable {
  LogId: () => Promise<ID_Output>;
  LogDate: () => Promise<DateTimeOutput>;
  Thread: () => Promise<String>;
  Level: () => Promise<String>;
  Operation: () => Promise<String>;
  Event: () => Promise<String>;
  Sourcekeyfields: () => Promise<String>;
  Sourcekeyvalue: () => Promise<String>;
  Targetkeyfields: () => Promise<String>;
  Targetkeyvalue: () => Promise<String>;
  Message: () => Promise<String>;
  Exceptions: () => Promise<String>;
}

export interface LogPreviousValuesSubscription
  extends Promise<AsyncIterator<LogPreviousValues>>,
    Fragmentable {
  LogId: () => Promise<AsyncIterator<ID_Output>>;
  LogDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  Thread: () => Promise<AsyncIterator<String>>;
  Level: () => Promise<AsyncIterator<String>>;
  Operation: () => Promise<AsyncIterator<String>>;
  Event: () => Promise<AsyncIterator<String>>;
  Sourcekeyfields: () => Promise<AsyncIterator<String>>;
  Sourcekeyvalue: () => Promise<AsyncIterator<String>>;
  Targetkeyfields: () => Promise<AsyncIterator<String>>;
  Targetkeyvalue: () => Promise<AsyncIterator<String>>;
  Message: () => Promise<AsyncIterator<String>>;
  Exceptions: () => Promise<AsyncIterator<String>>;
}

export interface PluginCategoryEdge {
  node: PluginCategory;
  cursor: String;
}

export interface PluginCategoryEdgePromise
  extends Promise<PluginCategoryEdge>,
    Fragmentable {
  node: <T = PluginCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PluginCategoryEdgeSubscription
  extends Promise<AsyncIterator<PluginCategoryEdge>>,
    Fragmentable {
  node: <T = PluginCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDatabaseUser {
  count: Int;
}

export interface AggregateDatabaseUserPromise
  extends Promise<AggregateDatabaseUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDatabaseUserSubscription
  extends Promise<AsyncIterator<AggregateDatabaseUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePlugin {
  count: Int;
}

export interface AggregatePluginPromise
  extends Promise<AggregatePlugin>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePluginSubscription
  extends Promise<AsyncIterator<AggregatePlugin>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PluginSubscriptionPayload {
  mutation: MutationType;
  node: Plugin;
  updatedFields: String[];
  previousValues: PluginPreviousValues;
}

export interface PluginSubscriptionPayloadPromise
  extends Promise<PluginSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PluginPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PluginPreviousValuesPromise>() => T;
}

export interface PluginSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PluginSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PluginSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PluginPreviousValuesSubscription>() => T;
}

export interface PluginConnection {
  pageInfo: PageInfo;
  edges: PluginEdge[];
}

export interface PluginConnectionPromise
  extends Promise<PluginConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PluginEdge>>() => T;
  aggregate: <T = AggregatePluginPromise>() => T;
}

export interface PluginConnectionSubscription
  extends Promise<AsyncIterator<PluginConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PluginEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePluginSubscription>() => T;
}

export interface PluginPreviousValues {
  PluginID: ID_Output;
  PluginName?: String;
  PluginTitle?: String;
  PluginShortName?: String;
  PluginSEOName?: String;
  PluginShortDesc?: String;
  PluginLongDesc?: String;
  AssemblyName?: String;
  Status?: Status;
  pluginType?: String;
  CreatedDate?: DateTimeOutput;
  CreatedBy?: String;
  ModifiedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ImageName?: String;
  DefaultStructure?: String;
  ConnectUrl?: String;
  Popular?: Boolean;
  Recent?: Boolean;
}

export interface PluginPreviousValuesPromise
  extends Promise<PluginPreviousValues>,
    Fragmentable {
  PluginID: () => Promise<ID_Output>;
  PluginName: () => Promise<String>;
  PluginTitle: () => Promise<String>;
  PluginShortName: () => Promise<String>;
  PluginSEOName: () => Promise<String>;
  PluginShortDesc: () => Promise<String>;
  PluginLongDesc: () => Promise<String>;
  AssemblyName: () => Promise<String>;
  Status: () => Promise<Status>;
  pluginType: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  CreatedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ImageName: () => Promise<String>;
  DefaultStructure: () => Promise<String>;
  ConnectUrl: () => Promise<String>;
  Popular: () => Promise<Boolean>;
  Recent: () => Promise<Boolean>;
}

export interface PluginPreviousValuesSubscription
  extends Promise<AsyncIterator<PluginPreviousValues>>,
    Fragmentable {
  PluginID: () => Promise<AsyncIterator<ID_Output>>;
  PluginName: () => Promise<AsyncIterator<String>>;
  PluginTitle: () => Promise<AsyncIterator<String>>;
  PluginShortName: () => Promise<AsyncIterator<String>>;
  PluginSEOName: () => Promise<AsyncIterator<String>>;
  PluginShortDesc: () => Promise<AsyncIterator<String>>;
  PluginLongDesc: () => Promise<AsyncIterator<String>>;
  AssemblyName: () => Promise<AsyncIterator<String>>;
  Status: () => Promise<AsyncIterator<Status>>;
  pluginType: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ImageName: () => Promise<AsyncIterator<String>>;
  DefaultStructure: () => Promise<AsyncIterator<String>>;
  ConnectUrl: () => Promise<AsyncIterator<String>>;
  Popular: () => Promise<AsyncIterator<Boolean>>;
  Recent: () => Promise<AsyncIterator<Boolean>>;
}

export interface LogEdge {
  node: Log;
  cursor: String;
}

export interface LogEdgePromise extends Promise<LogEdge>, Fragmentable {
  node: <T = LogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LogEdgeSubscription
  extends Promise<AsyncIterator<LogEdge>>,
    Fragmentable {
  node: <T = LogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DatabaseUserEdge {
  node: DatabaseUser;
  cursor: String;
}

export interface DatabaseUserEdgePromise
  extends Promise<DatabaseUserEdge>,
    Fragmentable {
  node: <T = DatabaseUserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DatabaseUserEdgeSubscription
  extends Promise<AsyncIterator<DatabaseUserEdge>>,
    Fragmentable {
  node: <T = DatabaseUserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Schedule {
  ScheduleID: ID_Output;
  Field?: String;
  Status?: Stage;
  DailyOccurence?: String;
  ScheduleType?: String;
  DailyRecurrenceType?: String;
  OccursAt?: String;
  DailyInterval?: String;
  DailyIntervalSpan?: String;
  WeekDays: Int[];
  DayofMonth?: String;
  LastExecuted?: String;
  NextOccurence?: String;
  CreatedDate?: String;
  CreatedBy?: String;
  ModifiedDate?: String;
  ModifiedBy?: String;
  StartTime?: String;
  EndTime?: String;
  Type?: String;
}

export interface SchedulePromise extends Promise<Schedule>, Fragmentable {
  ScheduleID: () => Promise<ID_Output>;
  TenantId: <T = UserPromise>() => T;
  ProcessId: <T = ProcessPromise>() => T;
  SubscriberProcess: <T = SubscriberProcessPromise>() => T;
  SubcriptionHistoryId: <T = SubcriptionHistoryPromise>() => T;
  Field: () => Promise<String>;
  Status: () => Promise<Stage>;
  DailyOccurence: () => Promise<String>;
  ScheduleType: () => Promise<String>;
  DailyRecurrenceType: () => Promise<String>;
  OccursAt: () => Promise<String>;
  DailyInterval: () => Promise<String>;
  DailyIntervalSpan: () => Promise<String>;
  WeekDays: () => Promise<Int[]>;
  DayofMonth: () => Promise<String>;
  LastExecuted: () => Promise<String>;
  NextOccurence: () => Promise<String>;
  SubscriptionIntegrationId: <T = SubscriptionIntegrationPromise>() => T;
  CreatedDate: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  ModifiedDate: () => Promise<String>;
  ModifiedBy: () => Promise<String>;
  StartTime: () => Promise<String>;
  EndTime: () => Promise<String>;
  Type: () => Promise<String>;
}

export interface ScheduleSubscription
  extends Promise<AsyncIterator<Schedule>>,
    Fragmentable {
  ScheduleID: () => Promise<AsyncIterator<ID_Output>>;
  TenantId: <T = UserSubscription>() => T;
  ProcessId: <T = ProcessSubscription>() => T;
  SubscriberProcess: <T = SubscriberProcessSubscription>() => T;
  SubcriptionHistoryId: <T = SubcriptionHistorySubscription>() => T;
  Field: () => Promise<AsyncIterator<String>>;
  Status: () => Promise<AsyncIterator<Stage>>;
  DailyOccurence: () => Promise<AsyncIterator<String>>;
  ScheduleType: () => Promise<AsyncIterator<String>>;
  DailyRecurrenceType: () => Promise<AsyncIterator<String>>;
  OccursAt: () => Promise<AsyncIterator<String>>;
  DailyInterval: () => Promise<AsyncIterator<String>>;
  DailyIntervalSpan: () => Promise<AsyncIterator<String>>;
  WeekDays: () => Promise<AsyncIterator<Int[]>>;
  DayofMonth: () => Promise<AsyncIterator<String>>;
  LastExecuted: () => Promise<AsyncIterator<String>>;
  NextOccurence: () => Promise<AsyncIterator<String>>;
  SubscriptionIntegrationId: <T = SubscriptionIntegrationSubscription>() => T;
  CreatedDate: () => Promise<AsyncIterator<String>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<String>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  StartTime: () => Promise<AsyncIterator<String>>;
  EndTime: () => Promise<AsyncIterator<String>>;
  Type: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleNullablePromise
  extends Promise<Schedule | null>,
    Fragmentable {
  ScheduleID: () => Promise<ID_Output>;
  TenantId: <T = UserPromise>() => T;
  ProcessId: <T = ProcessPromise>() => T;
  SubscriberProcess: <T = SubscriberProcessPromise>() => T;
  SubcriptionHistoryId: <T = SubcriptionHistoryPromise>() => T;
  Field: () => Promise<String>;
  Status: () => Promise<Stage>;
  DailyOccurence: () => Promise<String>;
  ScheduleType: () => Promise<String>;
  DailyRecurrenceType: () => Promise<String>;
  OccursAt: () => Promise<String>;
  DailyInterval: () => Promise<String>;
  DailyIntervalSpan: () => Promise<String>;
  WeekDays: () => Promise<Int[]>;
  DayofMonth: () => Promise<String>;
  LastExecuted: () => Promise<String>;
  NextOccurence: () => Promise<String>;
  SubscriptionIntegrationId: <T = SubscriptionIntegrationPromise>() => T;
  CreatedDate: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  ModifiedDate: () => Promise<String>;
  ModifiedBy: () => Promise<String>;
  StartTime: () => Promise<String>;
  EndTime: () => Promise<String>;
  Type: () => Promise<String>;
}

export interface PluginCategorySubscriptionPayload {
  mutation: MutationType;
  node: PluginCategory;
  updatedFields: String[];
  previousValues: PluginCategoryPreviousValues;
}

export interface PluginCategorySubscriptionPayloadPromise
  extends Promise<PluginCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PluginCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PluginCategoryPreviousValuesPromise>() => T;
}

export interface PluginCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PluginCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PluginCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PluginCategoryPreviousValuesSubscription>() => T;
}

export interface SubscriberProcess {
  SubscriberProcessID: ID_Output;
  Status?: Status;
  Stage?: Stage;
  CreatedBy?: String;
  CreatedDate: DateTimeOutput;
  ModifiedDate: DateTimeOutput;
  ModifiedBy?: String;
  LastSyncDate?: String;
}

export interface SubscriberProcessPromise
  extends Promise<SubscriberProcess>,
    Fragmentable {
  SubscriberProcessID: () => Promise<ID_Output>;
  ProcessId: <T = ProcessPromise>() => T;
  TenantId: <T = UserPromise>() => T;
  ConnectorId: <T = ConnectorPromise>() => T;
  Status: () => Promise<Status>;
  Stage: () => Promise<Stage>;
  CreatedBy: () => Promise<String>;
  Schedule: <T = FragmentableArray<Schedule>>(args?: {
    where?: ScheduleWhereInput;
    orderBy?: ScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  LastSyncDate: () => Promise<String>;
  PrimaryEntity: <T = EntityPromise>() => T;
  SecondaryEntity: <T = EntityPromise>() => T;
}

export interface SubscriberProcessSubscription
  extends Promise<AsyncIterator<SubscriberProcess>>,
    Fragmentable {
  SubscriberProcessID: () => Promise<AsyncIterator<ID_Output>>;
  ProcessId: <T = ProcessSubscription>() => T;
  TenantId: <T = UserSubscription>() => T;
  ConnectorId: <T = ConnectorSubscription>() => T;
  Status: () => Promise<AsyncIterator<Status>>;
  Stage: () => Promise<AsyncIterator<Stage>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  Schedule: <T = Promise<AsyncIterator<ScheduleSubscription>>>(args?: {
    where?: ScheduleWhereInput;
    orderBy?: ScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  LastSyncDate: () => Promise<AsyncIterator<String>>;
  PrimaryEntity: <T = EntitySubscription>() => T;
  SecondaryEntity: <T = EntitySubscription>() => T;
}

export interface SubscriberProcessNullablePromise
  extends Promise<SubscriberProcess | null>,
    Fragmentable {
  SubscriberProcessID: () => Promise<ID_Output>;
  ProcessId: <T = ProcessPromise>() => T;
  TenantId: <T = UserPromise>() => T;
  ConnectorId: <T = ConnectorPromise>() => T;
  Status: () => Promise<Status>;
  Stage: () => Promise<Stage>;
  CreatedBy: () => Promise<String>;
  Schedule: <T = FragmentableArray<Schedule>>(args?: {
    where?: ScheduleWhereInput;
    orderBy?: ScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  LastSyncDate: () => Promise<String>;
  PrimaryEntity: <T = EntityPromise>() => T;
  SecondaryEntity: <T = EntityPromise>() => T;
}

export interface PluginCategoryPreviousValues {
  CategoryID: ID_Output;
  CategoryName: String;
  CategoryDesc?: String;
}

export interface PluginCategoryPreviousValuesPromise
  extends Promise<PluginCategoryPreviousValues>,
    Fragmentable {
  CategoryID: () => Promise<ID_Output>;
  CategoryName: () => Promise<String>;
  CategoryDesc: () => Promise<String>;
}

export interface PluginCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<PluginCategoryPreviousValues>>,
    Fragmentable {
  CategoryID: () => Promise<AsyncIterator<ID_Output>>;
  CategoryName: () => Promise<AsyncIterator<String>>;
  CategoryDesc: () => Promise<AsyncIterator<String>>;
}

export interface User {
  UserId: ID_Output;
  FirstName?: String;
  LastName?: String;
  UserName?: String;
  Address?: String;
  PhoneNumber?: String;
  PhoneCode?: String;
  Email?: String;
  TenantId?: String;
  CompanyName?: String;
  ZipCode?: String;
  Country?: String;
  State?: String;
  City?: String;
  IsAdmin?: String;
  Password?: String;
  ConfirmPassword?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  UserId: () => Promise<ID_Output>;
  FirstName: () => Promise<String>;
  LastName: () => Promise<String>;
  UserName: () => Promise<String>;
  Address: () => Promise<String>;
  PhoneNumber: () => Promise<String>;
  PhoneCode: () => Promise<String>;
  Email: () => Promise<String>;
  TenantId: () => Promise<String>;
  CompanyName: () => Promise<String>;
  ZipCode: () => Promise<String>;
  Country: () => Promise<String>;
  State: () => Promise<String>;
  City: () => Promise<String>;
  IsAdmin: () => Promise<String>;
  Password: () => Promise<String>;
  ConfirmPassword: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  UserId: () => Promise<AsyncIterator<ID_Output>>;
  FirstName: () => Promise<AsyncIterator<String>>;
  LastName: () => Promise<AsyncIterator<String>>;
  UserName: () => Promise<AsyncIterator<String>>;
  Address: () => Promise<AsyncIterator<String>>;
  PhoneNumber: () => Promise<AsyncIterator<String>>;
  PhoneCode: () => Promise<AsyncIterator<String>>;
  Email: () => Promise<AsyncIterator<String>>;
  TenantId: () => Promise<AsyncIterator<String>>;
  CompanyName: () => Promise<AsyncIterator<String>>;
  ZipCode: () => Promise<AsyncIterator<String>>;
  Country: () => Promise<AsyncIterator<String>>;
  State: () => Promise<AsyncIterator<String>>;
  City: () => Promise<AsyncIterator<String>>;
  IsAdmin: () => Promise<AsyncIterator<String>>;
  Password: () => Promise<AsyncIterator<String>>;
  ConfirmPassword: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  UserId: () => Promise<ID_Output>;
  FirstName: () => Promise<String>;
  LastName: () => Promise<String>;
  UserName: () => Promise<String>;
  Address: () => Promise<String>;
  PhoneNumber: () => Promise<String>;
  PhoneCode: () => Promise<String>;
  Email: () => Promise<String>;
  TenantId: () => Promise<String>;
  CompanyName: () => Promise<String>;
  ZipCode: () => Promise<String>;
  Country: () => Promise<String>;
  State: () => Promise<String>;
  City: () => Promise<String>;
  IsAdmin: () => Promise<String>;
  Password: () => Promise<String>;
  ConfirmPassword: () => Promise<String>;
}

export interface DatabaseUserConnection {
  pageInfo: PageInfo;
  edges: DatabaseUserEdge[];
}

export interface DatabaseUserConnectionPromise
  extends Promise<DatabaseUserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DatabaseUserEdge>>() => T;
  aggregate: <T = AggregateDatabaseUserPromise>() => T;
}

export interface DatabaseUserConnectionSubscription
  extends Promise<AsyncIterator<DatabaseUserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DatabaseUserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDatabaseUserSubscription>() => T;
}

export interface Log {
  LogId: ID_Output;
  LogDate?: DateTimeOutput;
  Thread?: String;
  Level?: String;
  Operation?: String;
  Event?: String;
  Sourcekeyfields?: String;
  Sourcekeyvalue?: String;
  Targetkeyfields?: String;
  Targetkeyvalue?: String;
  Message?: String;
  Exceptions?: String;
}

export interface LogPromise extends Promise<Log>, Fragmentable {
  LogId: () => Promise<ID_Output>;
  SubcriptionHistoryId: <T = SubcriptionHistoryPromise>() => T;
  SubscriberProcess: <T = SubscriberProcessPromise>() => T;
  SubscriptionIntegrationId: <T = SubscriptionIntegrationPromise>() => T;
  ConnectorId: <T = ConnectorPromise>() => T;
  LogDate: () => Promise<DateTimeOutput>;
  Thread: () => Promise<String>;
  Level: () => Promise<String>;
  ProcessId: <T = ProcessPromise>() => T;
  Operation: () => Promise<String>;
  Event: () => Promise<String>;
  Sourcekeyfields: () => Promise<String>;
  Sourcekeyvalue: () => Promise<String>;
  Targetkeyfields: () => Promise<String>;
  Targetkeyvalue: () => Promise<String>;
  Message: () => Promise<String>;
  Exceptions: () => Promise<String>;
  TenantId: <T = UserPromise>() => T;
}

export interface LogSubscription
  extends Promise<AsyncIterator<Log>>,
    Fragmentable {
  LogId: () => Promise<AsyncIterator<ID_Output>>;
  SubcriptionHistoryId: <T = SubcriptionHistorySubscription>() => T;
  SubscriberProcess: <T = SubscriberProcessSubscription>() => T;
  SubscriptionIntegrationId: <T = SubscriptionIntegrationSubscription>() => T;
  ConnectorId: <T = ConnectorSubscription>() => T;
  LogDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  Thread: () => Promise<AsyncIterator<String>>;
  Level: () => Promise<AsyncIterator<String>>;
  ProcessId: <T = ProcessSubscription>() => T;
  Operation: () => Promise<AsyncIterator<String>>;
  Event: () => Promise<AsyncIterator<String>>;
  Sourcekeyfields: () => Promise<AsyncIterator<String>>;
  Sourcekeyvalue: () => Promise<AsyncIterator<String>>;
  Targetkeyfields: () => Promise<AsyncIterator<String>>;
  Targetkeyvalue: () => Promise<AsyncIterator<String>>;
  Message: () => Promise<AsyncIterator<String>>;
  Exceptions: () => Promise<AsyncIterator<String>>;
  TenantId: <T = UserSubscription>() => T;
}

export interface LogNullablePromise extends Promise<Log | null>, Fragmentable {
  LogId: () => Promise<ID_Output>;
  SubcriptionHistoryId: <T = SubcriptionHistoryPromise>() => T;
  SubscriberProcess: <T = SubscriberProcessPromise>() => T;
  SubscriptionIntegrationId: <T = SubscriptionIntegrationPromise>() => T;
  ConnectorId: <T = ConnectorPromise>() => T;
  LogDate: () => Promise<DateTimeOutput>;
  Thread: () => Promise<String>;
  Level: () => Promise<String>;
  ProcessId: <T = ProcessPromise>() => T;
  Operation: () => Promise<String>;
  Event: () => Promise<String>;
  Sourcekeyfields: () => Promise<String>;
  Sourcekeyvalue: () => Promise<String>;
  Targetkeyfields: () => Promise<String>;
  Targetkeyvalue: () => Promise<String>;
  Message: () => Promise<String>;
  Exceptions: () => Promise<String>;
  TenantId: <T = UserPromise>() => T;
}

export interface PluginParamSubscriptionPayload {
  mutation: MutationType;
  node: PluginParam;
  updatedFields: String[];
  previousValues: PluginParamPreviousValues;
}

export interface PluginParamSubscriptionPayloadPromise
  extends Promise<PluginParamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PluginParamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PluginParamPreviousValuesPromise>() => T;
}

export interface PluginParamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PluginParamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PluginParamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PluginParamPreviousValuesSubscription>() => T;
}

export interface FieldMapEdge {
  node: FieldMap;
  cursor: String;
}

export interface FieldMapEdgePromise
  extends Promise<FieldMapEdge>,
    Fragmentable {
  node: <T = FieldMapPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FieldMapEdgeSubscription
  extends Promise<AsyncIterator<FieldMapEdge>>,
    Fragmentable {
  node: <T = FieldMapSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PluginParamPreviousValues {
  PluginParamID: ID_Output;
  FieldType?: String;
  FieldName?: String;
  Caption?: String;
  Status?: Status;
  Required?: Boolean;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
}

export interface PluginParamPreviousValuesPromise
  extends Promise<PluginParamPreviousValues>,
    Fragmentable {
  PluginParamID: () => Promise<ID_Output>;
  FieldType: () => Promise<String>;
  FieldName: () => Promise<String>;
  Caption: () => Promise<String>;
  Status: () => Promise<Status>;
  Required: () => Promise<Boolean>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface PluginParamPreviousValuesSubscription
  extends Promise<AsyncIterator<PluginParamPreviousValues>>,
    Fragmentable {
  PluginParamID: () => Promise<AsyncIterator<ID_Output>>;
  FieldType: () => Promise<AsyncIterator<String>>;
  FieldName: () => Promise<AsyncIterator<String>>;
  Caption: () => Promise<AsyncIterator<String>>;
  Status: () => Promise<AsyncIterator<Status>>;
  Required: () => Promise<AsyncIterator<Boolean>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DatabaseUser {
  UserId: ID_Output;
  Name: String;
  Password: String;
  Claims?: DBClaims;
  Token?: String;
}

export interface DatabaseUserPromise
  extends Promise<DatabaseUser>,
    Fragmentable {
  UserId: () => Promise<ID_Output>;
  Name: () => Promise<String>;
  Password: () => Promise<String>;
  Claims: () => Promise<DBClaims>;
  Token: () => Promise<String>;
}

export interface DatabaseUserSubscription
  extends Promise<AsyncIterator<DatabaseUser>>,
    Fragmentable {
  UserId: () => Promise<AsyncIterator<ID_Output>>;
  Name: () => Promise<AsyncIterator<String>>;
  Password: () => Promise<AsyncIterator<String>>;
  Claims: () => Promise<AsyncIterator<DBClaims>>;
  Token: () => Promise<AsyncIterator<String>>;
}

export interface DatabaseUserNullablePromise
  extends Promise<DatabaseUser | null>,
    Fragmentable {
  UserId: () => Promise<ID_Output>;
  Name: () => Promise<String>;
  Password: () => Promise<String>;
  Claims: () => Promise<DBClaims>;
  Token: () => Promise<String>;
}

export interface TestimonialEdge {
  node: Testimonial;
  cursor: String;
}

export interface TestimonialEdgePromise
  extends Promise<TestimonialEdge>,
    Fragmentable {
  node: <T = TestimonialPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TestimonialEdgeSubscription
  extends Promise<AsyncIterator<TestimonialEdge>>,
    Fragmentable {
  node: <T = TestimonialSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProcessSubscriptionPayload {
  mutation: MutationType;
  node: Process;
  updatedFields: String[];
  previousValues: ProcessPreviousValues;
}

export interface ProcessSubscriptionPayloadPromise
  extends Promise<ProcessSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProcessPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProcessPreviousValuesPromise>() => T;
}

export interface ProcessSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProcessSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProcessSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProcessPreviousValuesSubscription>() => T;
}

export interface SubscriptionIntegrationEdge {
  node: SubscriptionIntegration;
  cursor: String;
}

export interface SubscriptionIntegrationEdgePromise
  extends Promise<SubscriptionIntegrationEdge>,
    Fragmentable {
  node: <T = SubscriptionIntegrationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubscriptionIntegrationEdgeSubscription
  extends Promise<AsyncIterator<SubscriptionIntegrationEdge>>,
    Fragmentable {
  node: <T = SubscriptionIntegrationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProcessPreviousValues {
  ProcessId: ID_Output;
  ProcessShortDesc?: String;
  ProcessLongDesc?: String;
  Status?: Status;
  CreatedBy?: String;
  CreatedDate: DateTimeOutput;
  ModifiedDate: DateTimeOutput;
  ModifiedBy?: String;
}

export interface ProcessPreviousValuesPromise
  extends Promise<ProcessPreviousValues>,
    Fragmentable {
  ProcessId: () => Promise<ID_Output>;
  ProcessShortDesc: () => Promise<String>;
  ProcessLongDesc: () => Promise<String>;
  Status: () => Promise<Status>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
}

export interface ProcessPreviousValuesSubscription
  extends Promise<AsyncIterator<ProcessPreviousValues>>,
    Fragmentable {
  ProcessId: () => Promise<AsyncIterator<ID_Output>>;
  ProcessShortDesc: () => Promise<AsyncIterator<String>>;
  ProcessLongDesc: () => Promise<AsyncIterator<String>>;
  Status: () => Promise<AsyncIterator<Status>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
}

export interface SubscriberProcessConnection {
  pageInfo: PageInfo;
  edges: SubscriberProcessEdge[];
}

export interface SubscriberProcessConnectionPromise
  extends Promise<SubscriberProcessConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubscriberProcessEdge>>() => T;
  aggregate: <T = AggregateSubscriberProcessPromise>() => T;
}

export interface SubscriberProcessConnectionSubscription
  extends Promise<AsyncIterator<SubscriberProcessConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubscriberProcessEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubscriberProcessSubscription>() => T;
}

export interface AggregateConnector {
  count: Int;
}

export interface AggregateConnectorPromise
  extends Promise<AggregateConnector>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateConnectorSubscription
  extends Promise<AsyncIterator<AggregateConnector>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubscriberFieldMap {
  SubscriberFieldMapID: ID_Output;
  Status?: Status;
  FieldShortDesc?: String;
  FieldLongDesc?: String;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
}

export interface SubscriberFieldMapPromise
  extends Promise<SubscriberFieldMap>,
    Fragmentable {
  SubscriberFieldMapID: () => Promise<ID_Output>;
  SourceEntityID: <T = EntityPromise>() => T;
  TargetEntityID: <T = EntityPromise>() => T;
  SourceField: <T = FragmentableArray<Field>>(args?: {
    where?: FieldWhereInput;
    orderBy?: FieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  TargetField: <T = FragmentableArray<Field>>(args?: {
    where?: FieldWhereInput;
    orderBy?: FieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  Status: () => Promise<Status>;
  FieldShortDesc: () => Promise<String>;
  FieldLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface SubscriberFieldMapSubscription
  extends Promise<AsyncIterator<SubscriberFieldMap>>,
    Fragmentable {
  SubscriberFieldMapID: () => Promise<AsyncIterator<ID_Output>>;
  SourceEntityID: <T = EntitySubscription>() => T;
  TargetEntityID: <T = EntitySubscription>() => T;
  SourceField: <T = Promise<AsyncIterator<FieldSubscription>>>(args?: {
    where?: FieldWhereInput;
    orderBy?: FieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  TargetField: <T = Promise<AsyncIterator<FieldSubscription>>>(args?: {
    where?: FieldWhereInput;
    orderBy?: FieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  Status: () => Promise<AsyncIterator<Status>>;
  FieldShortDesc: () => Promise<AsyncIterator<String>>;
  FieldLongDesc: () => Promise<AsyncIterator<String>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubscriberFieldMapNullablePromise
  extends Promise<SubscriberFieldMap | null>,
    Fragmentable {
  SubscriberFieldMapID: () => Promise<ID_Output>;
  SourceEntityID: <T = EntityPromise>() => T;
  TargetEntityID: <T = EntityPromise>() => T;
  SourceField: <T = FragmentableArray<Field>>(args?: {
    where?: FieldWhereInput;
    orderBy?: FieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  TargetField: <T = FragmentableArray<Field>>(args?: {
    where?: FieldWhereInput;
    orderBy?: FieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  Status: () => Promise<Status>;
  FieldShortDesc: () => Promise<String>;
  FieldLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface ProcessHistorySubscriptionPayload {
  mutation: MutationType;
  node: ProcessHistory;
  updatedFields: String[];
  previousValues: ProcessHistoryPreviousValues;
}

export interface ProcessHistorySubscriptionPayloadPromise
  extends Promise<ProcessHistorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProcessHistoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProcessHistoryPreviousValuesPromise>() => T;
}

export interface ProcessHistorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProcessHistorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProcessHistorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProcessHistoryPreviousValuesSubscription>() => T;
}

export interface SubscriberField {
  SubscriberFieldID: ID_Output;
  FieldName?: String;
  DataType?: String;
  FieldType?: String;
  Status?: Status;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
}

export interface SubscriberFieldPromise
  extends Promise<SubscriberField>,
    Fragmentable {
  SubscriberFieldID: () => Promise<ID_Output>;
  PluginsID: <T = PluginPromise>() => T;
  EntityID: <T = EntityPromise>() => T;
  FieldName: () => Promise<String>;
  DataType: () => Promise<String>;
  FieldType: () => Promise<String>;
  Status: () => Promise<Status>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface SubscriberFieldSubscription
  extends Promise<AsyncIterator<SubscriberField>>,
    Fragmentable {
  SubscriberFieldID: () => Promise<AsyncIterator<ID_Output>>;
  PluginsID: <T = PluginSubscription>() => T;
  EntityID: <T = EntitySubscription>() => T;
  FieldName: () => Promise<AsyncIterator<String>>;
  DataType: () => Promise<AsyncIterator<String>>;
  FieldType: () => Promise<AsyncIterator<String>>;
  Status: () => Promise<AsyncIterator<Status>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubscriberFieldNullablePromise
  extends Promise<SubscriberField | null>,
    Fragmentable {
  SubscriberFieldID: () => Promise<ID_Output>;
  PluginsID: <T = PluginPromise>() => T;
  EntityID: <T = EntityPromise>() => T;
  FieldName: () => Promise<String>;
  DataType: () => Promise<String>;
  FieldType: () => Promise<String>;
  Status: () => Promise<Status>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface ProcessHistoryPreviousValues {
  ProcessHistoryId: ID_Output;
  LastSyncDate?: String;
  CreatedDate: DateTimeOutput;
  ModifiedDate: DateTimeOutput;
  Stage?: Stage;
}

export interface ProcessHistoryPreviousValuesPromise
  extends Promise<ProcessHistoryPreviousValues>,
    Fragmentable {
  ProcessHistoryId: () => Promise<ID_Output>;
  LastSyncDate: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  Stage: () => Promise<Stage>;
}

export interface ProcessHistoryPreviousValuesSubscription
  extends Promise<AsyncIterator<ProcessHistoryPreviousValues>>,
    Fragmentable {
  ProcessHistoryId: () => Promise<AsyncIterator<ID_Output>>;
  LastSyncDate: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  Stage: () => Promise<AsyncIterator<Stage>>;
}

export interface SubscriberEntityMap {
  SubscriberEntityMapID: ID_Output;
  Status?: Status;
  EntityShortDesc?: String;
  EntityLongDesc?: String;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
}

export interface SubscriberEntityMapPromise
  extends Promise<SubscriberEntityMap>,
    Fragmentable {
  SubscriberEntityMapID: () => Promise<ID_Output>;
  SourceEntityID: <T = FragmentableArray<Entity>>(args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  TargetEntityID: <T = FragmentableArray<Entity>>(args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  Status: () => Promise<Status>;
  EntityShortDesc: () => Promise<String>;
  EntityLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface SubscriberEntityMapSubscription
  extends Promise<AsyncIterator<SubscriberEntityMap>>,
    Fragmentable {
  SubscriberEntityMapID: () => Promise<AsyncIterator<ID_Output>>;
  SourceEntityID: <T = Promise<AsyncIterator<EntitySubscription>>>(args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  TargetEntityID: <T = Promise<AsyncIterator<EntitySubscription>>>(args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  Status: () => Promise<AsyncIterator<Status>>;
  EntityShortDesc: () => Promise<AsyncIterator<String>>;
  EntityLongDesc: () => Promise<AsyncIterator<String>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubscriberEntityMapNullablePromise
  extends Promise<SubscriberEntityMap | null>,
    Fragmentable {
  SubscriberEntityMapID: () => Promise<ID_Output>;
  SourceEntityID: <T = FragmentableArray<Entity>>(args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  TargetEntityID: <T = FragmentableArray<Entity>>(args?: {
    where?: EntityWhereInput;
    orderBy?: EntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  Status: () => Promise<Status>;
  EntityShortDesc: () => Promise<String>;
  EntityLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface ConnectorEdge {
  node: Connector;
  cursor: String;
}

export interface ConnectorEdgePromise
  extends Promise<ConnectorEdge>,
    Fragmentable {
  node: <T = ConnectorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ConnectorEdgeSubscription
  extends Promise<AsyncIterator<ConnectorEdge>>,
    Fragmentable {
  node: <T = ConnectorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SubscriberEntity {
  SubscriberEntityID: ID_Output;
  EntityName?: String;
  EntityType?: String;
  EntityShortDesc?: String;
  EntityLongDesc?: String;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
  Status?: Status;
}

export interface SubscriberEntityPromise
  extends Promise<SubscriberEntity>,
    Fragmentable {
  SubscriberEntityID: () => Promise<ID_Output>;
  PluginID: <T = PluginPromise>() => T;
  EntityName: () => Promise<String>;
  EntityType: () => Promise<String>;
  EntityShortDesc: () => Promise<String>;
  EntityLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  Status: () => Promise<Status>;
}

export interface SubscriberEntitySubscription
  extends Promise<AsyncIterator<SubscriberEntity>>,
    Fragmentable {
  SubscriberEntityID: () => Promise<AsyncIterator<ID_Output>>;
  PluginID: <T = PluginSubscription>() => T;
  EntityName: () => Promise<AsyncIterator<String>>;
  EntityType: () => Promise<AsyncIterator<String>>;
  EntityShortDesc: () => Promise<AsyncIterator<String>>;
  EntityLongDesc: () => Promise<AsyncIterator<String>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  Status: () => Promise<AsyncIterator<Status>>;
}

export interface SubscriberEntityNullablePromise
  extends Promise<SubscriberEntity | null>,
    Fragmentable {
  SubscriberEntityID: () => Promise<ID_Output>;
  PluginID: <T = PluginPromise>() => T;
  EntityName: () => Promise<String>;
  EntityType: () => Promise<String>;
  EntityShortDesc: () => Promise<String>;
  EntityLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  Status: () => Promise<Status>;
}

export interface ScheduleSubscriptionPayload {
  mutation: MutationType;
  node: Schedule;
  updatedFields: String[];
  previousValues: SchedulePreviousValues;
}

export interface ScheduleSubscriptionPayloadPromise
  extends Promise<ScheduleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SchedulePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SchedulePreviousValuesPromise>() => T;
}

export interface ScheduleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SchedulePreviousValuesSubscription>() => T;
}

export interface AggregateSourceTargetFieldmapping {
  count: Int;
}

export interface AggregateSourceTargetFieldmappingPromise
  extends Promise<AggregateSourceTargetFieldmapping>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSourceTargetFieldmappingSubscription
  extends Promise<AsyncIterator<AggregateSourceTargetFieldmapping>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SchedulePreviousValues {
  ScheduleID: ID_Output;
  Field?: String;
  Status?: Stage;
  DailyOccurence?: String;
  ScheduleType?: String;
  DailyRecurrenceType?: String;
  OccursAt?: String;
  DailyInterval?: String;
  DailyIntervalSpan?: String;
  WeekDays: Int[];
  DayofMonth?: String;
  LastExecuted?: String;
  NextOccurence?: String;
  CreatedDate?: String;
  CreatedBy?: String;
  ModifiedDate?: String;
  ModifiedBy?: String;
  StartTime?: String;
  EndTime?: String;
  Type?: String;
}

export interface SchedulePreviousValuesPromise
  extends Promise<SchedulePreviousValues>,
    Fragmentable {
  ScheduleID: () => Promise<ID_Output>;
  Field: () => Promise<String>;
  Status: () => Promise<Stage>;
  DailyOccurence: () => Promise<String>;
  ScheduleType: () => Promise<String>;
  DailyRecurrenceType: () => Promise<String>;
  OccursAt: () => Promise<String>;
  DailyInterval: () => Promise<String>;
  DailyIntervalSpan: () => Promise<String>;
  WeekDays: () => Promise<Int[]>;
  DayofMonth: () => Promise<String>;
  LastExecuted: () => Promise<String>;
  NextOccurence: () => Promise<String>;
  CreatedDate: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  ModifiedDate: () => Promise<String>;
  ModifiedBy: () => Promise<String>;
  StartTime: () => Promise<String>;
  EndTime: () => Promise<String>;
  Type: () => Promise<String>;
}

export interface SchedulePreviousValuesSubscription
  extends Promise<AsyncIterator<SchedulePreviousValues>>,
    Fragmentable {
  ScheduleID: () => Promise<AsyncIterator<ID_Output>>;
  Field: () => Promise<AsyncIterator<String>>;
  Status: () => Promise<AsyncIterator<Stage>>;
  DailyOccurence: () => Promise<AsyncIterator<String>>;
  ScheduleType: () => Promise<AsyncIterator<String>>;
  DailyRecurrenceType: () => Promise<AsyncIterator<String>>;
  OccursAt: () => Promise<AsyncIterator<String>>;
  DailyInterval: () => Promise<AsyncIterator<String>>;
  DailyIntervalSpan: () => Promise<AsyncIterator<String>>;
  WeekDays: () => Promise<AsyncIterator<Int[]>>;
  DayofMonth: () => Promise<AsyncIterator<String>>;
  LastExecuted: () => Promise<AsyncIterator<String>>;
  NextOccurence: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<String>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<String>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  StartTime: () => Promise<AsyncIterator<String>>;
  EndTime: () => Promise<AsyncIterator<String>>;
  Type: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSchedule {
  count: Int;
}

export interface AggregateSchedulePromise
  extends Promise<AggregateSchedule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleSubscription
  extends Promise<AsyncIterator<AggregateSchedule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ProcessHistoryEdge {
  node: ProcessHistory;
  cursor: String;
}

export interface ProcessHistoryEdgePromise
  extends Promise<ProcessHistoryEdge>,
    Fragmentable {
  node: <T = ProcessHistoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProcessHistoryEdgeSubscription
  extends Promise<AsyncIterator<ProcessHistoryEdge>>,
    Fragmentable {
  node: <T = ProcessHistorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SourceTargetFieldmappingSubscriptionPayload {
  mutation: MutationType;
  node: SourceTargetFieldmapping;
  updatedFields: String[];
  previousValues: SourceTargetFieldmappingPreviousValues;
}

export interface SourceTargetFieldmappingSubscriptionPayloadPromise
  extends Promise<SourceTargetFieldmappingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SourceTargetFieldmappingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SourceTargetFieldmappingPreviousValuesPromise>() => T;
}

export interface SourceTargetFieldmappingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SourceTargetFieldmappingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SourceTargetFieldmappingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = SourceTargetFieldmappingPreviousValuesSubscription
  >() => T;
}

export interface ProcessEdge {
  node: Process;
  cursor: String;
}

export interface ProcessEdgePromise extends Promise<ProcessEdge>, Fragmentable {
  node: <T = ProcessPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProcessEdgeSubscription
  extends Promise<AsyncIterator<ProcessEdge>>,
    Fragmentable {
  node: <T = ProcessSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SourceTargetFieldmappingPreviousValues {
  SourceTargetFieldmappingID: ID_Output;
  FieldShortDesc?: String;
  FieldLongDesc?: String;
  SourceKey?: String;
  SourceKeyValue?: String;
  TargetKey?: String;
  TargetKeyValue?: String;
  OtherParam?: String;
}

export interface SourceTargetFieldmappingPreviousValuesPromise
  extends Promise<SourceTargetFieldmappingPreviousValues>,
    Fragmentable {
  SourceTargetFieldmappingID: () => Promise<ID_Output>;
  FieldShortDesc: () => Promise<String>;
  FieldLongDesc: () => Promise<String>;
  SourceKey: () => Promise<String>;
  SourceKeyValue: () => Promise<String>;
  TargetKey: () => Promise<String>;
  TargetKeyValue: () => Promise<String>;
  OtherParam: () => Promise<String>;
}

export interface SourceTargetFieldmappingPreviousValuesSubscription
  extends Promise<AsyncIterator<SourceTargetFieldmappingPreviousValues>>,
    Fragmentable {
  SourceTargetFieldmappingID: () => Promise<AsyncIterator<ID_Output>>;
  FieldShortDesc: () => Promise<AsyncIterator<String>>;
  FieldLongDesc: () => Promise<AsyncIterator<String>>;
  SourceKey: () => Promise<AsyncIterator<String>>;
  SourceKeyValue: () => Promise<AsyncIterator<String>>;
  TargetKey: () => Promise<AsyncIterator<String>>;
  TargetKeyValue: () => Promise<AsyncIterator<String>>;
  OtherParam: () => Promise<AsyncIterator<String>>;
}

export interface PluginParamConnection {
  pageInfo: PageInfo;
  edges: PluginParamEdge[];
}

export interface PluginParamConnectionPromise
  extends Promise<PluginParamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PluginParamEdge>>() => T;
  aggregate: <T = AggregatePluginParamPromise>() => T;
}

export interface PluginParamConnectionSubscription
  extends Promise<AsyncIterator<PluginParamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PluginParamEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePluginParamSubscription>() => T;
}

export interface ConnectorConnection {
  pageInfo: PageInfo;
  edges: ConnectorEdge[];
}

export interface ConnectorConnectionPromise
  extends Promise<ConnectorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ConnectorEdge>>() => T;
  aggregate: <T = AggregateConnectorPromise>() => T;
}

export interface ConnectorConnectionSubscription
  extends Promise<AsyncIterator<ConnectorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ConnectorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateConnectorSubscription>() => T;
}

export interface PluginCategoryConnection {
  pageInfo: PageInfo;
  edges: PluginCategoryEdge[];
}

export interface PluginCategoryConnectionPromise
  extends Promise<PluginCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PluginCategoryEdge>>() => T;
  aggregate: <T = AggregatePluginCategoryPromise>() => T;
}

export interface PluginCategoryConnectionSubscription
  extends Promise<AsyncIterator<PluginCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PluginCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePluginCategorySubscription>() => T;
}

export interface SubcriptionHistorySubscriptionPayload {
  mutation: MutationType;
  node: SubcriptionHistory;
  updatedFields: String[];
  previousValues: SubcriptionHistoryPreviousValues;
}

export interface SubcriptionHistorySubscriptionPayloadPromise
  extends Promise<SubcriptionHistorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubcriptionHistoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubcriptionHistoryPreviousValuesPromise>() => T;
}

export interface SubcriptionHistorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubcriptionHistorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubcriptionHistorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubcriptionHistoryPreviousValuesSubscription>() => T;
}

export interface AggregateLog {
  count: Int;
}

export interface AggregateLogPromise
  extends Promise<AggregateLog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLogSubscription
  extends Promise<AsyncIterator<AggregateLog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubcriptionHistoryPreviousValues {
  SubcriptionHistoryId: ID_Output;
  SubcriptionHistoryName: String;
  Status?: Status;
  CreatedBy: String;
  CreatedDate: DateTimeOutput;
  ModifiedBy: String;
  ModifiedDate: DateTimeOutput;
}

export interface SubcriptionHistoryPreviousValuesPromise
  extends Promise<SubcriptionHistoryPreviousValues>,
    Fragmentable {
  SubcriptionHistoryId: () => Promise<ID_Output>;
  SubcriptionHistoryName: () => Promise<String>;
  Status: () => Promise<Status>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface SubcriptionHistoryPreviousValuesSubscription
  extends Promise<AsyncIterator<SubcriptionHistoryPreviousValues>>,
    Fragmentable {
  SubcriptionHistoryId: () => Promise<AsyncIterator<ID_Output>>;
  SubcriptionHistoryName: () => Promise<AsyncIterator<String>>;
  Status: () => Promise<AsyncIterator<Status>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Process {
  ProcessId: ID_Output;
  ProcessShortDesc?: String;
  ProcessLongDesc?: String;
  Status?: Status;
  CreatedBy?: String;
  CreatedDate: DateTimeOutput;
  ModifiedDate: DateTimeOutput;
  ModifiedBy?: String;
}

export interface ProcessPromise extends Promise<Process>, Fragmentable {
  ProcessId: () => Promise<ID_Output>;
  ConnectorId: <T = ConnectorPromise>() => T;
  ProcessShortDesc: () => Promise<String>;
  ProcessLongDesc: () => Promise<String>;
  Status: () => Promise<Status>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  PrimaryEntity: <T = EntityPromise>() => T;
  SecondaryEntity: <T = EntityPromise>() => T;
}

export interface ProcessSubscription
  extends Promise<AsyncIterator<Process>>,
    Fragmentable {
  ProcessId: () => Promise<AsyncIterator<ID_Output>>;
  ConnectorId: <T = ConnectorSubscription>() => T;
  ProcessShortDesc: () => Promise<AsyncIterator<String>>;
  ProcessLongDesc: () => Promise<AsyncIterator<String>>;
  Status: () => Promise<AsyncIterator<Status>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  PrimaryEntity: <T = EntitySubscription>() => T;
  SecondaryEntity: <T = EntitySubscription>() => T;
}

export interface ProcessNullablePromise
  extends Promise<Process | null>,
    Fragmentable {
  ProcessId: () => Promise<ID_Output>;
  ConnectorId: <T = ConnectorPromise>() => T;
  ProcessShortDesc: () => Promise<String>;
  ProcessLongDesc: () => Promise<String>;
  Status: () => Promise<Status>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  PrimaryEntity: <T = EntityPromise>() => T;
  SecondaryEntity: <T = EntityPromise>() => T;
}

export interface PluginCategory {
  CategoryID: ID_Output;
  CategoryName: String;
  CategoryDesc?: String;
}

export interface PluginCategoryPromise
  extends Promise<PluginCategory>,
    Fragmentable {
  CategoryID: () => Promise<ID_Output>;
  CategoryName: () => Promise<String>;
  CategoryDesc: () => Promise<String>;
}

export interface PluginCategorySubscription
  extends Promise<AsyncIterator<PluginCategory>>,
    Fragmentable {
  CategoryID: () => Promise<AsyncIterator<ID_Output>>;
  CategoryName: () => Promise<AsyncIterator<String>>;
  CategoryDesc: () => Promise<AsyncIterator<String>>;
}

export interface PluginCategoryNullablePromise
  extends Promise<PluginCategory | null>,
    Fragmentable {
  CategoryID: () => Promise<ID_Output>;
  CategoryName: () => Promise<String>;
  CategoryDesc: () => Promise<String>;
}

export interface SubcriptionHistory {
  SubcriptionHistoryId: ID_Output;
  SubcriptionHistoryName: String;
  Status?: Status;
  CreatedBy: String;
  CreatedDate: DateTimeOutput;
  ModifiedBy: String;
  ModifiedDate: DateTimeOutput;
}

export interface SubcriptionHistoryPromise
  extends Promise<SubcriptionHistory>,
    Fragmentable {
  SubcriptionHistoryId: () => Promise<ID_Output>;
  TenantId: <T = UserPromise>() => T;
  ConnectorId: <T = ConnectorPromise>() => T;
  SubscriberID: <T = SubscriptionIntegrationPromise>() => T;
  SubcriptionHistoryName: () => Promise<String>;
  PrimaryPluginID: <T = PluginPromise>() => T;
  SecondaryPluginID: <T = PluginPromise>() => T;
  Status: () => Promise<Status>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface SubcriptionHistorySubscription
  extends Promise<AsyncIterator<SubcriptionHistory>>,
    Fragmentable {
  SubcriptionHistoryId: () => Promise<AsyncIterator<ID_Output>>;
  TenantId: <T = UserSubscription>() => T;
  ConnectorId: <T = ConnectorSubscription>() => T;
  SubscriberID: <T = SubscriptionIntegrationSubscription>() => T;
  SubcriptionHistoryName: () => Promise<AsyncIterator<String>>;
  PrimaryPluginID: <T = PluginSubscription>() => T;
  SecondaryPluginID: <T = PluginSubscription>() => T;
  Status: () => Promise<AsyncIterator<Status>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubcriptionHistoryNullablePromise
  extends Promise<SubcriptionHistory | null>,
    Fragmentable {
  SubcriptionHistoryId: () => Promise<ID_Output>;
  TenantId: <T = UserPromise>() => T;
  ConnectorId: <T = ConnectorPromise>() => T;
  SubscriberID: <T = SubscriptionIntegrationPromise>() => T;
  SubcriptionHistoryName: () => Promise<String>;
  PrimaryPluginID: <T = PluginPromise>() => T;
  SecondaryPluginID: <T = PluginPromise>() => T;
  Status: () => Promise<Status>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface SubscriberEntitySubscriptionPayload {
  mutation: MutationType;
  node: SubscriberEntity;
  updatedFields: String[];
  previousValues: SubscriberEntityPreviousValues;
}

export interface SubscriberEntitySubscriptionPayloadPromise
  extends Promise<SubscriberEntitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubscriberEntityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubscriberEntityPreviousValuesPromise>() => T;
}

export interface SubscriberEntitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubscriberEntitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubscriberEntitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubscriberEntityPreviousValuesSubscription>() => T;
}

export interface FieldMapConnection {
  pageInfo: PageInfo;
  edges: FieldMapEdge[];
}

export interface FieldMapConnectionPromise
  extends Promise<FieldMapConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FieldMapEdge>>() => T;
  aggregate: <T = AggregateFieldMapPromise>() => T;
}

export interface FieldMapConnectionSubscription
  extends Promise<AsyncIterator<FieldMapConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FieldMapEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFieldMapSubscription>() => T;
}

export interface SubscriberEntityPreviousValues {
  SubscriberEntityID: ID_Output;
  EntityName?: String;
  EntityType?: String;
  EntityShortDesc?: String;
  EntityLongDesc?: String;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
  Status?: Status;
}

export interface SubscriberEntityPreviousValuesPromise
  extends Promise<SubscriberEntityPreviousValues>,
    Fragmentable {
  SubscriberEntityID: () => Promise<ID_Output>;
  EntityName: () => Promise<String>;
  EntityType: () => Promise<String>;
  EntityShortDesc: () => Promise<String>;
  EntityLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  Status: () => Promise<Status>;
}

export interface SubscriberEntityPreviousValuesSubscription
  extends Promise<AsyncIterator<SubscriberEntityPreviousValues>>,
    Fragmentable {
  SubscriberEntityID: () => Promise<AsyncIterator<ID_Output>>;
  EntityName: () => Promise<AsyncIterator<String>>;
  EntityType: () => Promise<AsyncIterator<String>>;
  EntityShortDesc: () => Promise<AsyncIterator<String>>;
  EntityLongDesc: () => Promise<AsyncIterator<String>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  Status: () => Promise<AsyncIterator<Status>>;
}

export interface Testimonial {
  TestimonialID: ID_Output;
  Message?: String;
  Author?: String;
  Designation?: String;
  CompanyName?: String;
  ImageName?: String;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
}

export interface TestimonialPromise extends Promise<Testimonial>, Fragmentable {
  TestimonialID: () => Promise<ID_Output>;
  Message: () => Promise<String>;
  Author: () => Promise<String>;
  Designation: () => Promise<String>;
  CompanyName: () => Promise<String>;
  ImageName: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface TestimonialSubscription
  extends Promise<AsyncIterator<Testimonial>>,
    Fragmentable {
  TestimonialID: () => Promise<AsyncIterator<ID_Output>>;
  Message: () => Promise<AsyncIterator<String>>;
  Author: () => Promise<AsyncIterator<String>>;
  Designation: () => Promise<AsyncIterator<String>>;
  CompanyName: () => Promise<AsyncIterator<String>>;
  ImageName: () => Promise<AsyncIterator<String>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TestimonialNullablePromise
  extends Promise<Testimonial | null>,
    Fragmentable {
  TestimonialID: () => Promise<ID_Output>;
  Message: () => Promise<String>;
  Author: () => Promise<String>;
  Designation: () => Promise<String>;
  CompanyName: () => Promise<String>;
  ImageName: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface SubscriberFieldMapEdge {
  node: SubscriberFieldMap;
  cursor: String;
}

export interface SubscriberFieldMapEdgePromise
  extends Promise<SubscriberFieldMapEdge>,
    Fragmentable {
  node: <T = SubscriberFieldMapPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubscriberFieldMapEdgeSubscription
  extends Promise<AsyncIterator<SubscriberFieldMapEdge>>,
    Fragmentable {
  node: <T = SubscriberFieldMapSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SubscriberEntityMapSubscriptionPayload {
  mutation: MutationType;
  node: SubscriberEntityMap;
  updatedFields: String[];
  previousValues: SubscriberEntityMapPreviousValues;
}

export interface SubscriberEntityMapSubscriptionPayloadPromise
  extends Promise<SubscriberEntityMapSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubscriberEntityMapPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubscriberEntityMapPreviousValuesPromise>() => T;
}

export interface SubscriberEntityMapSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubscriberEntityMapSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubscriberEntityMapSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubscriberEntityMapPreviousValuesSubscription>() => T;
}

export interface SubscriberEntityMapEdge {
  node: SubscriberEntityMap;
  cursor: String;
}

export interface SubscriberEntityMapEdgePromise
  extends Promise<SubscriberEntityMapEdge>,
    Fragmentable {
  node: <T = SubscriberEntityMapPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubscriberEntityMapEdgeSubscription
  extends Promise<AsyncIterator<SubscriberEntityMapEdge>>,
    Fragmentable {
  node: <T = SubscriberEntityMapSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SubscriberEntityMapPreviousValues {
  SubscriberEntityMapID: ID_Output;
  Status?: Status;
  EntityShortDesc?: String;
  EntityLongDesc?: String;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
}

export interface SubscriberEntityMapPreviousValuesPromise
  extends Promise<SubscriberEntityMapPreviousValues>,
    Fragmentable {
  SubscriberEntityMapID: () => Promise<ID_Output>;
  Status: () => Promise<Status>;
  EntityShortDesc: () => Promise<String>;
  EntityLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface SubscriberEntityMapPreviousValuesSubscription
  extends Promise<AsyncIterator<SubscriberEntityMapPreviousValues>>,
    Fragmentable {
  SubscriberEntityMapID: () => Promise<AsyncIterator<ID_Output>>;
  Status: () => Promise<AsyncIterator<Status>>;
  EntityShortDesc: () => Promise<AsyncIterator<String>>;
  EntityLongDesc: () => Promise<AsyncIterator<String>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubcriptionHistoryEdge {
  node: SubcriptionHistory;
  cursor: String;
}

export interface SubcriptionHistoryEdgePromise
  extends Promise<SubcriptionHistoryEdge>,
    Fragmentable {
  node: <T = SubcriptionHistoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubcriptionHistoryEdgeSubscription
  extends Promise<AsyncIterator<SubcriptionHistoryEdge>>,
    Fragmentable {
  node: <T = SubcriptionHistorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ConnStrctjson {
  Name?: String;
  Label?: String;
  Value?: String;
  IsRequired?: Boolean;
  IsEditable?: Boolean;
  IsViewable?: Boolean;
  FieldType?: String;
  dropdownfieldName: String[];
  LookupValues: String[];
  SortOrder?: Int;
}

export interface ConnStrctjsonPromise
  extends Promise<ConnStrctjson>,
    Fragmentable {
  Name: () => Promise<String>;
  Label: () => Promise<String>;
  Value: () => Promise<String>;
  IsRequired: () => Promise<Boolean>;
  IsEditable: () => Promise<Boolean>;
  IsViewable: () => Promise<Boolean>;
  FieldType: () => Promise<String>;
  dropdownfieldName: () => Promise<String[]>;
  LookupValues: () => Promise<String[]>;
  SortOrder: () => Promise<Int>;
}

export interface ConnStrctjsonSubscription
  extends Promise<AsyncIterator<ConnStrctjson>>,
    Fragmentable {
  Name: () => Promise<AsyncIterator<String>>;
  Label: () => Promise<AsyncIterator<String>>;
  Value: () => Promise<AsyncIterator<String>>;
  IsRequired: () => Promise<AsyncIterator<Boolean>>;
  IsEditable: () => Promise<AsyncIterator<Boolean>>;
  IsViewable: () => Promise<AsyncIterator<Boolean>>;
  FieldType: () => Promise<AsyncIterator<String>>;
  dropdownfieldName: () => Promise<AsyncIterator<String[]>>;
  LookupValues: () => Promise<AsyncIterator<String[]>>;
  SortOrder: () => Promise<AsyncIterator<Int>>;
}

export interface ConnStrctjsonNullablePromise
  extends Promise<ConnStrctjson | null>,
    Fragmentable {
  Name: () => Promise<String>;
  Label: () => Promise<String>;
  Value: () => Promise<String>;
  IsRequired: () => Promise<Boolean>;
  IsEditable: () => Promise<Boolean>;
  IsViewable: () => Promise<Boolean>;
  FieldType: () => Promise<String>;
  dropdownfieldName: () => Promise<String[]>;
  LookupValues: () => Promise<String[]>;
  SortOrder: () => Promise<Int>;
}

export interface ScheduleConnection {
  pageInfo: PageInfo;
  edges: ScheduleEdge[];
}

export interface ScheduleConnectionPromise
  extends Promise<ScheduleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ScheduleEdge>>() => T;
  aggregate: <T = AggregateSchedulePromise>() => T;
}

export interface ScheduleConnectionSubscription
  extends Promise<AsyncIterator<ScheduleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ScheduleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateScheduleSubscription>() => T;
}

export interface SubscriberFieldSubscriptionPayload {
  mutation: MutationType;
  node: SubscriberField;
  updatedFields: String[];
  previousValues: SubscriberFieldPreviousValues;
}

export interface SubscriberFieldSubscriptionPayloadPromise
  extends Promise<SubscriberFieldSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubscriberFieldPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubscriberFieldPreviousValuesPromise>() => T;
}

export interface SubscriberFieldSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubscriberFieldSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubscriberFieldSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubscriberFieldPreviousValuesSubscription>() => T;
}

export interface AggregatePluginParam {
  count: Int;
}

export interface AggregatePluginParamPromise
  extends Promise<AggregatePluginParam>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePluginParamSubscription
  extends Promise<AsyncIterator<AggregatePluginParam>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubscriberFieldPreviousValues {
  SubscriberFieldID: ID_Output;
  FieldName?: String;
  DataType?: String;
  FieldType?: String;
  Status?: Status;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
}

export interface SubscriberFieldPreviousValuesPromise
  extends Promise<SubscriberFieldPreviousValues>,
    Fragmentable {
  SubscriberFieldID: () => Promise<ID_Output>;
  FieldName: () => Promise<String>;
  DataType: () => Promise<String>;
  FieldType: () => Promise<String>;
  Status: () => Promise<Status>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface SubscriberFieldPreviousValuesSubscription
  extends Promise<AsyncIterator<SubscriberFieldPreviousValues>>,
    Fragmentable {
  SubscriberFieldID: () => Promise<AsyncIterator<ID_Output>>;
  FieldName: () => Promise<AsyncIterator<String>>;
  DataType: () => Promise<AsyncIterator<String>>;
  FieldType: () => Promise<AsyncIterator<String>>;
  Status: () => Promise<AsyncIterator<Status>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PluginEdge {
  node: Plugin;
  cursor: String;
}

export interface PluginEdgePromise extends Promise<PluginEdge>, Fragmentable {
  node: <T = PluginPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PluginEdgeSubscription
  extends Promise<AsyncIterator<PluginEdge>>,
    Fragmentable {
  node: <T = PluginSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Plugin {
  PluginID: ID_Output;
  PluginName?: String;
  PluginTitle?: String;
  PluginShortName?: String;
  PluginSEOName?: String;
  PluginShortDesc?: String;
  PluginLongDesc?: String;
  AssemblyName?: String;
  Status?: Status;
  pluginType?: String;
  CreatedDate?: DateTimeOutput;
  CreatedBy?: String;
  ModifiedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ImageName?: String;
  ConnStructure?: <T = FragmentableArray<ConnStrctjson>>() => T;
  DefaultStructure?: String;
  ConnectUrl?: String;
  Popular?: Boolean;
  Recent?: Boolean;
}

export interface PluginPromise extends Promise<Plugin>, Fragmentable {
  PluginID: () => Promise<ID_Output>;
  PluginName: () => Promise<String>;
  PluginTitle: () => Promise<String>;
  PluginShortName: () => Promise<String>;
  PluginSEOName: () => Promise<String>;
  PluginShortDesc: () => Promise<String>;
  PluginLongDesc: () => Promise<String>;
  AssemblyName: () => Promise<String>;
  Status: () => Promise<Status>;
  pluginType: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  CreatedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ImageName: () => Promise<String>;
  ConnStructure: <T = FragmentableArray<ConnStrctjson>>() => T;
  DefaultStructure: () => Promise<String>;
  ConnectUrl: () => Promise<String>;
  Popular: () => Promise<Boolean>;
  Recent: () => Promise<Boolean>;
  PluginCategoryId: <T = PluginCategoryPromise>() => T;
}

export interface PluginSubscription
  extends Promise<AsyncIterator<Plugin>>,
    Fragmentable {
  PluginID: () => Promise<AsyncIterator<ID_Output>>;
  PluginName: () => Promise<AsyncIterator<String>>;
  PluginTitle: () => Promise<AsyncIterator<String>>;
  PluginShortName: () => Promise<AsyncIterator<String>>;
  PluginSEOName: () => Promise<AsyncIterator<String>>;
  PluginShortDesc: () => Promise<AsyncIterator<String>>;
  PluginLongDesc: () => Promise<AsyncIterator<String>>;
  AssemblyName: () => Promise<AsyncIterator<String>>;
  Status: () => Promise<AsyncIterator<Status>>;
  pluginType: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ImageName: () => Promise<AsyncIterator<String>>;
  ConnStructure: <T = Promise<AsyncIterator<ConnStrctjsonSubscription>>>() => T;
  DefaultStructure: () => Promise<AsyncIterator<String>>;
  ConnectUrl: () => Promise<AsyncIterator<String>>;
  Popular: () => Promise<AsyncIterator<Boolean>>;
  Recent: () => Promise<AsyncIterator<Boolean>>;
  PluginCategoryId: <T = PluginCategorySubscription>() => T;
}

export interface PluginNullablePromise
  extends Promise<Plugin | null>,
    Fragmentable {
  PluginID: () => Promise<ID_Output>;
  PluginName: () => Promise<String>;
  PluginTitle: () => Promise<String>;
  PluginShortName: () => Promise<String>;
  PluginSEOName: () => Promise<String>;
  PluginShortDesc: () => Promise<String>;
  PluginLongDesc: () => Promise<String>;
  AssemblyName: () => Promise<String>;
  Status: () => Promise<Status>;
  pluginType: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  CreatedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ImageName: () => Promise<String>;
  ConnStructure: <T = FragmentableArray<ConnStrctjson>>() => T;
  DefaultStructure: () => Promise<String>;
  ConnectUrl: () => Promise<String>;
  Popular: () => Promise<Boolean>;
  Recent: () => Promise<Boolean>;
  PluginCategoryId: <T = PluginCategoryPromise>() => T;
}

export interface SubscriptionIntegration {
  SubscriptionIntegrationId: ID_Output;
  NoOfLicenses?: String;
  NoOfUsers?: String;
  Status?: Status;
  SubscriptionStartDate: DateTimeOutput;
  SubscriptionEndDate?: DateTimeOutput;
  PrimaryPluginConnectionData?: <T = FragmentableArray<ConnStrctjson>>() => T;
  SecondaryPluginConnectionData?: <T = FragmentableArray<ConnStrctjson>>() => T;
  ConfigStructure?: <T = FragmentableArray<EntityConnStrctjson>>() => T;
}

export interface SubscriptionIntegrationPromise
  extends Promise<SubscriptionIntegration>,
    Fragmentable {
  SubscriptionIntegrationId: () => Promise<ID_Output>;
  NoOfLicenses: () => Promise<String>;
  NoOfUsers: () => Promise<String>;
  Status: () => Promise<Status>;
  TenantId: <T = UserPromise>() => T;
  ConnectorId: <T = ConnectorPromise>() => T;
  SubscriptionStartDate: () => Promise<DateTimeOutput>;
  SubscriptionEndDate: () => Promise<DateTimeOutput>;
  PrimaryPluginConnectionData: <T = FragmentableArray<ConnStrctjson>>() => T;
  SecondaryPluginConnectionData: <T = FragmentableArray<ConnStrctjson>>() => T;
  ConfigStructure: <T = FragmentableArray<EntityConnStrctjson>>() => T;
}

export interface SubscriptionIntegrationSubscription
  extends Promise<AsyncIterator<SubscriptionIntegration>>,
    Fragmentable {
  SubscriptionIntegrationId: () => Promise<AsyncIterator<ID_Output>>;
  NoOfLicenses: () => Promise<AsyncIterator<String>>;
  NoOfUsers: () => Promise<AsyncIterator<String>>;
  Status: () => Promise<AsyncIterator<Status>>;
  TenantId: <T = UserSubscription>() => T;
  ConnectorId: <T = ConnectorSubscription>() => T;
  SubscriptionStartDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  SubscriptionEndDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  PrimaryPluginConnectionData: <
    T = Promise<AsyncIterator<ConnStrctjsonSubscription>>
  >() => T;
  SecondaryPluginConnectionData: <
    T = Promise<AsyncIterator<ConnStrctjsonSubscription>>
  >() => T;
  ConfigStructure: <
    T = Promise<AsyncIterator<EntityConnStrctjsonSubscription>>
  >() => T;
}

export interface SubscriptionIntegrationNullablePromise
  extends Promise<SubscriptionIntegration | null>,
    Fragmentable {
  SubscriptionIntegrationId: () => Promise<ID_Output>;
  NoOfLicenses: () => Promise<String>;
  NoOfUsers: () => Promise<String>;
  Status: () => Promise<Status>;
  TenantId: <T = UserPromise>() => T;
  ConnectorId: <T = ConnectorPromise>() => T;
  SubscriptionStartDate: () => Promise<DateTimeOutput>;
  SubscriptionEndDate: () => Promise<DateTimeOutput>;
  PrimaryPluginConnectionData: <T = FragmentableArray<ConnStrctjson>>() => T;
  SecondaryPluginConnectionData: <T = FragmentableArray<ConnStrctjson>>() => T;
  ConfigStructure: <T = FragmentableArray<EntityConnStrctjson>>() => T;
}

export interface SubscriberFieldMapSubscriptionPayload {
  mutation: MutationType;
  node: SubscriberFieldMap;
  updatedFields: String[];
  previousValues: SubscriberFieldMapPreviousValues;
}

export interface SubscriberFieldMapSubscriptionPayloadPromise
  extends Promise<SubscriberFieldMapSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubscriberFieldMapPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubscriberFieldMapPreviousValuesPromise>() => T;
}

export interface SubscriberFieldMapSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubscriberFieldMapSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubscriberFieldMapSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubscriberFieldMapPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface SubscriberFieldMapPreviousValues {
  SubscriberFieldMapID: ID_Output;
  Status?: Status;
  FieldShortDesc?: String;
  FieldLongDesc?: String;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
}

export interface SubscriberFieldMapPreviousValuesPromise
  extends Promise<SubscriberFieldMapPreviousValues>,
    Fragmentable {
  SubscriberFieldMapID: () => Promise<ID_Output>;
  Status: () => Promise<Status>;
  FieldShortDesc: () => Promise<String>;
  FieldLongDesc: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface SubscriberFieldMapPreviousValuesSubscription
  extends Promise<AsyncIterator<SubscriberFieldMapPreviousValues>>,
    Fragmentable {
  SubscriberFieldMapID: () => Promise<AsyncIterator<ID_Output>>;
  Status: () => Promise<AsyncIterator<Status>>;
  FieldShortDesc: () => Promise<AsyncIterator<String>>;
  FieldLongDesc: () => Promise<AsyncIterator<String>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubscriberFieldEdge {
  node: SubscriberField;
  cursor: String;
}

export interface SubscriberFieldEdgePromise
  extends Promise<SubscriberFieldEdge>,
    Fragmentable {
  node: <T = SubscriberFieldPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubscriberFieldEdgeSubscription
  extends Promise<AsyncIterator<SubscriberFieldEdge>>,
    Fragmentable {
  node: <T = SubscriberFieldSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TestimonialPreviousValues {
  TestimonialID: ID_Output;
  Message?: String;
  Author?: String;
  Designation?: String;
  CompanyName?: String;
  ImageName?: String;
  CreatedBy?: String;
  CreatedDate?: DateTimeOutput;
  ModifiedBy?: String;
  ModifiedDate?: DateTimeOutput;
}

export interface TestimonialPreviousValuesPromise
  extends Promise<TestimonialPreviousValues>,
    Fragmentable {
  TestimonialID: () => Promise<ID_Output>;
  Message: () => Promise<String>;
  Author: () => Promise<String>;
  Designation: () => Promise<String>;
  CompanyName: () => Promise<String>;
  ImageName: () => Promise<String>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  ModifiedDate: () => Promise<DateTimeOutput>;
}

export interface TestimonialPreviousValuesSubscription
  extends Promise<AsyncIterator<TestimonialPreviousValues>>,
    Fragmentable {
  TestimonialID: () => Promise<AsyncIterator<ID_Output>>;
  Message: () => Promise<AsyncIterator<String>>;
  Author: () => Promise<AsyncIterator<String>>;
  Designation: () => Promise<AsyncIterator<String>>;
  CompanyName: () => Promise<AsyncIterator<String>>;
  ImageName: () => Promise<AsyncIterator<String>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SourceTargetFieldmappingConnection {
  pageInfo: PageInfo;
  edges: SourceTargetFieldmappingEdge[];
}

export interface SourceTargetFieldmappingConnectionPromise
  extends Promise<SourceTargetFieldmappingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SourceTargetFieldmappingEdge>>() => T;
  aggregate: <T = AggregateSourceTargetFieldmappingPromise>() => T;
}

export interface SourceTargetFieldmappingConnectionSubscription
  extends Promise<AsyncIterator<SourceTargetFieldmappingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<SourceTargetFieldmappingEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateSourceTargetFieldmappingSubscription>() => T;
}

export interface SubscriberProcessSubscriptionPayload {
  mutation: MutationType;
  node: SubscriberProcess;
  updatedFields: String[];
  previousValues: SubscriberProcessPreviousValues;
}

export interface SubscriberProcessSubscriptionPayloadPromise
  extends Promise<SubscriberProcessSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubscriberProcessPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubscriberProcessPreviousValuesPromise>() => T;
}

export interface SubscriberProcessSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubscriberProcessSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubscriberProcessSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubscriberProcessPreviousValuesSubscription>() => T;
}

export interface AggregatePluginCategory {
  count: Int;
}

export interface AggregatePluginCategoryPromise
  extends Promise<AggregatePluginCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePluginCategorySubscription
  extends Promise<AsyncIterator<AggregatePluginCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateFieldMap {
  count: Int;
}

export interface AggregateFieldMapPromise
  extends Promise<AggregateFieldMap>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFieldMapSubscription
  extends Promise<AsyncIterator<AggregateFieldMap>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubscriptionIntegrationPreviousValues {
  SubscriptionIntegrationId: ID_Output;
  NoOfLicenses?: String;
  NoOfUsers?: String;
  Status?: Status;
  SubscriptionStartDate: DateTimeOutput;
  SubscriptionEndDate?: DateTimeOutput;
}

export interface SubscriptionIntegrationPreviousValuesPromise
  extends Promise<SubscriptionIntegrationPreviousValues>,
    Fragmentable {
  SubscriptionIntegrationId: () => Promise<ID_Output>;
  NoOfLicenses: () => Promise<String>;
  NoOfUsers: () => Promise<String>;
  Status: () => Promise<Status>;
  SubscriptionStartDate: () => Promise<DateTimeOutput>;
  SubscriptionEndDate: () => Promise<DateTimeOutput>;
}

export interface SubscriptionIntegrationPreviousValuesSubscription
  extends Promise<AsyncIterator<SubscriptionIntegrationPreviousValues>>,
    Fragmentable {
  SubscriptionIntegrationId: () => Promise<AsyncIterator<ID_Output>>;
  NoOfLicenses: () => Promise<AsyncIterator<String>>;
  NoOfUsers: () => Promise<AsyncIterator<String>>;
  Status: () => Promise<AsyncIterator<Status>>;
  SubscriptionStartDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  SubscriptionEndDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubscriptionIntegrationSubscriptionPayload {
  mutation: MutationType;
  node: SubscriptionIntegration;
  updatedFields: String[];
  previousValues: SubscriptionIntegrationPreviousValues;
}

export interface SubscriptionIntegrationSubscriptionPayloadPromise
  extends Promise<SubscriptionIntegrationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubscriptionIntegrationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubscriptionIntegrationPreviousValuesPromise>() => T;
}

export interface SubscriptionIntegrationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubscriptionIntegrationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubscriptionIntegrationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = SubscriptionIntegrationPreviousValuesSubscription
  >() => T;
}

export interface TestimonialSubscriptionPayload {
  mutation: MutationType;
  node: Testimonial;
  updatedFields: String[];
  previousValues: TestimonialPreviousValues;
}

export interface TestimonialSubscriptionPayloadPromise
  extends Promise<TestimonialSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TestimonialPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TestimonialPreviousValuesPromise>() => T;
}

export interface TestimonialSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TestimonialSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TestimonialSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TestimonialPreviousValuesSubscription>() => T;
}

export interface SubscriberProcessPreviousValues {
  SubscriberProcessID: ID_Output;
  Status?: Status;
  Stage?: Stage;
  CreatedBy?: String;
  CreatedDate: DateTimeOutput;
  ModifiedDate: DateTimeOutput;
  ModifiedBy?: String;
  LastSyncDate?: String;
}

export interface SubscriberProcessPreviousValuesPromise
  extends Promise<SubscriberProcessPreviousValues>,
    Fragmentable {
  SubscriberProcessID: () => Promise<ID_Output>;
  Status: () => Promise<Status>;
  Stage: () => Promise<Stage>;
  CreatedBy: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  ModifiedBy: () => Promise<String>;
  LastSyncDate: () => Promise<String>;
}

export interface SubscriberProcessPreviousValuesSubscription
  extends Promise<AsyncIterator<SubscriberProcessPreviousValues>>,
    Fragmentable {
  SubscriberProcessID: () => Promise<AsyncIterator<ID_Output>>;
  Status: () => Promise<AsyncIterator<Status>>;
  Stage: () => Promise<AsyncIterator<Stage>>;
  CreatedBy: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedBy: () => Promise<AsyncIterator<String>>;
  LastSyncDate: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSubscriberProcess {
  count: Int;
}

export interface AggregateSubscriberProcessPromise
  extends Promise<AggregateSubscriberProcess>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubscriberProcessSubscription
  extends Promise<AsyncIterator<AggregateSubscriberProcess>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LogConnection {
  pageInfo: PageInfo;
  edges: LogEdge[];
}

export interface LogConnectionPromise
  extends Promise<LogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LogEdge>>() => T;
  aggregate: <T = AggregateLogPromise>() => T;
}

export interface LogConnectionSubscription
  extends Promise<AsyncIterator<LogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLogSubscription>() => T;
}

export interface ProcessHistory {
  ProcessHistoryId: ID_Output;
  LastSyncDate?: String;
  CreatedDate: DateTimeOutput;
  ModifiedDate: DateTimeOutput;
  Stage?: Stage;
}

export interface ProcessHistoryPromise
  extends Promise<ProcessHistory>,
    Fragmentable {
  ProcessHistoryId: () => Promise<ID_Output>;
  ProcessId: <T = ProcessPromise>() => T;
  TenantId: <T = UserPromise>() => T;
  LastSyncDate: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  Stage: () => Promise<Stage>;
}

export interface ProcessHistorySubscription
  extends Promise<AsyncIterator<ProcessHistory>>,
    Fragmentable {
  ProcessHistoryId: () => Promise<AsyncIterator<ID_Output>>;
  ProcessId: <T = ProcessSubscription>() => T;
  TenantId: <T = UserSubscription>() => T;
  LastSyncDate: () => Promise<AsyncIterator<String>>;
  CreatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  ModifiedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  Stage: () => Promise<AsyncIterator<Stage>>;
}

export interface ProcessHistoryNullablePromise
  extends Promise<ProcessHistory | null>,
    Fragmentable {
  ProcessHistoryId: () => Promise<ID_Output>;
  ProcessId: <T = ProcessPromise>() => T;
  TenantId: <T = UserPromise>() => T;
  LastSyncDate: () => Promise<String>;
  CreatedDate: () => Promise<DateTimeOutput>;
  ModifiedDate: () => Promise<DateTimeOutput>;
  Stage: () => Promise<Stage>;
}

export interface SubscriberEntityEdge {
  node: SubscriberEntity;
  cursor: String;
}

export interface SubscriberEntityEdgePromise
  extends Promise<SubscriberEntityEdge>,
    Fragmentable {
  node: <T = SubscriberEntityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubscriberEntityEdgeSubscription
  extends Promise<AsyncIterator<SubscriberEntityEdge>>,
    Fragmentable {
  node: <T = SubscriberEntitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Status",
    embedded: false
  },
  {
    name: "Stage",
    embedded: false
  },
  {
    name: "Stages",
    embedded: false
  },
  {
    name: "ConnStrctjson",
    embedded: true
  },
  {
    name: "EntityConnStrctjson",
    embedded: true
  },
  {
    name: "Plugin",
    embedded: false
  },
  {
    name: "Entity",
    embedded: false
  },
  {
    name: "EntityMap",
    embedded: false
  },
  {
    name: "SubcriptionHistory",
    embedded: false
  },
  {
    name: "Schedule",
    embedded: false
  },
  {
    name: "Log",
    embedded: false
  },
  {
    name: "PluginCategory",
    embedded: false
  },
  {
    name: "Connector",
    embedded: false
  },
  {
    name: "Process",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "SubscriptionIntegration",
    embedded: false
  },
  {
    name: "Field",
    embedded: false
  },
  {
    name: "FieldMap",
    embedded: false
  },
  {
    name: "PluginParam",
    embedded: false
  },
  {
    name: "Testimonial",
    embedded: false
  },
  {
    name: "DBClaims",
    embedded: false
  },
  {
    name: "DatabaseUser",
    embedded: false
  },
  {
    name: "ProcessHistory",
    embedded: false
  },
  {
    name: "SubscriberProcess",
    embedded: false
  },
  {
    name: "SubscriberEntity",
    embedded: false
  },
  {
    name: "SubscriberEntityMap",
    embedded: false
  },
  {
    name: "SubscriberField",
    embedded: false
  },
  {
    name: "SubscriberFieldMap",
    embedded: false
  },
  {
    name: "SourceTargetFieldmapping",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
